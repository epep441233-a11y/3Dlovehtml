<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <title>æ¸´æ„›_è¢«æ„›çš„å‰ææ˜¯ä»€éº¼ Â©2025ä¾†äº†å“ˆå“ˆ(æœ‰ç‚º)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="æ¸´æ„›">
    <link rel="apple-touch-icon" href="https://i.postimg.cc/bYkg2tTX/icon.png">
    <link rel="icon" type="image/png" href="https://i.postimg.cc/bYkg2tTX/icon.png">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="orientation-overlay" class="overlay">
        <img src="https://i.postimg.cc/fWG82BdM/duck.png" alt="è«‹æ—‹è½‰è£ç½®">
        
        <p>ç‚ºäº†ç²å¾—æœ€ä½³é«”é©—ï¼Œè«‹å°‡æ‚¨çš„è£ç½®æ—‹è½‰ç‚ºæ©«å‘</p>
        
        <p style="font-size: 14px; color: #ccc; margin-top: 5px;">(è˜‹æœç”¨æˆ¶å¯åœ¨ç€è¦½å™¨é»æ“Šåˆ†äº«â†’æ–°å¢è‡³ä¸»ç•«é¢ï¼Œæ‰èƒ½è§¸ç™¼å…¨è¢å¹•)</p>
    </div>
    <svg style="display: none;">
        <defs>
            <filter id="rgb-split-filter" x="-20%" y="-20%" width="140%" height="140%">
                <feColorMatrix in="SourceGraphic" type="matrix" 
                    values="1 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0" result="red-channel"/>
                <feColorMatrix in="SourceGraphic" type="matrix" 
                    values="0 0 0 0 0  0 1 0 0 0  0 0 0 0 0  0 0 0 1 0" result="green-channel"/>
                <feColorMatrix in="SourceGraphic" type="matrix" 
                    values="0 0 0 0 0  0 0 0 0 0  0 0 1 0 0  0 0 0 1 0" result="blue-channel"/>
                
                <feOffset in="red-channel" dx="0" dy="0" result="red-offset" id="svg-offset-red"/>
                <feOffset in="blue-channel" dx="0" dy="0" result="blue-offset" id="svg-offset-blue"/>

                <feBlend mode="screen" in="red-offset" in2="green-channel" result="rg"/>
                <feBlend mode="screen" in="rg" in2="blue-offset" result="final"/>
            </filter>
        </defs>
    </svg>
    <div id="scene-container"></div>

    <div id="fps-counter" style="position: absolute; left: 1%; bottom: 1%; z-index: 666; font-family: 'Courier New', monospace; font-size: 12px; font-weight: bold; pointer-events: none; text-shadow: 1px 1px 2px black; display: none;"></div>

    <div id="loading-overlay" class="overlay" style="display: none; z-index: 3000; background-color: rgba(0,0,0,0.85);">
        <p style="font-size: 24px; color: #fffc58; letter-spacing: 2px;">æ­£åœ¨æº–å‚™é€šå¾€çœŸå¯¦â€¦</p>
    </div>
   
    <div id="start-screen" class="overlay">
    <div id="start-bg-container">
        <img id="start-bg-image" src="https://i.postimg.cc/fRYYj7wT/opendoor-2.jpg" alt="éŠæˆ²èƒŒæ™¯">
    </div>

    <img id="start-fg-image" src="https://i.postimg.cc/rFBY5SVZ/opendoor1-2.png" alt="éŠæˆ²æ–‡å­—">

    <div id="info-icon">âœ‰ï¸<span id="info-badge">1</span></div>

    <div id="brain-icon">ğŸ§ </div>

    <div id="brain-modal" class="overlay" style="display: none;">
        <div id="brain-modal-content">
            </div>
    </div>

</div> <div id="end-door-icon">ğŸšª</div>
    
<div id="info-modal" class="overlay" style="display: none;">
        <div id="info-modal-content">
        </div>
    </div>

<div id="ending-overlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 200; background-color: white; opacity: 0; transition: opacity 2s ease-in-out; pointer-events: auto;">
        <div id="cleanup-loading-text" style="display: none; position: absolute; bottom: 20px; right: 20px; color: #ccc; font-size: 14px; letter-spacing: 2px;">è¼‰å…¥ä¸­...</div>
    </div>

    <div id="ending-image-container" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 201; background-color: white; align-items: center; justify-content: center;">
        <img id="ending-img-a" src="https://i.postimg.cc/9F1Zqgyg/finishdoor0.jpg" style="position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity 1s;">
        <img id="ending-img-b" src="https://i.postimg.cc/wvPDSYBp/finishdoor.jpg" style="position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity 1s;">
        <img id="ending-img-c" src="https://i.postimg.cc/fLX12Xzy/finishdoor2.png" style="position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity 1s;">
    </div>
    <div id="skill-warning" style="position: absolute; left: 50%; bottom: 66%; transform: translateX(-50%); color: #e12424; font-size: 18px; font-weight: normal; text-shadow: none; letter-spacing: 9px; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 9999; white-space: nowrap; font-family: 'Courier New', Courier, monospace;"></div>
    <div id="game-over-screen" class="overlay" style="display: none;">
        <h1></h1>
        <p>é»æ“Šç•«é¢é‡æ–°æ¢ç´¢</p>
    </div>
    
    <canvas id="treasure-canvas"></canvas>
    <div id="treasure-counter-text" class="ui-element"></div>

    <div id="san-bar-container" class="ui-element">
        <span>SAN</span>
        <div id="san-bar-outer">
            <div id="san-bar-phantom"></div>
            <div id="san-bar-inner"></div>
        </div>
    </div>
    
    <div id="status-effect-container">

        </div>
    
    <div id="joystick-base"></div> <div id="joystick-handle"></div>
    <div id="noise-overlay" class="noise-layer"></div>
    <canvas id="vignette-canvas"></canvas>
    <div id="chromatic-red" class="chromatic-layer"></div>
    <div id="chromatic-blue" class="chromatic-layer"></div>
    <canvas id="trauma-vignette-canvas"></canvas>
    <canvas id="glitch-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 99; display: none;"></canvas>
    
    <img id="tsundere-explosion-img" src="https://i.postimg.cc/Bnkc9KsJ/ao-jiao-shi-zhong.png">

    <!-- ä¸€éµé€šé—œ -->
    <button id="debug-win-btn" style="position: absolute; top: 129px; left: 10px; z-index: 1000; padding: 5px 8px; font-size: 12px; letter-spacing: 1px; background: rgb(255, 231, 110); color: rgb(139, 165, 251); border: 2px solid rgb(255, 146, 69);  cursor: pointer; opacity: 0.6; display: none;">ä¸€éµèª²é‡‘é€šé—œ</button> 

    <button id="debug-hidden-win-btn" style="position: absolute; top: 162px; left: 10px; z-index: 1000; padding: 5px 8px; font-size: 12px; letter-spacing: 1px; background: rgb(73, 115, 222); color: rgb(234, 194, 119); border: 2px solid rgb(31, 65, 216);  cursor: pointer; opacity: 0.6; display: none;">æš´é›·éš±è—çµå±€</button>

    <div id="bubble-shoot-button" style="position: absolute; right: 5%; bottom: 5%; width: 130px; height: 130px; background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(100, 200, 255, 0.5); border-radius: 50%; display: none; justify-content: center; align-items: center; z-index: 21; cursor: pointer; backdrop-filter: blur(2px);">
        <div style="font-size: 60px;">ğŸ’¦</div>
        <div id="bubble-ammo-count" style="position: absolute; top: 0; right: 0; width: 32px; height: 32px; background-color: #666; border: 2px solid white; border-radius: 50%; color: white; font-size: 14px; font-weight: bold; display: flex; justify-content: center; align-items: center; z-index: 22;">15</div>
        
        <svg class="cooldown-ring" width="130" height="130" style="position: absolute; top: 0; left: 0; transform: rotate(-90deg);">
            <circle cx="65" cy="65" r="60" stroke="rgba(100, 200, 255, 0.8)" stroke-width="5" fill="none" stroke-dasharray="377" stroke-dashoffset="0" style="transition: stroke-dashoffset 0.1s linear;"></circle>
        </svg>
    </div>

    <!-- æŠ€èƒ½æŒ‰éµ (å¤§Eäºº) -->
    <div id="skill-button">
        <div id="skill-icon">â™Ÿï¸</div>
    </div>

    <div id="shoot-button">
<svg id="taijitu-icon" viewBox="0 0 100 100">
    <defs>
        <path id="taijitu-drop" d="M50,0 A50,50 0 0,0 50,100 A25,25 0 0,1 50,50 A25,25 0 0,0 50,0 Z"></path>
    </defs>
    <use href="#taijitu-drop" fill="#372d40" />
    <use href="#taijitu-drop" fill="#f2ecc9" transform="rotate(180, 50, 50)" />
    <circle cx="50" cy="25" r="10" fill="#f2ecc9"></circle>
    <circle cx="50" cy="75" r="10" fill="#372d40"></circle>
</svg>
    <div id="cooldown-timer"></div>
    <div id="ammo-counter"></div>
</div>

    <div id="boss-hp-container">
    <div id="boss-hp-title">FÌ‡AÌ‡LÌ‡SÌ‡EÌ‡ FÌ‡AÌ‡CÌ§AÌ‡DÌ‡EÌ‡</div>
    <div id="boss-hp-frame">
        <div id="boss-hp-inner">
            <div id="boss-hp-fill"></div>
        </div>
    </div>
</div>

    <div id="chaos-hp-container">
        <div id="chaos-hp-icon">ğŸ’¥</div>
        <div id="chaos-hp-frame">
            <div id="chaos-hp-inner">
                <div id="chaos-hp-fill"></div>
            </div>
        </div>
    </div>

    <div id="collection-ui">
        <div id="collection-text">æ‹¾å›è‡ªæˆ‘ä¸­...</div>
        <div id="collection-bar-container">
            <div id="collection-bar-fill"></div>
        </div>
    </div>

<div id="intro-layer-b" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9000; background-color: #ffffff; transition: opacity 0.9s ease-in-out;">
    <img src="https://i.postimg.cc/bdXFkNsW/0opendoor2.jpg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
</div>

<div id="intro-layer-a" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9001; background-color: #ffffff; transition: opacity 0.9s ease-in-out;">
    <img src="https://i.postimg.cc/90SHShzJ/0opendoor1.jpg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
</div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        // [æ–°å¢] åŒ¯å…¥è³‡æ–™èˆ‡å·¥å…·
        import { 
            gameDescription, DUCK_SETTINGS, DUCK_NOD_SETTINGS, 
            FEAR_ERUPTION_CONFIG, TRAUMA_REACTION_CONFIG, TRAUMA_VIGNETTE_CONFIG, 
            MOYING_CONFIG, ZODIAC_SYMBOLS, BRAIN_DATA 
        } from './data.js';

        import { setupManagers, bossManager, moyingManager, duckManager, shieldCageManager, weatherManager } from './managers.js';
        import { 
            statusEffectManager, erosionSystem, bindStatusContext, 
            updateStatusSystem, handlePushEffect, resetStatusSystem, 
            addProjectionStack, updateErosionUI 
        } from './status_system.js';
        import { bindSkillContext, setupSkillButton, resetAllSkills, updateSkills, impatientManager, tsundereManager, forceHideSkillUI } from './skills.js';

        import { 
            createDoorLightTexture, createSolidCageTexture, createHexShieldTexture,
            createYanBaseTexture, createYanParticleTexture, createGlowTexture,
            createShadowTexture, createSmileyTexture, createWhiteGlowTexture,
            createSymbolTexture, createGlowSymbolTexture, createPortalMaterial,
            createChaosOrbMaterial, createLaserMaterial, createBossOrbMaterial,
            createOrbMaterial, createAuroraMaterial
        } from './utils.js';
        document.addEventListener('contextmenu', event => event.preventDefault());
        // [æ–°å¢] ç¦æ­¢åœ–ç‰‡æ‹–æ›³
        document.addEventListener('dragstart', event => event.preventDefault());

        // [æ–°å¢] èƒŒæ™¯æ¼¸é€²å¼æ¸…ç†æ ¸å¿ƒ
        let cleanupQueue = []; 
        let cleanupRequestId = null;
        
        // [æ–°å¢] çµå±€æµç¨‹è¨ˆæ™‚å™¨ç®¡ç†å™¨ (è§£æ±ºé‡ç©å¾Œç™¼ç”Ÿéˆç•°ç¾è±¡çš„é—œéµ)
        let endingTimeouts = []; 

        // [æ–°å¢] è¼”åŠ©å‡½å¼ï¼šè¨­å®šå¯è¢«å–æ¶ˆçš„ Timeout
        function setGameTimeout(callback, delay) {
            const id = setTimeout(callback, delay);
            endingTimeouts.push(id);
            return id;
        }

        // [æ–°å¢] è¼”åŠ©å‡½å¼ï¼šå¼·åˆ¶æ®ºæ­»æ‰€æœ‰è¨ˆæ™‚å™¨
        function clearAllGameTimeouts() {
            endingTimeouts.forEach(id => clearTimeout(id));
            endingTimeouts = [];
        }
        let infoIcon, infoModal, infoModalContent, infoBadge, startBgContainer, startFgImage, bossHpContainer, bossHpFill, chaosHpContainer, chaosHpFill;
        let brainIcon, brainModal, brainModalContent;

        const moyingTextures = []; // å­˜æ”¾5å¼µåœ–ç‰‡

        function updateTraumaVignette() {
        const canvas = document.getElementById('trauma-vignette-canvas');
        if (!canvas) return;

        if (player.userData.isTraumaActive) {
            canvas.style.display = 'block';
            const ctx = canvas.getContext('2d');
            // ç¢ºä¿ canvas å°ºå¯¸èˆ‡è¦–çª—ä¸€è‡´
            if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            const w = canvas.width;
            const h = canvas.height;

            ctx.clearRect(0, 0, w, h);

            const centerX = w / 2;
            const centerY = h / 2;
            const innerRadius = w * TRAUMA_VIGNETTE_CONFIG.SIZE;
            const outerRadius = w * TRAUMA_VIGNETTE_CONFIG.FEATHER;

            const gradient = ctx.createRadialGradient(centerX, centerY, innerRadius, centerX, centerY, outerRadius);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, TRAUMA_VIGNETTE_CONFIG.COLOR);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, w, h);
        } else {
            canvas.style.display = 'none';
        }
    }
        

    // --- å¤§è…¦é¸å–®ç®¡ç†å™¨ (å‡ç´šç‰ˆ) ---
    const brainMenuSystem = {
        currentTab: 'status', 
        selectedPersonality: null, // ç”¨ä¾†è¨˜æ†¶ç©å®¶é¸äº†å“ªå€‹æ€§æ ¼

        tabs: {
            personality: { 
                label: 'æ€§æ ¼', 
                desc: 'ä¸åŒæ€§æ ¼çš„äººï¼Œéƒ½æœ‰ä¸åŒå„ªå‹¢(å¯é¸æ“‡ä¸€ç¨®æ€§æ ¼)',
                render: () => brainMenuSystem.renderPersonality() 
            },
            status: { 
                label: 'ç‹€æ…‹', 
                desc: 'ç‹€æ…‹å°‡å½±éŸ¿ä¸€å€‹äººçš„ç™¼æ®',
                render: () => brainMenuSystem.renderStatus() 
            },
            experience: { 
                label: 'ç¶“é©—', 
                desc: 'ç¶“é©—æœƒå½±éŸ¿èªçŸ¥èˆ‡åˆ¤æ–·ï¼Œä¸ç®¡é€™èªçŸ¥æ˜¯â€œæ‰­æ›²çš„â€é‚„æ˜¯â€œå°çš„â€',
                render: () => brainMenuSystem.renderExperience() 
            },
            achievement: { 
                label: 'æˆå°±', 
                desc: 'æˆå°±æ„Ÿæ˜¯å‰é€²çš„å‹•åŠ›ã€å­˜åœ¨çš„ç†ç”±',
                render: () => brainMenuSystem.renderAchievement() 
            }
        },

        open: function(defaultTab = 'status') {
            this.currentTab = defaultTab;
            const contentDiv = document.getElementById('brain-modal-content');
            contentDiv.innerHTML = ''; 

            const tabsContainer = document.createElement('div');
            tabsContainer.className = 'brain-tabs';
            
            const descContainer = document.createElement('div');
            descContainer.className = 'brain-cat-desc';
            descContainer.id = 'brain-cat-text';

            const mainView = document.createElement('div');
            mainView.className = 'brain-main-view';
            mainView.id = 'brain-main-area';

            // åº•éƒ¨è³‡è¨Šé¢æ¿ (é€™å¡Šæˆ‘å€‘æœƒæ ¹æ“šåˆ†é å‹•æ…‹é¡¯ç¤º/éš±è—)
            const infoPanel = document.createElement('div');
            infoPanel.className = 'brain-info-panel';
            infoPanel.id = 'brain-info-panel'; // åŠ  ID æ–¹ä¾¿é¸å–
            infoPanel.innerHTML = `<div id="brain-info-title" class="brain-info-title"></div><div id="brain-info-text" class="brain-info-text"></div>`;

            Object.keys(this.tabs).forEach(key => {
                const btn = document.createElement('button');
                btn.className = 'brain-tab-btn';
                if(key === this.currentTab) btn.classList.add('active');
                btn.innerText = this.tabs[key].label;
                btn.onclick = () => this.switchTab(key);
                tabsContainer.appendChild(btn);
            });

            contentDiv.appendChild(tabsContainer);
            contentDiv.appendChild(descContainer);
            contentDiv.appendChild(mainView);
            contentDiv.appendChild(infoPanel);

            this.switchTab(this.currentTab);
            
            document.getElementById('brain-modal').style.display = 'flex';
            document.getElementById('brain-modal').style.zIndex = '3000';
        },

        switchTab: function(tabKey) {
            this.currentTab = tabKey;
            
            // 1. æ›´æ–°æŒ‰éˆ•æ¨£å¼
            const btns = document.querySelectorAll('.brain-tab-btn');
            btns.forEach((btn, index) => {
                const keys = Object.keys(this.tabs);
                if(keys[index] === tabKey) btn.classList.add('active');
                else btn.classList.remove('active');
            });

            // 2. æ›´æ–°å“²å­¸æ–‡å­—
            document.getElementById('brain-cat-text').innerText = this.tabs[tabKey].desc;

            // 3. æ¸…ç©ºä¸»è¦å€åŸŸ
            const mainArea = document.getElementById('brain-main-area');
            mainArea.innerHTML = '';
            
            // 4. [é—œéµä¿®æ”¹] æ ¹æ“šåˆ†é æ±ºå®šæ˜¯å¦é¡¯ç¤ºä¸‹æ–¹æ–‡å­—å€å¡Š
            const infoPanel = document.getElementById('brain-info-panel');
            if (tabKey === 'personality' || tabKey === 'status' || tabKey === 'experience') {
                infoPanel.style.display = 'none'; 
            } else {
                infoPanel.style.display = 'block'; 
                this.updateInfo('', 'è«‹é¸æ“‡ä¸€å€‹é …ç›®æŸ¥çœ‹è©³æƒ…...'); 
            }

            // 5. æ¸²æŸ“å…§å®¹
            this.tabs[tabKey].render();
        },

        updateInfo: function(title, text) {
            const titleEl = document.getElementById('brain-info-title');
            const textEl = document.getElementById('brain-info-text');
            if(titleEl) titleEl.innerText = title;
            if(textEl) textEl.innerText = text;
        },

        // --- 1. æ€§æ ¼æ¸²æŸ“ ---
        renderPersonality: function() {
            const container = document.getElementById('brain-main-area');
            // [ä¿®æ”¹] æ”¹ç‚ºå¾ data.js è®€å–
            const personalities = BRAIN_DATA.personalities;

            personalities.forEach(p => {
                const div = document.createElement('div');
                div.className = 'personality-item';
                div.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: flex-start;">
                        <div style="font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 6px;">${p.name}</div>
                        <div style="font-size: 13px; color: #dadada; line-height: 1.4; text-align: left;">${p.desc}</div>
                    </div>
                `;
                
                if (this.selectedPersonality === p.id) {
                    div.classList.add('selected');
                }

                div.onclick = () => {
                    // [ä¿®æ”¹] åŠ å…¥å–æ¶ˆé¸å–é‚è¼¯ (é»æ“Šå·²é¸å–çš„æœƒè®Šæˆæœªé¸å–)
                    if (this.selectedPersonality === p.id) {
                        this.selectedPersonality = null; // æ¸…ç©ºé¸æ“‡
                        div.classList.remove('selected'); // ç§»é™¤æ¨£å¼
                        console.log('å·²å–æ¶ˆé¸æ“‡æ€§æ ¼ (ç„¡æŠ€èƒ½æ¨¡å¼)');
                    } else {
                        // åŸæœ¬çš„é¸å–é‚è¼¯
                        this.selectedPersonality = p.id;
                        document.querySelectorAll('.personality-item').forEach(el => el.classList.remove('selected'));
                        div.classList.add('selected');
                        console.log('å·²é¸æ“‡æ€§æ ¼:', p.name); 
                    }
                };
                container.appendChild(div);
            });
        },

        // --- 2. ç‹€æ…‹æ¸²æŸ“ ---
        renderStatus: function() {
            const container = document.getElementById('brain-main-area');
            const data = statusEffectManager.statusData;
            let hasStatus = false;

            for (const key in data) {
                hasStatus = true;
                const status = data[key];
                const entry = document.createElement('div');
                entry.className = 'status-entry-row';
                // é€™è£¡ä¿ç•™æè¿°åœ¨åˆ—è¡¨å…§ï¼Œå› ç‚ºä¸‹æ–¹å€å¡Šè¢«æˆ‘å€‘éš±è—äº†
                entry.innerHTML = `<div class="status-entry-icon">${status.icon}</div><div style="flex:1;"><strong>${status.name}</strong><br><small style="color:#aaa;">${status.desc}</small></div>`;
                container.appendChild(entry);
            }

            if (!hasStatus) {
                container.innerHTML = '<div style="width:100%; text-align:center; color:#666; margin-top:50px;">ç›®å‰èº«å¿ƒå¥åº·ï¼Œç„¡ä»»ä½•ç‰¹æ®Šç‹€æ…‹ã€‚</div>';
            }
        },

        // --- 3. ç¶“é©—æ¸²æŸ“ (åˆ—è¡¨å¼ï¼šå·¦åœ–å³æ–‡) ---
        renderExperience: function() {
            const container = document.getElementById('brain-main-area');
            
            // [ä¿®æ”¹] å¾ data.js è®€å–åŸºç¤è³‡æ–™ (æ·±æ‹·è²ä¸€ä»½ä»¥å…æ±™æŸ“åŸå§‹è³‡æ–™)
            const experiences = JSON.parse(JSON.stringify(BRAIN_DATA.experiences));

            // è£œæ»¿åˆ° 9 å€‹ (ç¯„ä¾‹)
            for(let i=experiences.length + 1; i<=9; i++) {
                experiences.push({ id: i, unlocked: false, img: '', title: '???', desc: 'å°šæœªè§£é–ã€‚' });
            }

            experiences.forEach(exp => {
                const div = document.createElement('div');
                div.className = 'gallery-list-item'; // ä½¿ç”¨æ–°çš„åˆ—è¡¨æ¨£å¼
                
                let imgHtml = '';
                if (exp.img) {
                    const lockedClass = exp.unlocked ? '' : 'gallery-locked';
                    imgHtml = `<img src="${exp.img}" class="gallery-img ${lockedClass}">`;
                } else {
                    imgHtml = '<span style="font-size:30px; color:#555;">?</span>';
                }

                const title = exp.unlocked ? exp.title : '???';
                const desc = exp.unlocked ? exp.desc : 'ä¸€æ®µæœªè¢«çœ‹è¦‹çš„è¨˜æ†¶ï¼Œä¾¿ç„¡æ³•è½‰åŒ–æˆç¶“é©—â€¦';

                div.innerHTML = `
                    <div class="gallery-img-wrapper">
                        ${imgHtml}
                    </div>
                    <div class="gallery-text-wrapper">
                        <div style="font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 6px;">${title}</div>
                        <div style="font-size: 13px; color: #dadada; line-height: 1.4;">${desc}</div>
                    </div>
                `;
                
                container.appendChild(div);
            });
        },

        // --- 4. æˆå°±æ¸²æŸ“ ---
        renderAchievement: function() {
            const container = document.getElementById('brain-main-area');
            // [ä¿®æ”¹] æ”¹ç‚ºå¾ data.js è®€å–
            const achievements = BRAIN_DATA.achievements;

            achievements.forEach(ach => {
                const div = document.createElement('div');
                div.className = `achieve-badge achieve-${ach.tier}`;
                
                if (ach.unlocked) {
                    div.classList.add('unlocked');
                    div.innerText = `ã€${ach.name}ã€‘`;
                    div.onclick = () => this.updateInfo(ach.name, ach.desc);
                } else {
                    div.innerText = 'ğŸ”’ æœªè§£é–';
                    div.onclick = () => this.updateInfo('æŸäº›ä½¿å‘½æ­£åœ¨è¢«ç­‰å¾…é”æˆâ€¦', ach.lockText);
                }
                container.appendChild(div);
            });
        }
    };

        // [æ–°å¢] FPS è¨ˆç®—è®Šæ•¸
        let fpsFrameCount = 0;
        let lastFpsTime = 0;
        const fpsElement = document.getElementById('fps-counter');

        function updateFPS(time) {
            if (!fpsElement) return;
            
            // åªæœ‰åœ¨éŠæˆ²é–‹å§‹å¾Œ (åŒ…å«éš±è—çµå±€) æ‰é¡¯ç¤º
            if (gameStarted || (endingState.active && isHiddenEnding)) {
                if (fpsElement.style.display === 'none') fpsElement.style.display = 'block';
            } else {
                if (fpsElement.style.display !== 'none') fpsElement.style.display = 'none';
                return;
            }

            fpsFrameCount++;
            const elapsed = time - lastFpsTime;

            if (elapsed >= 500) {
                const fps = Math.round((fpsFrameCount / elapsed) * 1000);
                fpsElement.textContent = `${fps} FPS`;

                // [ä¿®æ”¹] é‡å°æ‰‹æ©Ÿç¶²é å„ªåŒ–çš„é¡è‰²æ¨™æº– (æ¯”è¼ƒå¯¬å®¹)
                if (fps >= 28) fpsElement.style.color = '#00ff00';      // 28ä»¥ä¸Š: ç¶ è‰² (åœ¨æ‰‹æ©Ÿç¶²é ç®—å¾ˆé †äº†)
                else if (fps >= 20) fpsElement.style.color = '#ffff00'; // 20~27: é»ƒè‰² (å¯æ¥å—)
                else if (fps >= 10) fpsElement.style.color = '#ffaa00'; // 10~19: æ©˜è‰² (ç¨å¾®å¡é “ï¼Œä½†èƒ½ç©)
                else fpsElement.style.color = '#ff0000';                // 10ä»¥ä¸‹: ç´…è‰² (å¹»ç‡ˆç‰‡)

                fpsFrameCount = 0;
                lastFpsTime = time;
            }
        }
    
        let camera, scene, renderer, skydome, floor;
        let ambientLight, directionalLight;
        const player = new THREE.Group();
        const PI_2 = Math.PI / 2;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const playerHeight = 1.7;
        const playerRadius = 0.4;

        let obstacles = [];
        let treasures = [];
        let exit_portal;
        const totalTreasures = 6;

        const MAX_SAN = 333; //ç©å®¶è¡€é‡
        let playerSan = MAX_SAN;
        let isBeingPushed = false;
        let pushingPiece = null;
        let globalShake = { active: false, start: 0, duration: 0, intensity: 0, type: 'decay' };
        function triggerGlobalShake(intensity, duration, type = 'decay') {
            globalShake.active = true;
            globalShake.start = performance.now();
            globalShake.duration = duration;
            globalShake.intensity = intensity;
            globalShake.type = type; // è¨˜éŒ„éœ‡å‹•é¡å‹
        }
        let lastPushDamageTime = 0;
        let lastClampDamageTime = 0;
        let prevTime = performance.now();
        let treasuresFound = 0;
        let gameStarted = false;
        // [æ–°å¢] çµå±€ç‹€æ…‹ç®¡ç†
        let endingState = {
            active: false,      // æ˜¯å¦é€²å…¥çµå±€æµç¨‹
            stage: 0,           // 0:æœªé–‹å§‹, 1:ç™½å±6ç§’, 2:åœ–A, 3:å›åˆ°ä¸–ç•Œ, 4:åœ–B, 5:åœ–C
            timer: 0,           // è¨ˆæ™‚ç”¨
            postGameStartTime: 0 // ç©ºåœ°åœ–é–‹å§‹çš„æ™‚é–“
        };
        const endingOverlay = document.getElementById('ending-overlay');
        const endingContainer = document.getElementById('ending-image-container');
        const imgA = document.getElementById('ending-img-a');
        const imgB = document.getElementById('ending-img-b');
        const imgC = document.getElementById('ending-img-c');
        let gameOver = false;
        let gameOverAnimation = { active: false, start: 0, duration: 1500, initialCamPos: new THREE.Vector3(), initialCamQuat: new THREE.Quaternion() };
        let playerLookDisabled = false;
        
        let skyCycleState = 'day';
        let nextSkyCycleTime = 0;
        let skyCycleTimer = 0;
        const skyCycleConfig = { dayDurationMin: 18000, dayDurationMax: 24000, nightDuration: 15000, fadeDuration: 3000 };
        const originalColors = { background: new THREE.Color(0x334455), fog: new THREE.Color(0x3E4F60), ambient: new THREE.Color(0xADC8D6), directional: new THREE.Color(0xffffff) };
        const nightColors = { background: new THREE.Color(0x120c22), fog: new THREE.Color(0x1A142E), ambient: new THREE.Color(0x352a55), directional: new THREE.Color(0x665588) };
        const lightIntensities = { day: { ambient: 0.8, directional: 0.7 }, night: { ambient: 0.6, directional: 0.55 } };
        let isInitialGridSize = true;


        const joystick = { id: -1, active: false, base: document.getElementById('joystick-base'), handle: document.getElementById('joystick-handle'), startX: 0, startY: 0, maxDist: 30 };
        const look = { id: -1, active: false, lastX: 0, lastY: 0 };
        const sceneContainer = document.getElementById('scene-container');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const sanBarUI = document.getElementById('san-bar-container');
        let vignetteCanvas, vignetteCtx;
        
        let glowTexture, shadowTexture, smileyTexture, birdTexture;
        let auroraMaterial, portalMaterial, chaosOrbMaterial, laserMaterial, bossOrbMaterial;
        const boundary = 240;
        
        const columnMat = new THREE.MeshStandardMaterial({ color: 0xF5F5DC, roughness: 0.8, metalness: 0.1 });
        
        let fallingPiecesManager = { isActive: false, interval: 6500, nextFallTime: 0, piecesToFall: [], totalFalls: 12, fallsCompleted: 0, currentFall: null };
        let smileyBallManager = { isActive: false, interval: 6000, nextSpawnTime: 0, totalSpawns: 24, spawnsCompleted: 0, activeBalls: [] };
        let lightningManager = { isActive: false, nextFlashTime: 0, state: 'idle', flashCount: 0, flashTimer: 0 };
        let chaosOrb = { active: false, mesh: null, light: null, lightFlash: null, laserBeams: null, state: 'idle', attackStartTime: 0, lastSanDrainTime: 0, lastGazeDamageTime: 0 };
        let birdManager = { isActive: false, mesh: null, speed: 12, state: 'arc', nextTargetTime: 0, targetTimerActive: false, arcData: { turnRate: 0.5 } };
        let requiredSymbols = [];
        let lissajousFigure = { group: null, orbs: [], curve: null, active: false };
        let summoningCircle = {
            group: null, symbols: [], animation: { active: false, state: 'idle', startTime: 0, ring: null, hexagram: null, lightCurtain: null }, puzzleSolved: false, active: false
        };
        
        let cameraFrustum = new THREE.Frustum();
        let projScreenMatrix = new THREE.Matrix4();
        const duckBox = new THREE.Box3();
        
        let treasureCanvas, treasureCtx;
        let magicCircle = { 
            rotations: { star: 0, sq1: 0, sq2: 0 }, 
            collectedColors: [], 
            flash: { active: false, startTime: 0, duration: 3000 }, 
            finish: { active: false, startTime: 0, duration: 1500, textFired: false },
                
            // [æ–°å¢] é™°é™½ä¹‹æ°£èˆ‡æ—¥æœˆç³»çµ±çš„è®Šæ•¸
            yinEnergy: 0,       // é™°æ°£å±¤æ•¸
            yangEnergy: 0,      // é™½æ°£å±¤æ•¸
            moonOpacity: 0,     // æœˆäº®å¡«è‰²çš„ä¸é€æ˜åº¦ (0.0 åˆ° 1.0)
            sunOpacity: 0,      // å¤ªé™½å¡«è‰²çš„ä¸é€æ˜åº¦ (0.0 åˆ° 1.0)
            moonCycle: 1,       // æœˆäº®é¡è‰²å¾ªç’° (1=æ·±è‰², 2=æ·ºè‰²)
            sunCycle: 1,        // å¤ªé™½é¡è‰²å¾ªç’° (1=æ·±è‰², 2=æ·ºè‰²)
            orbitAngle: 0       // æ—¥æœˆå…¬è½‰çš„è§’åº¦
        };

        const loadedModels = {};

        // [æ–°å¢] å¯¶ç‰©æ‹¾å–ç›¸é—œè®Šæ•¸
        let collectionState = { 
            isCollecting: false, 
            timer: 0, 
            duration: 3000, // éœ€è¦ 3 ç§’
            currentTreasure: null 
        };

        let glitchCanvas, glitchCtx;    // ç‰¹æ•ˆç•«å¸ƒ
        
        // 6ç¨®é«˜æ˜åº¦ã€ä½é£½å’Œçš„é¡è‰² (å°æ‡‰å¯¶ç‰©é€²åº¦è®ŠåŒ–)
        // æ·¡é»ƒ, æ·¡è—, æ·¡ç´…, æ·¡ç¶ , æ·¡ç²‰, æ·¡ç´«
        const collectionColors = ['#FFFACD', '#E0FFFF', '#FFC0CB', '#98FB98', '#FFB6C1', '#E6E6FA'];
        
        let collectionUI = { container: null, bar: null };

let playerAttackManager = {
    projectiles: null,
    maxProjectiles: 15, // [å„ªåŒ–] å°‡å­å½ˆæ± ä¸Šé™æ”¹ç‚º 15
    projectileSpeed: 250,
    projectileRange: 210, // [å¯èª¿æ•´] å­å½ˆæœ€é é£›è¡Œè·é›¢
    maxAmmo: 15,
    currentAmmo: 15,
    reloadTime: 6000, // 6ç§’å†·å»
    isReloading: false,
    reloadEndTime: 0,
    button: null,
    ammoCounter: null,
    cooldownTimer: null,
};

// [æ–°å¢] éš±è—çµå±€ç›¸é—œå…¨åŸŸè®Šæ•¸
        let hasChaosOrbBeenAbsorbed = false; // ç´€éŒ„å…‰çƒæ˜¯å¦è¢«BOSSå¸æ”¶
        let isHiddenEnding = false;          // æ˜¯å¦é€²å…¥éš±è—çµå±€è·¯ç·š
        const MAX_BUBBLES = 30;              // è¨­å®šæœ€å¤§æ³¡æ³¡æ•¸é‡ (30é¡†å¤ ç”¨äº†)
        let bubblePool = [];                 // å­˜æ”¾æ‰€æœ‰æ³¡æ³¡çš„æ± å­
        let bubbleCooldown = 0;              // å°„æ“Šå†·å»
        let sharedBubbleGeo = null;          // å…±ç”¨æ³¡æ³¡å¹¾ä½•é«”
        let sharedBubbleMat = null;          // å…±ç”¨æ³¡æ³¡æè³ª
        let bubbleMaxCooldown = 1500;        // 1.5ç§’
        let playerBossShield = null;         // ç©å®¶è®ŠæˆBOSSæ™‚çš„è­·ç›¾
        let toppledObjectsCount = 0;         // å·²æ¨å€’çš„ç‰©ä»¶æ•¸é‡
        let totalToppleableCount = 0;        // å ´ä¸Šå¯æ¨å€’çš„ç¸½æ•¸
        let cachedShieldTexture = null;      // ç·©å­˜è­·ç›¾è²¼åœ–ï¼Œé¿å…é‡è¤‡ç¹ªè£½
        let bossLevelTargets = [];           // VIPåå–®ï¼Œåªé‹ç®—éœ€è¦è¢«æ¨å€’çš„æ±è¥¿

// [ä¿®æ­£ç‰ˆ] æŸ±å­æµ®å‹•ç®¡ç†å™¨ (åŠ å…¥éœ‡å‹•)
const pillarManager = {
    riseDuration: 5100,    
    floatRange: 2.5,       
    floatSpeed: 0.002,     
    
    triggerRise: function() {
        console.log("æŸ±å­é–‹å§‹ä¸Šæµ®è¨Šè™Ÿå·²ç™¼é€ï¼");
        const now = performance.now();
        
        // [æ–°å¢] æŸ±å­å‡å¤©æ™‚çš„éœ‡å‹• (å¼·åº¦ 22, æŒçºŒ 5ç§’)
        triggerGlobalShake(21, 5000);
        obstacles.forEach(obs => {
            if (obs.userData.isColumn) {
                obs.userData.floatState = 'delay';
                obs.userData.floatStartTime = now;
                obs.userData.riseDelay = Math.random() * 1500; 
                obs.userData.initialY = obs.position.y;
                obs.userData.targetHeight = 132 + Math.random() * 42;
            }
        });
    },

    triggerFall: function() {
        // [ä¿®æ­£] å¢œè½æ™‚éœ‡å‹•ï¼šä½¿ç”¨ build-up æ¼¸å¼·æ¨¡å¼
        // 1200ms æ˜¯é ä¼°çš„å¢œè½æ™‚é–“ï¼Œéœ‡å‹•æœƒå¾ 0 éš¨æ™‚é–“å¢å¼·ï¼Œç›´åˆ°è½åœ°ç¬é–“(1.2ç§’å¾Œ)é”åˆ°å¼·åº¦ 30
        triggerGlobalShake(27, 2400, 'build-up');
        const now = performance.now();
        obstacles.forEach(obs => {
            if (obs.userData.isColumn) {
                obs.userData.floatState = 'falling';
                obs.userData.floatStartTime = now;
                obs.userData.riseDelay = Math.random() * 500; 
                obs.userData.currentYAtFall = obs.position.y;
            }
        });
    },

    update: function(time) {
        let hasJustLanded = false; // åµæ¸¬æ˜¯å¦æœ‰æŸ±å­å‰›è½åœ°

        obstacles.forEach((obs, index) => {
            if (!obs.userData.isColumn) return;

            const state = obs.userData.floatState;
            
            if (state === 'delay') {
                if (time > obs.userData.floatStartTime + obs.userData.riseDelay) {
                    obs.userData.floatState = 'rising';
                    obs.userData.floatStartTime = time; 
                }
            }
            else if (state === 'rising') {
                const elapsed = time - obs.userData.floatStartTime;
                const progress = Math.min(elapsed / this.riseDuration, 1);
                const eased = 1 - Math.pow(1 - progress, 3); 
                
                const target = obs.userData.targetHeight || 132;
                obs.position.y = eased * target;

                if (progress >= 1) {
                    obs.userData.floatState = 'floating';
                    obs.userData.floatOffset = Math.random() * Math.PI * 2;
                }
            }
            else if (state === 'floating') {
                const target = obs.userData.targetHeight || 132;
                obs.position.y = target + Math.sin(time * this.floatSpeed + (index * 0.5)) * this.floatRange;
            }
            else if (state === 'falling') {
                const elapsed = time - obs.userData.floatStartTime;
                if (elapsed < obs.userData.riseDelay) return;

                const fallTime = elapsed - obs.userData.riseDelay;
                const progress = Math.min(fallTime / 1000, 1); 
                const eased = progress * progress; 

                obs.position.y = obs.userData.currentYAtFall * (1 - eased);

                if (progress >= 1) {
                    obs.position.y = 0;
                    obs.userData.floatState = 'ground';
                    hasJustLanded = true;
                }
            }
        });

        // [æ–°å¢] å¦‚æœæœ‰æŸ±å­è½åœ°ï¼Œä¸”ç›®å‰æ²’æœ‰æ­£åœ¨é€²è¡Œçš„å¼·çƒˆè½åœ°éœ‡å‹•ï¼Œå°±è§¸ç™¼
        if (hasJustLanded) {
            // å¼·åº¦ 35 (æ¯”å‡å¤©å¼·), æŒçºŒ 1.8ç§’
            if (!globalShake.active || globalShake.intensity < 30) {
                 triggerGlobalShake(33, 1800);
            }
        }
    }
};

// è™›å½è¡¨é¢ç®¡ç†å™¨
const falseFacadeManager = {
    walls: [],
    // [ä¿®æ­£] ä½¿ç”¨ Lambert æè³ªï¼Œä¸¦å¼·åˆ¶å¯«å…¥æ·±åº¦ (depthWrite: true)
    material: new THREE.MeshLambertMaterial({ colorWrite: false, depthWrite: true }), 
    isFading: false,

    init: function() {
        this.clear();
        this.isFading = false;

        const geometry = new THREE.BoxGeometry(90, 30, 6); 
        
        for (let i = 0; i < 6; i++) {
            const wall = new THREE.Mesh(geometry, this.material);
            wall.renderOrder = -1;
            wall.visible = false;  
            wall.castShadow = false;
            wall.receiveShadow = false; 

            if (i >= 3) {
                wall.rotation.y = Math.PI / 2;
            }
            
            scene.add(wall);
            this.walls.push(wall);
        }
    },

    shuffle: function() {
        this.isFading = false;
        const boundary = 200; 
        const minSpacing = 50; 
        const horizontalPositions = []; 
        const verticalPositions = [];   

        this.walls.forEach((wall, index) => {
            wall.visible = true; 
            wall.scale.set(1, 1, 1);
            
            let valid = false;
            let attempts = 0;
            let pos = new THREE.Vector3();
            const isVertical = index >= 3;
            const checkList = isVertical ? verticalPositions : horizontalPositions;

            while (!valid && attempts < 50) {
                pos.set(
                    (Math.random() - 0.5) * 2 * boundary,
                    15,
                    (Math.random() - 0.5) * 2 * boundary
                );

                let tooClose = false;
                for (const existingPos of checkList) {
                    if (pos.distanceTo(existingPos) < minSpacing) {
                        tooClose = true;
                        break;
                    }
                }
                if (pos.distanceTo(player.position) < 15) tooClose = true;

                if (!tooClose) valid = true;
                attempts++;
            }
            
            wall.position.copy(pos);
            checkList.push(pos);
        });
    },

    fadeOut: function() {
        this.isFading = true;
    },

    update: function(delta) {
        if (this.isFading) {
            let allGone = true;
            this.walls.forEach(wall => {
                if (wall.visible && wall.scale.y > 0.01) {
                    wall.scale.y = THREE.MathUtils.lerp(wall.scale.y, 0, delta * 3);
                    wall.position.y = 14 * wall.scale.y; 
                    allGone = false;
                } else if (wall.visible) {
                    wall.visible = false;
                    wall.scale.y = 0;
                }
            });
            if (allGone) this.isFading = false;
        }
    },

    clear: function() {
        this.walls.forEach(wall => {
            if (wall.parent) scene.remove(wall);
            if (wall.geometry) wall.geometry.dispose();
        });
        this.walls = [];
        this.isFading = false;
    }
};

let taijituRotation = 0; // [æ–°å¢] ç”¨æ–¼è¨˜éŒ„å¤ªæ¥µåœ–ç¤ºçš„æ—‹è½‰è§’åº¦

let vortexManager = {
    pivot: null, // ç”¨ä¾†æ§åˆ¶æ•´é«”ä½ç½®ã€å¤§å°çš„è»¸å¿ƒé»
    active: false,
    animation: {}
};
let attackEffectManager = {
    sprite: null,
    active: false,
    animation: {}
};
let vortexTexture, attackEffectTexture; // ç”¨ä¾†å­˜æ”¾æ‚¨è¼‰å…¥çš„åœ–ç‰‡
        
        init();
        animate();

        async function loadAllModels() {
            const loader = new GLTFLoader();
            const modelsToLoad = {
                angelWhite: 'https://epep441233-a11y.github.io/3dgame/angelwhite.glb',
                angelBlack: 'https://epep441233-a11y.github.io/3dgame/angelblack.glb',
                demonWhite: 'https://epep441233-a11y.github.io/3dgame/demonwhite.glb',
                demonBlack: 'https://epep441233-a11y.github.io/3dgame/demonblack.glb',
                horseWhite: 'https://epep441233-a11y.github.io/3dgame/horsewhite.glb',
                horseBlack: 'https://epep441233-a11y.github.io/3dgame/horseblack.glb',
                bishopWhite: 'https://epep441233-a11y.github.io/3dgame/bishopwhite.glb',
                bishopBlack: 'https://epep441233-a11y.github.io/3dgame/bishopblack.glb',
                kingWhite: 'https://epep441233-a11y.github.io/3dgame/kingwhite.glb',
                kingBlack: 'https://epep441233-a11y.github.io/3dgame/kingblack.glb',
                pawnWhite: 'https://epep441233-a11y.github.io/3dgame/pawnwhite.glb',
                pawnBlack: 'https://epep441233-a11y.github.io/3dgame/pawnblack.glb',
                queenWhite: 'https://epep441233-a11y.github.io/3dgame/queenwhite.glb',
                queenBlack: 'https://epep441233-a11y.github.io/3dgame/queenblack.glb',
                rookWhite: 'https://epep441233-a11y.github.io/3dgame/rookwhite.glb',
                rookBlack: 'https://epep441233-a11y.github.io/3dgame/rookblack.glb',
                angelWhite_low: 'https://epep441233-a11y.github.io/3dgame/angelwhite0.glb',
                angelBlack_low: 'https://epep441233-a11y.github.io/3dgame/angelblack0.glb',
                demonWhite_low: 'https://epep441233-a11y.github.io/3dgame/demonwhite0.glb',
                demonBlack_low: 'https://epep441233-a11y.github.io/3dgame/demonblack0.glb',
                horseWhite_low: 'https://epep441233-a11y.github.io/3dgame/horsewhite0.glb',
                horseBlack_low: 'https://epep441233-a11y.github.io/3dgame/horseblack0.glb',
                bishopWhite_low: 'https://epep441233-a11y.github.io/3dgame/bishopwhite0.glb',
                bishopBlack_low: 'https://epep441233-a11y.github.io/3dgame/bishopblack0.glb',
                kingWhite_low: 'https://epep441233-a11y.github.io/3dgame/kingwhite0.glb',
                kingBlack_low: 'https://epep441233-a11y.github.io/3dgame/kingblack0.glb',
                pawnWhite_low: 'https://epep441233-a11y.github.io/3dgame/pawnwhite0.glb',
                pawnBlack_low: 'https://epep441233-a11y.github.io/3dgame/pawnblack0.glb',
                queenWhite_low: 'https://epep441233-a11y.github.io/3dgame/queenwhite0.glb',
                queenBlack_low: 'https://epep441233-a11y.github.io/3dgame/queenblack0.glb',
                rookWhite_low: 'https://epep441233-a11y.github.io/3dgame/rookwhite0.glb',
                rookBlack_low: 'https://epep441233-a11y.github.io/3dgame/rookblack0.glb',
                boss: 'https://epep441233-a11y.github.io/3dgame/doorboss.glb',
		        duck: 'https://epep441233-a11y.github.io/3dgame/bird.glb',
                angryDuck: 'https://epep441233-a11y.github.io/3dgame/bird3777.glb',
                vortex: 'https://epep441233-a11y.github.io/3dgame/door.glb',
            };

            const promises = Object.entries(modelsToLoad).map(async ([name, url]) => {
                try {
                    const gltf = await loader.loadAsync(url);
                    gltf.scene.traverse(function (child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    loadedModels[name] = gltf.scene;
                } catch (error) {
                    console.error(`ç„¡æ³•è¼‰å…¥æ¨¡å‹ ${name} å¾ ${url}:`, error);
                }
            });
            await Promise.all(promises);

        }

function showInfoModal(e) {
            e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å‚³éï¼Œé˜²æ­¢è§¸ç™¼ handleFirstClick
            requestFullScreenIfNeeded();

            const infoModal = document.getElementById('info-modal');
            const infoBadge = document.getElementById('info-badge');

            if (infoModal) {
                infoModal.style.display = 'flex';
                infoModal.style.zIndex = '2000'; // [é—œéµä¿®æ­£] ç¢ºä¿æ¯”é–‹å§‹ç•«é¢(1000)é«˜
            }
            if (infoBadge) {
                infoBadge.style.display = 'none';
            }
        }

function hideInfoModal() {
    infoModal.style.display = 'none';
}

function handleDeviceTilt(event) {
    // [é—œéµä¿®æ­£] å°‡ event.gamma (ç›´å‘å·¦å³å‚¾æ–œ) æ”¹ç‚º event.beta (æ©«å‘å·¦å³å‚¾æ–œ)
    if (!gameStarted && event.beta != null) {
        const tiltLR = event.beta;
        const maxTilt = 15; // å°‡ +/- 20åº¦çš„å‚¾æ–œè¦–ç‚ºæœ€å¤§ç¯„åœ
        const maxMove = 21; // èƒŒæ™¯åœ–æœ€å¤§ç§»å‹•çš„åƒç´ å€¼

        // é™åˆ¶å‚¾æ–œå€¼åœ¨æˆ‘å€‘çš„æœ€å¤§ç¯„åœå…§
        const clampedTilt = Math.max(-maxTilt, Math.min(maxTilt, tiltLR));

        // è¨ˆç®—ç§»å‹•ç™¾åˆ†æ¯” (-1 to 1)
        const movePercent = clampedTilt / maxTilt;

        // è¨ˆç®—æœ€çµ‚ç§»å‹•çš„åƒç´ å€¼ (æ•¸å€¼æ­£è² æ–¹å‘å¯èƒ½éœ€è¦æ ¹æ“šå¯¦éš›é«”æ„Ÿèª¿æ•´)
        const tx = movePercent * maxMove;

        const bgImage = document.getElementById('start-bg-image');
        if (bgImage) {
            // åœ¨åŸæœ‰çš„ç½®ä¸­èˆ‡ç¸®æ”¾åŸºç¤ä¸Šï¼ŒåŠ ä¸Šæˆ‘å€‘çš„æ©«å‘ç§»å‹•
            bgImage.style.transform = `translate(calc(-50% + ${tx}px), -50%)`;
        }
    }
}

    async function init() {
            // 1. éŠæˆ²ä¸€å•Ÿå‹•ï¼Œè¨­å®š 0.3 ç§’å¾Œè®“åœ–ç‰‡ A æ·¡å‡º
            setTimeout(() => {
                const layerA = document.getElementById('intro-layer-a');
                if (layerA) {
                    layerA.style.opacity = '0';
                    setTimeout(() => layerA.style.display = 'none', 300);
                }
            }, 900);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1111);
            camera.position.y = playerHeight; player.add(camera);
            scene = new THREE.Scene(); scene.background = originalColors.background.clone(); scene.fog = new THREE.Fog(originalColors.fog.getHex(), 0, 420); scene.add(player);
            ambientLight = new THREE.AmbientLight(originalColors.ambient.getHex(), lightIntensities.day.ambient); scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(originalColors.directional.getHex(), lightIntensities.day.directional);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            document.addEventListener('touchstart', onTouchStart, { passive: false }); document.addEventListener('touchmove', onTouchMove, { passive: false }); document.addEventListener('touchend', onTouchEnd);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.localClippingEnabled = true;
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, // æŠ—é‹¸é½’ä¿ç•™ï¼Œä¿è­‰é‚Šç·£åœ“æ»‘
                powerPreference: "high-performance" // [æ–°å¢] å‘Šè¨´ç€è¦½å™¨æˆ‘å€‘æƒ³è¦é«˜æ•ˆèƒ½æ¨¡å¼
            });
            renderer.localClippingEnabled = true;

            // [é—œéµå„ªåŒ–] ç•«è³ªèˆ‡æ•ˆèƒ½çš„é»ƒé‡‘å¹³è¡¡é»
            // æ‰‹æ©Ÿé€šå¸¸ devicePixelRatio æ˜¯ 3 (è¶…é«˜ç•«è³ª)ï¼Œç¡¬è·‘æœƒå¡æ­»ã€‚
            // æˆ‘å€‘å¼·åˆ¶æŠŠå®ƒå£“åœ¨ 1.5 ä»¥ä¸‹ã€‚è‚‰çœ¼å¹¾ä¹çœ‹ä¸å‡ºå·®åˆ¥ï¼Œä½†é‹ç®—é‡æ¸›å°‘äº† 4 å€ï¼
            let targetPixelRatio = window.devicePixelRatio;
            
            // æª¢æ¸¬æ˜¯å¦ç‚ºæ‰‹æ©Ÿ (ç°¡å–®åˆ¤æ–·)
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            if (isMobile) {
                // å¦‚æœæ˜¯æ‰‹æ©Ÿï¼Œå¼·åˆ¶é™è§£æåº¦æ›å–æµæš¢åº¦
                // 1.0 æ˜¯æ¨™æº–ç•«è³ªï¼Œ1.5 æ˜¯é«˜æ¸…ã€‚åŸæœ¬æ‰‹æ©Ÿé è¨­å¯èƒ½æ˜¯ 3.0 (4Kç­‰ç´š)
                // è¨­ç‚º 1.3 æ˜¯ä¸€å€‹éå¸¸å¥½çš„å¹³è¡¡ï¼Œæ—¢ä¸æœƒç³Šï¼Œåˆå¾ˆé †
                targetPixelRatio = Math.min(targetPixelRatio, 1.25);
            } else {
                // é›»è…¦æ•ˆèƒ½å¥½ï¼Œå¯ä»¥ç¨å¾®é«˜ä¸€é»ï¼Œä¸Šé™ 1.5 å°±å¤ äº†ï¼Œå†é«˜ä¹Ÿæ˜¯æµªè²»
                targetPixelRatio = Math.min(targetPixelRatio, 1.3);
            }

            renderer.setPixelRatio(targetPixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            sceneContainer.appendChild(renderer.domElement);
            vignetteCanvas = document.getElementById('vignette-canvas'); vignetteCtx = vignetteCanvas.getContext('2d');
            glitchCanvas = document.getElementById('glitch-canvas');
            glitchCtx = glitchCanvas.getContext('2d');
            glitchCanvas.width = window.innerWidth;
            glitchCanvas.height = window.innerHeight;
            treasureCanvas = document.getElementById('treasure-canvas'); treasureCtx = treasureCanvas.getContext('2d');
            window.addEventListener('resize', onWindowResize);
            infoIcon = document.getElementById('info-icon');
            infoBadge = document.getElementById('info-badge');
            infoModal = document.getElementById('info-modal');
            infoModalContent = document.getElementById('info-modal-content');
            startBgContainer = document.getElementById('start-bg-container');
            startFgImage = document.getElementById('start-fg-image');
            bossHpContainer = document.getElementById('boss-hp-container');
            bossHpFill = document.getElementById('boss-hp-fill');
            chaosHpContainer = document.getElementById('chaos-hp-container');
            chaosHpFill = document.getElementById('chaos-hp-fill');
            collectionUI.container = document.getElementById('collection-ui');
            collectionUI.bar = document.getElementById('collection-bar-fill');
            infoModalContent.innerHTML = `<p>${gameDescription}</p>`;
            infoIcon.addEventListener('pointerup', (e) => {
                showInfoModal(e);
            });
            infoModal.addEventListener('pointerup', (e) => {
                e.stopPropagation(); 
                hideInfoModal();
            });
            infoModalContent.addEventListener('pointerup', (e) => {
                e.stopPropagation();
            });
            brainIcon = document.getElementById('brain-icon');
            brainModal = document.getElementById('brain-modal');
            brainModalContent = document.getElementById('brain-modal-content');

            // [ä¿®æ”¹] ç¶å®šå¤§è…¦åœ–ç¤ºé»æ“Šäº‹ä»¶ (å‘¼å«æ–°ç³»çµ±)
            brainIcon.addEventListener('pointerup', (e) => {
                e.stopPropagation(); 
                requestFullScreenIfNeeded();
                
                brainMenuSystem.open('status');
            });

            brainModal.addEventListener('pointerup', (e) => {
                e.stopPropagation(); 
                brainModal.style.display = 'none';
            });
            
            brainModalContent.addEventListener('pointerup', (e) => {
                e.stopPropagation(); 
            });

            const debugBtn = document.getElementById('debug-win-btn');
            if (debugBtn) {
                debugBtn.addEventListener('pointerup', (e) => {
                    e.stopPropagation();
                    if (gameStarted) {
                        startEndingSequence(); 
                        debugBtn.style.display = 'none'; 
                    }
                });
            }

            const textureLoader = new THREE.TextureLoader();
            async function loadExtraTextures() {
                const loader = new THREE.TextureLoader();
                try {
                    vortexTexture = await loader.loadAsync('https://i.postimg.cc/Wz4J9pgF/door1-1.png');
                    attackEffectTexture = await loader.loadAsync('https://i.postimg.cc/NMKGCt7x/door2-4-01.png');
                    
                    const urls = [
                        'https://i.postimg.cc/631WYKCR/shadow1.png',
                        'https://i.postimg.cc/nVgVmHHN/shadow2.png',
                        'https://i.postimg.cc/W16sxgMc/shadow3.png',
                        'https://i.postimg.cc/263mqtgy/shadow4.png',
                        'https://i.postimg.cc/cCnShnxs/shadow5.png'
                    ];
                    for (const url of urls) {
                        moyingTextures.push(await loader.loadAsync(url));
                    }
                    
                } catch (error) { console.error("ç„¡æ³•è¼‰å…¥é¡å¤–ç‰¹æ•ˆåœ–ç‰‡:", error); }
            }
            glowTexture = createGlowTexture();
            shadowTexture = createShadowTexture();
            smileyTexture = createSmileyTexture();
            birdTexture = textureLoader.load('https://i.postimg.cc/j5d1rHn7/20250910-064431.png');
            portalMaterial = createPortalMaterial(); 
            chaosOrbMaterial = createChaosOrbMaterial(); 
            laserMaterial = createLaserMaterial(); 
            bossOrbMaterial = createBossOrbMaterial();
            startScreen.style.display = 'flex';
            onWindowResize();
            await loadExtraTextures();
            await tsundereManager.init();
            await loadAllModels();
            
            // [ä¿®æ”¹] 2. è³‡æºè¼‰å…¥å®Œæˆå¾Œï¼Œè®“åœ–ç‰‡ B (åº•å±¤) æ·¡å‡º
            const layerB = document.getElementById('intro-layer-b');
            if (layerB) {
                layerB.style.opacity = '0';
                setTimeout(() => layerB.style.display = 'none', 900);
            }

            startBgContainer.style.opacity = '1';
            startFgImage.style.opacity = '1';
            infoIcon.style.opacity = '1';
            brainIcon.style.opacity = '1';
            startScreen.style.backgroundColor = 'rgba(255, 255, 255, 0)';
            startScreen.style.cursor = 'pointer';
            addPCControls();
            statusEffectManager.init();

            // [æ–°å¢] å„ªåŒ–æ•ˆèƒ½ï¼šä½¿ç”¨ Canvas ç”Ÿæˆéœæ…‹å™ªé»åœ–ï¼Œå–ä»£ CSS SVG
            const noiseCanvasGen = document.createElement('canvas');
            noiseCanvasGen.width = 256; 
            noiseCanvasGen.height = 256;
            const nCtx = noiseCanvasGen.getContext('2d');
            const nImgData = nCtx.createImageData(256, 256);
            for (let i = 0; i < nImgData.data.length; i += 4) {
                const val = Math.random() * 255;
                nImgData.data[i] = val;     // R
                nImgData.data[i+1] = val;   // G
                nImgData.data[i+2] = val;   // B
                nImgData.data[i+3] = 255;   // Alpha (å…¨ä¸é€æ˜ï¼Œç”± CSS opacity æ§åˆ¶å¼·å¼±)
            }
            nCtx.putImageData(nImgData, 0, 0);
            const noiseUrl = noiseCanvasGen.toDataURL();
            const noiseOverlayEl = document.getElementById('noise-overlay');
            if (noiseOverlayEl) noiseOverlayEl.style.backgroundImage = `url(${noiseUrl})`;

            bindStatusContext({
                player, camera, scene,
                takeDamage, healPlayer,
                triggerDamageFlash, 
                triggerProjectionExplosion,
                magicCircle,
                duckManager, bossManager, endingState, moyingManager,
                cameraFrustum, duckBox, projScreenMatrix
            });

            playerAttackManager.button = document.getElementById('shoot-button');
            playerAttackManager.ammoCounter = document.getElementById('ammo-counter');
            playerAttackManager.cooldownTimer = document.getElementById('cooldown-timer');
            playerAttackManager.button.addEventListener('pointerdown', (event) => {
                event.stopPropagation();
                fireProjectile();
            });

            // [æ–°å¢] ç¶å®šéš±è—çµå±€æ¸¬è©¦æŒ‰éˆ•
            const hiddenDebugBtn = document.getElementById('debug-hidden-win-btn');
            if (hiddenDebugBtn) {
                hiddenDebugBtn.addEventListener('pointerup', (e) => {
                    e.stopPropagation();
                    if (gameStarted) {
                        hasChaosOrbBeenAbsorbed = true; // å¼·åˆ¶è¨­å®šæ¢ä»¶é”æˆ
                        startEndingSequence(); 
                        const normDebug = document.getElementById('debug-win-btn');
                        if(normDebug) normDebug.style.display = 'none';
                    }
                });
            }

            // [æ–°å¢] ç¶å®šæ°´æ§æŒ‰éˆ•
            const bubbleBtn = document.getElementById('bubble-shoot-button');
            if (bubbleBtn) {
                bubbleBtn.addEventListener('pointerdown', (e) => {
                    e.stopPropagation();
                    fireBubbleShot();
                });
                // é˜²æ­¢é»æ“Šç©¿é€ç§»å‹•
                bubbleBtn.addEventListener('touchstart', (e) => e.stopPropagation());
                bubbleBtn.addEventListener('touchmove', (e) => e.stopPropagation());
            }

            startScreen.addEventListener('pointerup', handleFirstClick, { once: true });
            window.addEventListener('deviceorientation', handleDeviceTilt);
            initProjectilePool();

            // [æ–°å¢] åˆå§‹åŒ–å¤–éƒ¨ç®¡ç†å™¨ï¼Œæ³¨å…¥å…¨åŸŸè®Šæ•¸
            setupManagers({
                scene, player, camera, obstacles, treasures, loadedModels,
                takeDamage, triggerDamageFlash, spawnSpecificTreasure,
                getPredictedPlayerPos, findValidSpawnPosition, createModelInstance,
                pillarManager, falseFacadeManager,
                startVortexAnimation, startAttackEffect,
                bossHpContainer, bossHpFill, updateBossHpBar,
                chaosHpContainer, chaosHpFill,
                getCollectionState: () => collectionState, 
                collectionUI,
                erosionSystem, updateErosionUI, addProjectionStack,
                moyingTextures, 
                getChaosOrb: () => chaosOrb,
                bossOrbMaterial, 
                exit_portal
            });
            // [ä¿®æ”¹] ç¶å®šå®Œæ•´çš„éŠæˆ²ç’°å¢ƒçµ¦æŠ€èƒ½æ¨¡çµ„
            bindSkillContext({
                scene, player, camera, obstacles, treasures, shadowTexture,
                bossManager, duckManager, chaosOrb, shieldCageManager, 
                fallingPiecesManager, playerAttackManager,
                takeDamage,                         
                healPlayer: (amount) => healPlayer(amount),
                getIsBeingPushed: () => isBeingPushed,
                getCollectionState: () => collectionState,
                spawnSkillPieceFn: (pieceData, faction, position) => {
                    const material = faction === 'Black' ? 
                        new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.4, metalness: 0.2, name: 'Black'}) : 
                        new THREE.MeshStandardMaterial({color: 0xeeeeee, roughness: 0.4, metalness: 0.2, name: 'White'});
                    
                    const piece = createPieceLOD(pieceData, material);
                    if (!piece) return null;

                    piece.position.set(position.x, 100, position.z); 
                    scene.add(piece);

                    const radius = piece.userData.collisionRadius || 5;
                    const shadow = new THREE.Mesh(
                        new THREE.PlaneGeometry(radius * 2.5, radius * 2.5),
                        new THREE.MeshBasicMaterial({ map: shadowTexture, transparent: true, opacity: 0, color: 0x000000 })
                    );
                    shadow.position.copy(position);
                    shadow.position.y = 0.1;
                    shadow.rotation.x = -Math.PI / 2;
                    scene.add(shadow);

                    return { piece, shadow };
                },
                moyingTextures
            });
        }    
        
        function startGame() { 
            
            // é‡ç½®éŠæˆ²é‚è¼¯
            resetGame(); 

            if (typeof originalColors !== 'undefined') {
                scene.background.copy(originalColors.background);
                scene.fog.color.copy(originalColors.fog);
                if (ambientLight) ambientLight.color.copy(originalColors.ambient);
                if (directionalLight) directionalLight.color.copy(originalColors.directional);
            }
            
            if (typeof lightIntensities !== 'undefined') {
                if (ambientLight) ambientLight.intensity = lightIntensities.day.ambient;
                if (directionalLight) directionalLight.intensity = lightIntensities.day.directional;
            }
            
            // é›™é‡ä¿éšªä»‹é¢é¡¯ç¤º
            if (sanBarUI) { sanBarUI.style.display = 'flex'; sanBarUI.style.zIndex = '5'; }
            if (treasureCanvas) { treasureCanvas.style.display = 'block'; treasureCanvas.style.zIndex = '5'; }

            // é¡¯ç¤ºé€šé—œæŒ‰éˆ•
            // [çµ•å°å¼·åˆ¶é¡¯ç¤º] é€™è£¡åŸæœ¬æœƒéš±è—ï¼Œç¾åœ¨å¼·åˆ¶æ”¹ç‚ºé¡¯ç¤º
            const debugBtn = document.getElementById('debug-win-btn');
            if (debugBtn) {
                debugBtn.style.display = 'block';
                debugBtn.style.opacity = '0.6';
                debugBtn.style.zIndex = '2000';
            }

            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) loadingOverlay.style.display = 'none';
            
            startScreen.style.display = 'none'; 

            // [ä¿®æ”¹] æ ¹æ“šé¸æ“‡çš„æ€§æ ¼é¡¯ç¤ºæŠ€èƒ½æŒ‰éˆ•èˆ‡åœ–ç¤º
            const skillButton = document.getElementById('skill-button');
            const skillIcon = document.getElementById('skill-icon');
            
            // ç§»é™¤èˆŠçš„ç›£è½å™¨ (é¿å…é‡é–‹éŠæˆ²é‡è¤‡ç¶å®š)
            const newSkillBtn = skillButton.cloneNode(true);
            skillButton.parentNode.replaceChild(newSkillBtn, skillButton);
            const finalSkillBtn = document.getElementById('skill-button');
            const finalSkillIcon = document.getElementById('skill-icon'); // é‡æ–°æŠ“å–
            const oldCounter = document.getElementById('skill-charge-count');
            if(oldCounter) oldCounter.remove();

            // [é—œéµä¿®æ­£] æ¯ä¸€å ´éŠæˆ²é–‹å§‹å‰ï¼Œå¼·åˆ¶æ›´æ–° skills.js çš„é€£çµï¼Œç¢ºä¿å®ƒæ‹¿åˆ°çš„æ˜¯é€™ä¸€å ´æœ€æ–°çš„ obstacles é™£åˆ—
            bindSkillContext({
                scene, player, camera, obstacles, treasures, shadowTexture,
                bossManager, duckManager, chaosOrb, shieldCageManager, 
                fallingPiecesManager, // ç¢ºä¿æœ‰å‚³å…¥æ‰è½ç‰©ç®¡ç†å™¨
                takeDamage,                         
                healPlayer: (amount) => healPlayer(amount),
                getIsBeingPushed: () => isBeingPushed,
                getCollectionState: () => collectionState,
                spawnSkillPieceFn: (pieceData, faction, position) => {
                    const material = faction === 'Black' ? 
                        new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.4, metalness: 0.2, name: 'Black'}) : 
                        new THREE.MeshStandardMaterial({color: 0xeeeeee, roughness: 0.4, metalness: 0.2, name: 'White'});
                    
                    const piece = createPieceLOD(pieceData, material);
                    if (!piece) return null;

                    piece.position.set(position.x, 100, position.z); 
                    scene.add(piece);

                    const radius = piece.userData.collisionRadius || 5;
                    const shadow = new THREE.Mesh(
                        new THREE.PlaneGeometry(radius * 2.5, radius * 2.5),
                        new THREE.MeshBasicMaterial({ map: shadowTexture, transparent: true, opacity: 0, color: 0x000000 })
                    );
                    shadow.position.copy(position);
                    shadow.position.y = 0.1;
                    shadow.rotation.x = -Math.PI / 2;
                    scene.add(shadow);

                    return { piece, shadow };
                },
                moyingTextures
            });

            // [ä¿®æ”¹] å°‡æŒ‰éˆ•è¨­å®šäº¤çµ¦ skills.js è™•ç†
            setupSkillButton(brainMenuSystem.selectedPersonality);


            gameStarted = true; 
        }

        function updateBossHpBar() {
    if (bossHpContainer) bossHpContainer.style.display = 'flex';
    // [ä¿®æ”¹] å¦‚æœ BOSS è¡€é‡æ­¸é›¶ï¼Œä¹Ÿç›´æ¥éš±è—è¡€æ¢
    if (!bossManager.active || bossManager.currentHP <= 0) {
        bossHpContainer.classList.remove('visible');
        return;
    }
    // ç¢ºä¿ BOSS ç™»å ´æ™‚ï¼Œå³ä½¿å‡½å¼è¢«å‘¼å«ï¼Œå®¹å™¨ä¹Ÿæ˜¯å¯è¦‹çš„
    if (!bossHpContainer.classList.contains('visible')) {
        bossHpContainer.classList.add('visible');
    }

    const percentage = (bossManager.currentHP / bossManager.maxHP) * 100;
    bossHpFill.style.width = Math.max(0, percentage) + '%';
}

        // [å…¨æ–°] é¡¯ç¤º/éš±è—å°„æ“ŠæŒ‰éˆ•
function showShootButton(visible) {
    if (playerAttackManager.button) {
        playerAttackManager.button.style.display = visible ? 'flex' : 'none';
    }
}

        // [æ–°å¢] é¡¯ç¤º/éš±è—æŠ€èƒ½æŒ‰éˆ•
function showSkillButton(visible) {
    const skillButton = document.getElementById('skill-button');
    if (skillButton) {
        skillButton.style.display = visible ? 'flex' : 'none';
    }
}

// [å…¨æ–°] æ›´æ–°å°„æ“ŠUI (å­å½ˆæ•¸é‡ã€å†·å»å€’æ•¸)
function updateShootUI() {
    if (playerAttackManager.isReloading) {
        playerAttackManager.button.classList.add('reloading');
        playerAttackManager.ammoCounter.style.display = 'none';
        const remaining = Math.ceil((playerAttackManager.reloadEndTime - performance.now()) / 1000);
        playerAttackManager.cooldownTimer.textContent = remaining > 0 ? remaining : '';
    } else {
        playerAttackManager.button.classList.remove('reloading');
        playerAttackManager.ammoCounter.style.display = 'block';
        playerAttackManager.cooldownTimer.textContent = '';
        playerAttackManager.ammoCounter.textContent = playerAttackManager.currentAmmo;
    }
}

// [å…¨æ–°] ç™¼å°„å­å½ˆçš„æ ¸å¿ƒé‚è¼¯
function fireProjectile() {
    // [æ–°å¢] æ¯æ¬¡å°„æ“Šæ™‚ï¼Œæ›´æ–°æ—‹è½‰è§’åº¦ä¸¦æ‡‰ç”¨åˆ°åœ–ç¤ºä¸Š
    const icon = document.getElementById('taijitu-icon');
    if (icon) {
        taijituRotation += 180;
        icon.style.transform = `rotate(${taijituRotation}deg)`;
    }

    if (playerAttackManager.isReloading || playerAttackManager.currentAmmo <= 0) return;

    // å¾ç‰©ä»¶æ± ä¸­æ‰¾åˆ°ä¸€å€‹é–’ç½®çš„å­å½ˆ
    const projectile = playerAttackManager.projectiles.find(p => !p.userData.active);

    if (projectile) {
        projectile.userData.active = true;
        projectile.visible = true; // è®“å®ƒé¡¯ç¤ºå‡ºä¾†ï¼

        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        const camPos = new THREE.Vector3();
        camera.getWorldPosition(camPos);

        projectile.position.copy(camPos).add(camDir.clone().multiplyScalar(2));
        projectile.position.y += 0.2;

        projectile.userData.velocity.copy(camDir).multiplyScalar(playerAttackManager.projectileSpeed);
        projectile.userData.distanceTraveled = 0;

        playerAttackManager.currentAmmo--;

        if (playerAttackManager.currentAmmo <= 0) {
            playerAttackManager.isReloading = true;
            playerAttackManager.reloadEndTime = performance.now() + playerAttackManager.reloadTime;
        }
        updateShootUI();
    }
}

function updateProjectiles(delta) {
    if (!playerAttackManager.projectiles) return;

    playerAttackManager.projectiles.forEach(p => {
        if (!p.userData.active) return;

        const moveStep = p.userData.velocity.clone().multiplyScalar(delta);
        p.position.add(moveStep);
        p.userData.distanceTraveled += moveStep.length();

        let hit = false;
        if (p.userData.distanceTraveled > playerAttackManager.projectileRange) { hit = true; }

        // --- [æ–°å¢] å­å½ˆæ‰“é´¨å­åˆ¤å®š ---
        if (!hit && duckManager.isActive) {
            for (const duck of duckManager.ducks) {
                // åªæœ‰åœ¨ "å¯è¦‹" ä¸” "é‚„æ²’ç”Ÿæ°£" çš„ç‹€æ…‹ä¸‹æ‰èƒ½è¢«æ‰“
                if (duck.state === 'visible' && duck.group.visible) {
                    const dist = p.position.distanceTo(duck.group.position);
                    // åˆ¤å®šç¯„åœç¨å¾®å¯¬å®¹ä¸€é» (åŠå¾‘ * 2)
                    if (dist < duck.radius * 2) {
                        hit = true;
                        duck.hp -= 1; // æ‰£è¡€
                        
                        // é–ƒçˆç´…å…‰ (è¦–è¦ºå›é¥‹)
                        const flashColor = duck.isSpecial ? new THREE.Color(0x9933FF) : new THREE.Color(0xFF0000);

                        duck.normalMesh.traverse(c => {
                            if(c.isMesh) {
                                c.material.emissive = flashColor;
                                // 0.1 ç§’å¾Œæ¢å¾©é»‘è‰² (ç„¡è‡ªç™¼å…‰)
                                setTimeout(() => { if(c && c.material) c.material.emissive = new THREE.Color(0x000000); }, 100);
                            }
                        });

                        // è¡€é‡æ­¸é›¶
                        if (duck.hp <= 0) {
                            if (duck.isSpecial) {
                                // [æ–°å¢] ç‰¹æ®Šé´¨å­ï¼šé€²å…¥æ­»äº¡æ‰è½æµç¨‹
                                duck.state = 'dying'; 
                                duck.vibrateEndTime = performance.now() + 3000; // æ­»äº¡å‰éœ‡å‹• 3 ç§’
                            } else {
                                // æ™®é€šé´¨å­ï¼šé€²å…¥ç”Ÿæ°£è¡æ’æµç¨‹
                                duck.state = 'vibrating'; 
                                duck.normalMesh.visible = false; 
                                duck.angryMesh.visible = true;   
                                const vibrateDuration = 3000 + Math.random() * 2000; 
                                duck.vibrateEndTime = performance.now() + vibrateDuration;
                            }
                        }
                        break;
                    }
                }
            }
        }

        // --- [ä¿®æ­£] BOSS è­·ç›¾æ ¼æ“‹åˆ¤å®š + åæ“Šé‚è¼¯ ---
        if (!hit && bossManager.active && bossManager.shield && bossManager.shield.visible) {
             if (bossManager.state === 'shield_expanding' || bossManager.state === 'shield_active' || bossManager.state === 'shield_end') {
                 const distToBoss = p.position.distanceTo(bossManager.mesh.position);
                 if (distToBoss < 42) { 
                     hit = true; 
                     
                     // [æ–°å¢] åæ“Šé‚è¼¯ï¼šæ¯åƒåˆ°ä¸€ç™¼å­å½ˆï¼Œç™¼å°„ä¸€é¡†ç‰¢ç± 
                     const startPos = bossManager.mesh.position.clone().add(new THREE.Vector3(0, 35, 0));
                     // [ä¿®æ”¹] åŒæ¨£æ”¹æˆé åˆ¤ 1.8 ç§’å¾Œçš„ä½ç½®
                     shieldCageManager.spawn(startPos, getPredictedPlayerPos(1.8));
                 }
             }
        }
        
        // --- [æ–°å¢] è­·ç›¾ç‰¢ç± æ ¼æ“‹åˆ¤å®š ---
        if (!hit && shieldCageManager.cages.length > 0) {
            for (const cage of shieldCageManager.cages) {
                // ç„¡è«–æ˜¯é£›è¡Œä¸­é‚„æ˜¯è½åœ°ï¼Œåªè¦ç¢°åˆ°çƒé«”è¡¨é¢å°±è¢«æ“‹æ‰
                // ç± å­åŠå¾‘ç‚º 4 (scale=1æ™‚)ï¼Œé£›è¡Œæ™‚ scale æœƒå¤§ä¸€é»ï¼Œæˆ‘å€‘æŠ“ 4~5 ä¹‹é–“
                const distToCage = p.position.distanceTo(cage.mesh.position);
                const currentRadius = 4 * cage.mesh.scale.x; 
                if (distToCage < currentRadius) {
                    hit = true;
                    break;
                }
            }
        }

        // --- [æ–°å¢] æ··æ²Œå…‰åœ˜åˆ¤å®š ---
        if (!hit && chaosOrb.active && chaosOrb.mesh && chaosOrb.state !== 'despawning' && chaosOrb.state !== 'intro') {
            const distToOrb = p.position.distanceTo(chaosOrb.mesh.position);
            // å…‰åœ˜åŠå¾‘ç´„ç‚º 4
            if (distToOrb < 4) {
                hit = true;
                chaosOrb.takeDamage(1, 'player'); 
            }
        }

        // BOSS æœ¬é«”åˆ¤å®š (åŸæœ¬çš„é‚è¼¯)
        if (!hit && bossManager.active && bossManager.mesh && bossManager.mesh.userData.bbox) {
            if (bossManager.mesh.userData.bbox.containsPoint(p.position)) {
                bossManager.takeDamage(1);
                hit = true;

                // [æ–°å¢] æª¢æ¸¬è‹¥ BOSS æ­»äº¡ï¼Œè§¸ç™¼è™›å½ç‰†å£æ¶ˆå¤±
                if (bossManager.currentHP <= 0) {
                    if (typeof falseFacadeManager !== 'undefined') {
                        falseFacadeManager.fadeOut();
                    }
                }
            }
        }

        // [ä¿®æ­£] éšœç¤™ç‰©åˆ¤å®š (åŠ å¯¬åˆ¤å®šç¯„åœï¼Œè§£æ±ºç©¿ç‰†æ„Ÿ)
        if (!hit) {
            for (const obs of obstacles) {
                if (obs.userData.isPortalBlocker && !exit_portal.visible) continue;
                
                // å–å¾—ç‰©ä»¶ç¢°æ’åŠå¾‘
                const obsRadius = obs.userData.collisionRadius || 1;
                
                // [é—œéµä¿®æ”¹] é€™è£¡é¡å¤– + 0.6ï¼Œè®“åˆ¤å®šç¯„åœæ¯”æ¨¡å‹å¤§ä¸€é»é»
                const hitThreshold = obsRadius + 0.6; 

                if (p.position.distanceTo(obs.position) < hitThreshold) {
                    hit = true;
                    break;
                }
            }
        }

        if (hit) {
            p.userData.active = false;
            p.visible = false;
            p.position.set(0, -100, 0);
        }
    });
}

            function resetYinYang() {
                magicCircle.yinEnergy = 0;
                magicCircle.yangEnergy = 0;
                magicCircle.moonOpacity = 0;
                magicCircle.sunOpacity = 0;
                magicCircle.moonCycle = 1;
                magicCircle.sunCycle = 1;
            }

        // [ä¿®æ­£] å¼·åŠ›å ´æ™¯æ¸…ç†å‡½å¼ (åŠ å…¥ä¿ç•™åå–®)
        function clearScene(keepEnvironment = false) {
            // 1. éæ­·å ´æ™¯ä¸­æ‰€æœ‰ç‰©ä»¶ï¼Œé€²è¡ŒéŠ·æ¯€
            scene.traverse(child => {
                if (keepEnvironment) {
                    if (child === floor) return;
                    if (child === skydome) return; // [æ–°å¢] ä¿è­·æ¥µå…‰
                    if (moyingManager && (child === moyingManager.yanGroup || child === moyingManager.moyingSprite)) return;
                    if (moyingManager && moyingManager.yanGroup && child.parent === moyingManager.yanGroup) return;
                    if (child.userData && child.userData.isBackgroundStairs) return;
                }

                if (child.isMesh || child.isSprite || child.isPoints || child.isLine) {
                    
                    // A. é‡‹æ”¾å¹¾ä½•é«”
                    if (child.geometry) {
                        child.geometry.dispose();
                    }

                    // B. é‡‹æ”¾æè³ª
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => disposeMaterial(mat));
                        } else {
                            disposeMaterial(child.material);
                        }
                    }
                }
            });

            // 2. å¾å ´æ™¯ä¸­ç§»é™¤ç‰©ä»¶
            for (let i = scene.children.length - 1; i >= 0; i--) {
                const child = scene.children[i];
                if (child === player || child === ambientLight || child === directionalLight || child === camera) continue;

                if (keepEnvironment) {
                    if (child === floor) continue;
                    if (child === skydome) continue;
                    if (moyingManager && (child === moyingManager.yanGroup || child === moyingManager.moyingSprite)) continue;
                    if (child.userData && child.userData.isBackgroundStairs) continue;
                }
                scene.remove(child);
            }
        }

        // [è¼”åŠ©] å®‰å…¨é‡‹æ”¾æè³ª
        function disposeMaterial(mat) {
            // çµ•å°ä¸è¦é‡‹æ”¾å…¨åŸŸå…±ç”¨çš„è²¼åœ– (glowTexture, shadowTexture ç­‰)ï¼Œå¦å‰‡ä¸‹æ¬¡æœƒè®Šç™½æ–¹å¡Š
            if (mat.map && 
                mat.map !== glowTexture && 
                mat.map !== shadowTexture && 
                mat.map !== smileyTexture && 
                mat.map !== birdTexture &&
                mat.map !== vortexTexture && 
                mat.map !== attackEffectTexture &&
                !moyingTextures.includes(mat.map)) {
                
                mat.map.dispose();
            }
            
            // é‡‹æ”¾æè³ªæœ¬èº«
            mat.dispose();
        }
        
        // [æ–°å¢] å°‡å ´æ™¯ç‰©ä»¶æ¨å…¥æ¸…ç†æ’ç¨‹ (åªéš±è—+æ’éšŠï¼Œä¸ç«‹å³éŠ·æ¯€ï¼Œè§£æ±ºå¡é “)
        function queueSceneForCleanup(keepEnvironment = false) {
            scene.traverse(child => {
                // å¦‚æœæ˜¯ç©ºä¸–ç•Œæ¨¡å¼ï¼Œä¿ç•™åœ°æ¿ã€æ¨“æ¢¯ã€é­˜
                if (keepEnvironment) {
                    if (child === floor) return;
                    if (child === skydome) return; // [æ–°å¢] ä¿è­·æ¥µå…‰
                    if (child.userData && child.userData.isBackgroundStairs) return;
                    if (moyingManager && (child === moyingManager.yanGroup || child === moyingManager.moyingSprite)) return;
                    if (moyingManager && moyingManager.yanGroup && child.parent === moyingManager.yanGroup) return;
                }
                
                // æ’é™¤æ ¸å¿ƒç‰©ä»¶ (å…‰ã€ç›¸æ©Ÿã€ç©å®¶)
                if (child === player || child === ambientLight || child === directionalLight || child === camera) return;
                if (child.isMesh || child.isSprite || child.isPoints || child.isLine || child.isGroup) {
                    // 1. ç«‹å³éš±è—ï¼Œè®“è¦–è¦ºä¸Šä»¥ç‚ºæ¸…ç©ºäº†
                    child.visible = false;
                    // 2. åŠ å…¥æ’ç¨‹ï¼Œè®“æ¸…æ½”å·¥æ…¢æ…¢æ¸…
                    cleanupQueue.push(child);
                }
            });

            // å•Ÿå‹•æ¸…æ½”å·¥
            if (!cleanupRequestId) runGradualCleanup();
        }

        // [æ–°å¢] å¼·åˆ¶æš«åœæ¸…æ½”å·¥ (é¿å…å½±éŸ¿çµå±€åœ–ç‰‡è¼‰å…¥)
        function pauseGradualCleanup() {
            if (cleanupRequestId) {
                cancelAnimationFrame(cleanupRequestId);
                cleanupRequestId = null;
            }
        }

        function runGradualCleanup() {
            if (cleanupQueue.length === 0) {
                cleanupRequestId = null;
                return;
            }

            const obj = cleanupQueue.pop();
            
            if (obj) {
                // 1. å¾å ´æ™¯ç§»é™¤
                if (obj.parent) obj.parent.remove(obj);

                // 2. é‡‹æ”¾è³‡æº
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(m => disposeMaterial(m));
                    } else {
                        disposeMaterial(obj.material);
                    }
                }
                
                // 3. éè¿´æ¸…ç†å­ç‰©ä»¶ (ç¢ºä¿ä¹¾æ·¨)
                if (obj.children) {
                    obj.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) disposeMaterial(child.material);
                    });
                }
            }

            // ç¹¼çºŒä¸‹ä¸€å¹€
            if (cleanupQueue.length > 0) {
                cleanupRequestId = requestAnimationFrame(runGradualCleanup);
            } else {
                cleanupRequestId = null;
            }
        }

        // [æ–°å¢] ç¨ç«‹çš„å­å½ˆæ± ç”Ÿæˆå‡½å¼
        function initProjectilePool() {
            if (playerAttackManager.projectiles) {
                playerAttackManager.projectiles.forEach(p => {
                    scene.remove(p);
                    if (p.geometry) p.geometry.dispose();
                    if (p.material) p.material.dispose();
                });
            }
            
            const projectilePool = [];
            const projectileGeo = new THREE.SphereGeometry(0.6, 8, 8); 
            const projectileMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });

            // [é—œéµ] ç”¢ç”Ÿä¸€å€‹å°ˆç”¨çš„ç™½è‰²è²¼åœ–ï¼Œåªçµ¦å­å½ˆç”¨
            const whiteGlowTexture = createWhiteGlowTexture();

            for (let i = 0; i < playerAttackManager.maxProjectiles; i++) {
                const projectileMesh = new THREE.Mesh(projectileGeo, projectileMat);
                projectileMesh.visible = false;
                
                const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
                    map: whiteGlowTexture, 
                    color: 0x8A2BE2, // é€™æ˜¯ä½ è¦çš„ç´«è‰²
                    transparent: true, 
                    opacity: 0.8,
                    alphaTest: 0.01,
                    blending: THREE.AdditiveBlending
                }));
                glowSprite.scale.set(3, 3, 1);
                projectileMesh.add(glowSprite);

                scene.add(projectileMesh);
                projectileMesh.userData = {
                    active: false,
                    velocity: new THREE.Vector3(),
                    distanceTraveled: 0,
                };
                projectilePool.push(projectileMesh);
            }
            
            playerAttackManager.projectiles = projectilePool;
            playerAttackManager.currentAmmo = playerAttackManager.maxAmmo;
            playerAttackManager.isReloading = false;
        }

        // [æ ¸å½ˆç´šé‡ç½®] å¾¹åº•æ¸…ç†ã€é‡‹æ”¾è¨˜æ†¶é«”ã€ä¿®å¾©æŒ‰éˆ•
        function resetGame() {
            // 0. ä»‹é¢èˆ‡æŒ‰éˆ•é‡ç½®
            if (endingContainer) { endingContainer.style.display = 'none'; endingContainer.style.opacity = '0'; }
            
            // [é—œéµ] ç¢ºä¿éš±è—çµå±€æŒ‰éˆ•å›æ­¸
            const hiddenDebugBtn = document.getElementById('debug-hidden-win-btn');
            if (hiddenDebugBtn) { 
                hiddenDebugBtn.style.display = 'block'; 
                hiddenDebugBtn.style.opacity = '0.6'; 
                hiddenDebugBtn.style.zIndex = '2000';
            }
            const normalDebugBtn = document.getElementById('debug-win-btn');
            if (normalDebugBtn) { normalDebugBtn.style.display = 'block'; normalDebugBtn.style.opacity = '0.6'; }

            // 1. æ®ºæ­»è¨ˆæ™‚å™¨èˆ‡å‹•ç•«
            clearAllGameTimeouts();
            if (window.skillFalls) window.skillFalls = [];

            // 2. [é—œéµ] é‡‹æ”¾éš±è—çµå±€çš„å¿«å–è²¼åœ–
            if (cachedShieldTexture) {
                cachedShieldTexture.dispose();
                cachedShieldTexture = null;
            }

            // 3. æ¸…ç†æ³¡æ³¡æ± 
            if (typeof bubblePool !== 'undefined') {
                bubblePool.forEach(p => {
                    if (p.mesh) {
                        scene.remove(p.mesh); 
                        if (p.mesh.geometry) p.mesh.geometry.dispose();
                        if (p.mesh.material) p.mesh.material.dispose();
                    }
                });
                bubblePool = []; 
            }

            // [æ–°å¢] å¼·åˆ¶æ¸…ç©º BOSS é—œå¡ç›®æ¨™æ¸…å–®ï¼Œé˜²æ­¢åƒç…§æ®˜ç•™
            bossLevelTargets = [];

            // 4. é‡ç½®èƒŒæ™¯
            if (typeof originalColors !== 'undefined') {
                scene.background = new THREE.Color(originalColors.background);
                scene.fog.color.copy(originalColors.fog);
            } else {
                scene.background = new THREE.Color(0x334455);
            }

            // 5. åœæ­¢èƒŒæ™¯æ¸…æ½”å·¥ä¸¦å¼·åˆ¶æ¸…ç†ä½‡åˆ—
            pauseGradualCleanup();
            cleanupQueue = []; 
            
            // 6. æ¸…ç†èˆŠå ´æ™¯ (éŠ·æ¯€æ‰€æœ‰ Mesh, Material, Geometry)
            // [ä¿®æ­£] å…ˆæ‰‹å‹•æ¸…ç©º obstacles é™£åˆ—å…§çš„åƒç…§ï¼Œå¹«åŠ© GC
            obstacles.forEach(o => {
                 if (o.geometry) o.geometry.dispose();
                 // ä¸è¦ dispose material é¿å…å…±ç”¨æè³ªé»‘æ‰ï¼Œç”± clearScene è™•ç†
            });
            obstacles = []; // æ–·é–‹é€£çµ
            treasures = []; // æ–·é–‹é€£çµ

            clearScene(false);
            
            // 7. [é—œéµ] å¼·åˆ¶é‡‹æ”¾æ¸²æŸ“å™¨è³‡æº
            renderer.renderLists.dispose(); 
            
            // 8. é‡å»ºåŸºç¤ç’°å¢ƒ
            createAurora(); 
            createChessboard(500, 500); 
            createSkyStairs();
            if(falseFacadeManager) falseFacadeManager.init();
            initProjectilePool();
            
            // 9. è®Šæ•¸é‡ç½®
            velocity.set(0, 0, 0);   
            direction.set(0, 0, 0);  
            if (player) player.userData.isTraumaActive = false; 
            isBeingPushed = false;   
            pushingPiece = null;
            if (endingState) { endingState.triggerGloomy = false; endingState.gloomyStartTime = 0; }

            // 10. UI å¾©åŸ
            const uiDefaults = [
                { id: 'san-bar-container', z: '5', display: 'flex' },
                { id: 'treasure-canvas', z: '5', display: 'block' },
                { id: 'treasure-counter-text', z: '20', display: 'block', opacity: '0' },
                { id: 'collection-ui', z: '20', display: 'none' },
                { id: 'vignette-canvas', z: '7', display: 'none' },
                { id: 'trauma-vignette-canvas', z: '4', display: 'none' },
                { id: 'glitch-canvas', z: '99', display: 'none' },
                { id: 'boss-hp-container', z: '10', display: 'none' },
                { id: 'chaos-hp-container', z: '9', display: 'none' },
                { id: 'status-effect-container', z: '50', display: 'flex' },
                { id: 'shoot-button', z: '21', display: 'none' },
                { id: 'skill-button', z: '21', display: 'none' },
                { id: 'end-door-icon', z: '21', display: 'none'}
            ];
            
            uiDefaults.forEach(def => {
                const el = document.getElementById(def.id);
                if (el) {
                    el.style.zIndex = def.z;
                    el.style.display = def.display;
                    el.style.opacity = def.opacity || '1';
                    
                    if (def.id === 'san-bar-container') el.classList.remove('damage-flash-short', 'damage-flash-long', 'heal-flash');
                    if (def.id === 'boss-hp-container') { el.classList.remove('visible'); if(bossHpFill) bossHpFill.style.width = '100%'; }
                    if (def.id === 'chaos-hp-container') { el.classList.remove('visible'); if(chaosHpFill) chaosHpFill.style.width = '100%'; }
                    if (def.id === 'treasure-canvas') { el.style.backgroundColor = 'transparent'; if (treasureCtx) treasureCtx.clearRect(0, 0, el.width, el.height); }
                    if (def.id === 'collection-ui' && collectionUI.bar) collectionUI.bar.style.width = '0%';
                }
            });
        
            // 11. çµå±€ä»‹é¢å¼·åˆ¶æ­¸é›¶
            const endingElements = [endingOverlay, endingContainer, imgA, imgB, imgC];
            endingElements.forEach(el => {
                if (el) { el.style.transition = 'none'; el.style.opacity = '0'; el.style.display = 'none'; void el.offsetWidth; }
            });
        
            // 12. è®Šæ•¸èˆ‡ç®¡ç†å™¨é‡ç½®
            endingState = { active: false, stage: 0, timer: 0, postGameStartTime: 0 };
            playerLookDisabled = false;
            joystick.active = false; joystick.id = -1;
            joystick.base.style.display = 'none'; joystick.handle.style.display = 'none';
            look.active = false; look.id = -1;
            
            moyingManager.init();
            weatherManager.reset();
            resetYinYang(); 
            magicCircle = { rotations: { star: 0, sq1: 0, sq2: 0 }, collectedColors: [], flash: { active: false, startTime: 0, duration: 3000 }, finish: { active: false, startTime: 0, duration: 1500, textFired: false }, orbitAngle: 0, yinEnergy: 0, yangEnergy: 0, moonOpacity: 0, sunOpacity: 0, moonCycle: 1, sunCycle: 1 };
            resetStatusSystem();
            
            bindStatusContext({
                player, camera, scene,
                takeDamage, healPlayer,
                triggerDamageFlash, 
                triggerProjectionExplosion,
                magicCircle,
                duckManager, bossManager, endingState, moyingManager,
                cameraFrustum, duckBox, projScreenMatrix
            });
            
            statusEffectManager.clearAll();
            if (chaosOrb.hpBar && chaosOrb.hpBar.group) { scene.remove(chaosOrb.hpBar.group); chaosOrb.hpBar = null; }
            if (glowTexture) glowTexture.needsUpdate = true;
        
            collectionState = { isCollecting: false, timer: 0, duration: 3000, currentTreasure: null };
            if (falseFacadeManager) falseFacadeManager.clear();
            resetAllSkills(); 
        
            bossLevelTargets = []; 
            treasures.length = 0;
            treasuresFound = 0;
            playerSan = MAX_SAN;
            isInitialGridSize = true;
            
            duckManager.reset();
            shieldCageManager.cages = [];
            bossManager.reset();
        
            vortexManager = { pivot: null, active: false, animation: {} };
            attackEffectManager = { sprite: null, active: false, animation: {} };
            fallingPiecesManager = { isActive: false, interval: 6500, nextFallTime: 0, piecesToFall: [], totalFalls: 12, fallsCompleted: 0, currentFall: null };
            smileyBallManager = { isActive: false, interval: 6000, nextSpawnTime: 0, totalSpawns: 24, spawnsCompleted: 0, activeBalls: [] };
            lightningManager = { isActive: false, nextFlashTime: 0, state: 'idle', flashCount: 0, flashTimer: 0 };
            chaosOrb = { active: false, mesh: null, light: null, lightFlash: null, laserBeams: null, state: 'idle', attackStartTime: 0, lastSanDrainTime: 0, lastGazeDamageTime: 0, hpBar: null };
            birdManager = { isActive: false, mesh: null, speed: 12, state: 'arc', nextTargetTime: 0, targetTimerActive: false, arcData: { turnRate: 0.5 }, dailyCrossCount: 0 };
            lissajousFigure = { group: null, orbs: [], curve: null, active: false };
            summoningCircle = { group: null, symbols: [], animation: { active: false, state: 'idle', startTime: 0, ring: null, hexagram: null, lightCurtain: null }, puzzleSolved: false, active: false };
            
            player.userData.isTraumaActive = false; 
            player.userData.yinPushAccumulator = 0; 
            player.userData.yangPushAccumulator = 0; 
            
            player.position.set(0, 0, 150);
            player.rotation.set(0, 0, 0);
            player.add(camera);
            camera.position.set(0, playerHeight, 0);
            camera.rotation.set(0, 0, 0);
            
            updateSanBar();
            createObstacles(); 
            createTreasures(); 
            createExit();
            
            skyCycleState = 'day'; 
            const dayDuration = skyCycleConfig.dayDurationMin + Math.random() * (skyCycleConfig.dayDurationMax - skyCycleConfig.dayDurationMin); 
            nextSkyCycleTime = performance.now() + dayDuration;
            
            if (typeof originalColors !== 'undefined') {
                scene.background.copy(originalColors.background); 
                scene.fog.color.copy(originalColors.fog); 
                ambientLight.color.copy(originalColors.ambient); 
                directionalLight.color.copy(originalColors.directional);
                ambientLight.intensity = lightIntensities.day.ambient; 
                directionalLight.intensity = lightIntensities.day.directional;
            }
        
            sanBarUI.style.display = 'flex';
        
            hasChaosOrbBeenAbsorbed = false;
            isHiddenEnding = false;
            toppledObjectsCount = 0;
            totalToppleableCount = 0;
            bubbleCooldown = 0;
            
            if (playerBossShield) { 
                player.remove(playerBossShield); 
                if (playerBossShield.geometry) playerBossShield.geometry.dispose();
                if (playerBossShield.material) playerBossShield.material.dispose();
                playerBossShield = null; 
            }
            
            const bubbleBtn = document.getElementById('bubble-shoot-button');
            if (bubbleBtn) bubbleBtn.style.display = 'none';
        
            gameStarted = false;
            
            const sceneContainerReset = document.getElementById('scene-container');
            if (sceneContainerReset) sceneContainerReset.style.filter = 'none';
            const svgRedReset = document.getElementById('svg-offset-red');
            const svgBlueReset = document.getElementById('svg-offset-blue');
            if(svgRedReset) svgRedReset.setAttribute('dx', 0);
            if(svgBlueReset) svgBlueReset.setAttribute('dx', 0);
            const noiseReset = document.getElementById('noise-overlay');
            if(noiseReset) { noiseReset.style.display = 'none'; noiseReset.style.opacity = '0'; }
            if(camera) { camera.fov = 75; camera.updateProjectionMatrix(); }
        }

        function onWindowResize() { 
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
            vignetteCanvas.width = window.innerWidth;
            vignetteCanvas.height = window.innerHeight;
            treasureCanvas.width = 110 * window.devicePixelRatio;
            treasureCanvas.height = 110 * window.devicePixelRatio;
            treasureCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
            glitchCanvas.width = window.innerWidth; glitchCanvas.height = window.innerHeight;
        }

        function createAurora() {
             // ç›´æ¥ä½¿ç”¨å¾ utils.js åŒ¯å…¥çš„æè³ª
             auroraMaterial = createAuroraMaterial(); 
             const skyGeo = new THREE.SphereGeometry(490, 64, 32); 
             skydome = new THREE.Mesh(skyGeo, auroraMaterial); 
             skydome.renderOrder = -999; 
             scene.add(skydome);
        }

        function createChessboard(width, height) { 
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512; 
            const context = canvas.getContext('2d'); const size = 512 / 16; 
            for (let i = 0; i < 16; i++) { for (let j = 0; j < 16; j++) { context.fillStyle = (i + j) % 2 === 0 ? '#888' : '#444'; context.fillRect(i * size, j * size, size, size); } } 
            const texture = new THREE.CanvasTexture(canvas); 
            texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; 
            texture.repeat.set(width / 125, height / 125); 
            const floorGeo = new THREE.PlaneGeometry(width, height); 
            const floorMat = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.7, metalness: 0.1 }); 
            floor = new THREE.Mesh(floorGeo, floorMat); 
            floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true; floor.renderOrder = -999; scene.add(floor); 
        }

        function createModelInstance(modelName, targetHeight) {
            const model = loadedModels[modelName];
            if (!model) { return null; }
            
            const modelInstance = model.clone();
            const box = new THREE.Box3().setFromObject(modelInstance);
            const size = box.getSize(new THREE.Vector3());
            if (size.y === 0 || !isFinite(size.y)) { return null; }

            const scale = targetHeight / size.y;
            modelInstance.scale.set(scale, scale, scale);
            
            const newBox = new THREE.Box3().setFromObject(modelInstance);
            const center = newBox.getCenter(new THREE.Vector3());
            
            const wrapper = new THREE.Group();
            wrapper.add(modelInstance);
            modelInstance.position.x = -center.x;
            modelInstance.position.y = -newBox.min.y;
            modelInstance.position.z = -center.z;
            
            const finalBox = new THREE.Box3().setFromObject(wrapper);
            const finalSize = finalBox.getSize(new THREE.Vector3());
            wrapper.userData.collisionRadius = Math.max(finalSize.x, finalSize.z) / 2;

            return wrapper;
        }

        function createPieceLOD(pieceData, material) {
            const highDetailModel = createModelInstance(`${pieceData.name}${material.name}`, pieceData.targetHeight);
            let lowDetailModel = createModelInstance(`${pieceData.name}${material.name}_low`, pieceData.targetHeight);

            if (!highDetailModel) return null;

            if (!lowDetailModel) {
                lowDetailModel = highDetailModel.clone();
            }

            const lod = new THREE.LOD();
            lod.addLevel(highDetailModel, 0);
            lod.addLevel(lowDetailModel, 60); // 60ç±³åˆ‡æ›

            lod.userData.faction = material.name; 
            lod.userData.isMovable = true;
            lod.userData.collisionRadius = highDetailModel.userData.collisionRadius;
            
            // [æ–°å¢] æƒ¡é­”æ£‹å­å°ç©å®¶çš„ç¢°æ’åŠå¾‘ï¼ˆç¸®å°30%ï¼Œåªä»¥åº•åº§ç‚ºåŸºæº–ï¼‰
            if (pieceData.name === 'demon' || pieceData.name === 'devil') {
                lod.userData.playerCollisionRadius = lod.userData.collisionRadius * 0.7; // ç¸®å°30%
            } else {
                lod.userData.playerCollisionRadius = lod.userData.collisionRadius; // å…¶ä»–æ£‹å­ä½¿ç”¨æ­£å¸¸åŠå¾‘
            }
            
            lod.frustumCulled = false; 

            return lod;
        }
        
        // [ä¿®æ­£] è£½ä½œç ´ç¢å…­é‚Šå½¢è­·ç›¾ (é‚Šç·£å®Œæ•´ä¿ç•™ï¼Œä¸åšæ¼¸å±¤æ·¡å‡ºï¼Œè¶…éç¯„åœç›´æ¥ä¸ç•«)
        function createBrokenHexShieldTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // 1. æ¸…ç©ºèƒŒæ™¯
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.clearRect(0, 0, 512, 512);
            
            const r = 32; 
            const w = r * 2;
            const h = Math.sqrt(3) * r;
            const centerX = 256;
            const centerY = 256;
            // è¨­å®šå®‰å…¨åŠå¾‘ï¼Œç¢ºä¿å…­é‚Šå½¢å®Œæ•´é¡¯ç¤ºä¸è¢«åˆ‡æ–· (512/2 = 256, æ‰£æ‰ä¸€å€‹å…­é‚Šå½¢åŠå¾‘ç´„ 32ï¼Œè¨­ 223 ä¿éšª)
            const safeRadius = 224; 
            
            // 2. ç¹ªè£½å…­é‚Šå½¢ç¶²æ ¼
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3; 
            ctx.lineJoin = 'round';
            
            let row = 0;
            // ç¸®å°è¿´åœˆç¯„åœï¼Œä¸ç”¨ç•«åˆ°æ»¿ç‰ˆå†é®æ‰ï¼Œç›´æ¥ç•«åœ¨ä¸­å¿ƒé™„è¿‘å³å¯
            for (let y = -h; y < 512 + h; y += h * 0.75) {
                const offset = (row % 2 === 0) ? 0 : w * 0.75;
                for (let x = -w + offset; x < 512 + w; x += w * 1.5) {
                    
                    // [é—œéµä¿®æ­£] è¨ˆç®—æ­¤å…­é‚Šå½¢çš„ä¸­å¿ƒé»è·é›¢
                    const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                    
                    // å¦‚æœè·é›¢è¶…éå®‰å…¨ç¯„åœï¼Œé€™å€‹å…­é‚Šå½¢ç›´æ¥ä¸ç•«ï¼Œä¿è­‰é‚Šç·£æ˜¯ä¹¾æ·¨çš„
                    if (dist > safeRadius) continue;

                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 3 * i;
                        const hx = x + r * Math.cos(angle);
                        const hy = y + r * Math.sin(angle);
                        if (i === 0) ctx.moveTo(hx, hy);
                        else ctx.lineTo(hx, hy);
                    }
                    ctx.closePath();
                    
                    // 33% æ©Ÿç‡å¡«è‰²
                    if (Math.random() < 0.33) {
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                        ctx.fill();
                    }
                    
                    ctx.globalAlpha = 0.4;
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }
                row++;
            }

            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        function createDoricColumn() { 
            const group = new THREE.Group(); 
            const material = columnMat; 
            const targetHeight = 66; 
            const radius = 9; 
            const flutes = 20; 
            const base1H = 3.6, base2H = 2.7, top1H = 2.7, top2H = 3.6; 
            const shaftHeight = targetHeight - (base1H + base2H + top1H + top2H); 
            
            const base1 = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, base1H, 64), material); 
            base1.position.y = base1H / 2; 
            const base2 = new THREE.Mesh(new THREE.CylinderGeometry(radius*0.9, radius*0.9, base2H, 64), material); 
            base2.position.y = base1H + base2H / 2; 
            group.add(base1, base2); 
            
            const shape = new THREE.Shape(); 
            const outerRadius = radius*0.85, innerRadius = outerRadius*0.95; 
            for (let i = 0; i < flutes; i++) { 
                const startAngle = (i/flutes)*Math.PI*2, endAngle = ((i+0.7)/flutes)*Math.PI*2; 
                shape.moveTo(outerRadius*Math.cos(startAngle), outerRadius*Math.sin(startAngle)); 
                shape.absarc(0, 0, outerRadius, startAngle, endAngle, false); 
                shape.absarc(0, 0, innerRadius, endAngle, startAngle, true); 
                shape.lineTo(outerRadius*Math.cos(startAngle), outerRadius*Math.sin(startAngle)); 
            } 
            const shaft = new THREE.Mesh(new THREE.ExtrudeGeometry(shape, { depth: shaftHeight, bevelEnabled: false }), material); 
            shaft.rotation.x = -Math.PI / 2; 
            shaft.position.y = base1H + base2H; 
            group.add(shaft); 
            
            const top1 = new THREE.Mesh(new THREE.CylinderGeometry(radius*0.9, radius*0.9, top1H, 64), material); 
            top1.position.y = targetHeight - top2H - top1H / 2; 
            const top2 = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, top2H, 64), material); 
            top2.position.y = targetHeight - top2H / 2; 
            group.add(top1, top2); 
            
            group.traverse(child => { child.castShadow = true; child.receiveShadow = true; }); 
            
            group.userData.isColumn = true; 
            group.userData.floatState = 'ground'; 
            group.userData.collisionRadius = radius; 
            
            return group; 
        }

        function createObstacles() {
            const occupiedSpaces = [];
            
            const isPositionOccupied = (pos, radius, checkPieces, checkColumns) => {
                for (const space of occupiedSpaces) {
                    if ((checkPieces && space.isPiece) || (checkColumns && !space.isPiece)) {
                        if (pos.distanceTo(space.position) < radius + space.radius) {
                            return true;
                        }
                    }
                }
                return false;
            };
            
            const pieceTypes = [ 
                { name: 'pawn', count: 8, speedRange: [5, 9], targetHeight: 18 }, 
                { name: 'rook', count: 6, speedRange: [8, 13], targetHeight: 22 }, 
                { name: 'horse', count: 6, speedRange: [11, 18], targetHeight: 24 }, 
                { name: 'bishop', count: 6, speedRange: [9, 15], targetHeight: 26 }, 
                { name: 'queen', count: 4, speedRange: [12, 20], targetHeight: 28 }, 
                { name: 'king', count: 4, speedRange: [4, 7], targetHeight: 30 }, 
                { name: 'angel', count: 5, speedRange: [14, 22], targetHeight: 32 }, 
                { name: 'demon', count: 5, speedRange: [14, 22], targetHeight: 32 }, 
            ];
            
            const darkMaterial = new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.4, metalness: 0.2, name: 'Black'});
            const lightMaterial = new THREE.MeshStandardMaterial({color: 0xeeeeee, roughness: 0.4, metalness: 0.2, name: 'White'});
            
            const pillarCount = 12 + 24;
            for (let i = 0; i < pillarCount; i++) { 
                let pos;
                const columnRadius = 12;
                let attempts = 0;
                
                if (i >= 12) { 
                    const side = Math.floor((i - 12) / 6); 
                    const indexOnSide = (i - 12) % 6; 
                    const spacing = (boundary * 2) / 7; 
                    const coord = -boundary + spacing * (indexOnSide + 1); 
                    switch(side) { 
                        case 0: pos = new THREE.Vector3(coord, 0, boundary - 5); break; 
                        case 1: pos = new THREE.Vector3(coord, 0, -boundary + 5); break; 
                        case 2: pos = new THREE.Vector3(boundary - 5, 0, coord); break; 
                        case 3: pos = new THREE.Vector3(-boundary + 5, 0, coord); break; 
                    } 
                } else { 
                    do { 
                        pos = new THREE.Vector3((Math.random() - 0.5) * boundary * 1.8, 0, (Math.random() - 0.5) * boundary * 1.8); 
                        attempts++;
                        // [ä¿®æ­£] å¼·åˆ¶æª¢æŸ¥æ˜¯å¦å¤ªé è¿‘ä¸­å¤® (åŠå¾‘ < 60)ï¼ŒåŸæœ¬å¬å–šé™£ç´„48ï¼Œå¢åŠ 12å¾Œè¨­ç‚º60
                    } while((isPositionOccupied(pos, columnRadius, false, true) || pos.length() < 60) && attempts < 100);
                }
                occupiedSpaces.push({ position: pos.clone(), radius: columnRadius, isPiece: false });
                
                const column = createDoricColumn(); 
                column.position.copy(pos); 
                
                // æˆ‘å€‘æ”¹ç”¨è¿½åŠ å±¬æ€§çš„æ–¹å¼ï¼Œä¿ç•™ createDoricColumn è£¡è¨­å®šå¥½çš„ isColumn å’Œ floatState
                column.userData.isMovable = false;
                column.userData.bbox = new THREE.Box3().setFromObject(column);

                scene.add(column); 
                obstacles.push(column); 
            }

            pieceTypes.forEach(pieceData => {
                for (let i = 0; i < pieceData.count; i++) {
                    const material = (i < Math.ceil(pieceData.count / 2)) ? darkMaterial : lightMaterial;
                    const pieceLOD = createPieceLOD(pieceData, material);
                    
                    if (!pieceLOD) continue;

                    let pos, attempts = 0;
                    const pieceRadius = pieceLOD.userData.collisionRadius + 2;
                    do {
                        pos = new THREE.Vector3((Math.random() - 0.5) * boundary * 1.8, 0, (Math.random() - 0.5) * boundary * 1.8);
                        attempts++;
                    } while (isPositionOccupied(pos, pieceRadius, true, true) && attempts < 100);
                    
                    occupiedSpaces.push({ position: pos.clone(), radius: pieceRadius, isPiece: true });
                    pieceLOD.position.copy(pos);
                    
                    const speed = pieceData.speedRange[0] + Math.random() * (pieceData.speedRange[1] - pieceData.speedRange[0]);
                    
                    pieceLOD.userData = { 
                        ...pieceLOD.userData, 
                        isMovable: true, 
                        moveAxis: Math.random() > 0.5 ? 'x' : 'z', 
                        range: 100 + Math.random() * 200, 
                        speed: speed, 
                        direction: Math.random() > 0.5 ? 1 : -1, 
                        initialPos: pieceLOD.position.clone(),
                        isDevil: pieceData.name === 'devil'
                    };
                    scene.add(pieceLOD);
                    obstacles.push(pieceLOD);
                }
            });
        }

        function createBipyramid(material) { const radius = 1.5, height = 2; const group = new THREE.Group(); const top = new THREE.Mesh(new THREE.ConeGeometry(radius, height, 3), material); top.position.y = height / 2; const bottom = new THREE.Mesh(new THREE.ConeGeometry(radius, height, 3), material); bottom.rotation.x = Math.PI; bottom.position.y = -height / 2; group.add(top, bottom); group.userData.isBipyramid = true; return group; }

        // å¯¶ç‰©è¨­å®šè³‡æ–™ (å…¨åŸŸ)
        const treasureConfigs = [ 
            { shape: 'icosahedron', color: 0xffcc00, emissive: 0xffaa00 }, // 1. é»ƒ (ä¸€èˆ¬)
            { shape: 'icosahedron', color: 0x00aaff, emissive: 0x0088ee }, // 2. è— (ä¸€èˆ¬)
            { shape: 'bipyramid', color: 0xff4444, emissive: 0xee2222 },   // 3. ç´… (ä¸€èˆ¬)
            { shape: 'icosahedron', color: 0x55ff55, emissive: 0x33ee33 }, // 4. ç¶  (ä¸€èˆ¬)
            { shape: 'bipyramid', color: 0xff88cc, emissive: 0xff66bb },   // 5. ç²‰ (ä¸€èˆ¬)
            { shape: 'dodecahedron', color: 0x9932CC, emissive: 0x8A2BE2 } // 6. ç´« (ç‰¹æ®Š - é´¨å­æ‰è½)
        ];

        // [æ–°åŠŸèƒ½] åœ¨æŒ‡å®šä½ç½®ç”ŸæˆæŒ‡å®šé¡å‹çš„å¯¶ç‰©
        function spawnSpecificTreasure(position, configIndex) {
            const config = treasureConfigs[configIndex];
            const treasureMat = new THREE.MeshStandardMaterial({ color: config.color, emissive: config.emissive, emissiveIntensity: 1.5, roughness: 0.2, metalness: 0.8 });
            let treasure; 
            
            if (config.shape === 'bipyramid') { 
                treasure = createBipyramid(treasureMat); 
            } else if (config.shape === 'dodecahedron') {
                const treasureGeo = new THREE.DodecahedronGeometry(1.5, 0);
                treasure = new THREE.Mesh(treasureGeo, treasureMat);
            } else { 
                const treasureGeo = new THREE.IcosahedronGeometry(1.5, 0); 
                treasure = new THREE.Mesh(treasureGeo, treasureMat); 
            }
            
            treasure.position.copy(position);
            treasure.userData.color = new THREE.Color(config.color);
            treasure.userData.isBipyramid = (config.shape === 'bipyramid'); // ç¢ºä¿æµ®å‹•å‹•ç•«æ­£å¸¸

            const pointLight = new THREE.PointLight(config.emissive, 2, 20); 
            pointLight.position.y = 3; 
            treasure.add(pointLight);
            
            const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: glowTexture, transparent: true, alphaTest: 0.01, depthWrite: false, blending: THREE.AdditiveBlending, opacity: 0.8 })); 
            glowSprite.scale.set(12, 12, 1); 
            treasure.add(glowSprite);
            
            scene.add(treasure); 
            treasures.push(treasure);
        }

        function createTreasures() {
            for (let i = 0; i < 4; i++) {
                let pos = findValidSpawnPosition(); 
                spawnSpecificTreasure(pos, i);
            }
        }
        
        // [ä¿®æ­£ç‰ˆ] å¯¶ç‰©ç”Ÿæˆé‚è¼¯ (å€åˆ†æŸ±å­èˆ‡å¯¶ç‰©è·é›¢ï¼Œå¿½ç•¥ç§»å‹•æ£‹å­)
        function findValidSpawnPosition() {
            let pos, valid;
            let attempts = 0;
            const maxAttempts = 600; 
            const spawnBoundary = boundary * 0.8; 

            // [åƒæ•¸è¨­å®š]
            const distToColumn = 15;   // å…è¨±é›¢æŸ±å­è¿‘ä¸€é» (åŸæœ¬æ˜¯æ··åˆåˆ¤æ–·ï¼Œç¾åœ¨åˆ†é–‹)
            const distToTreasure = 120; // å¯¶ç‰©ä¹‹é–“è¦é ä¸€é»
            const distToPlayer = 120;   // é›¢ç©å®¶è¦é 

            do {
                valid = true;
                pos = new THREE.Vector3(
                    (Math.random() - 0.5) * spawnBoundary * 2, 
                    3, 
                    (Math.random() - 0.5) * spawnBoundary * 2
                );
                
                for (const obs of obstacles) {
                    // åªæª¢æŸ¥ä¸å¯ç§»å‹•çš„ (æŸ±å­ã€ç‰†å£)ï¼Œå¿½ç•¥æœƒå‹•çš„æ£‹å­
                    if (!obs.userData.isMovable && obs.position) {
                        if (pos.distanceTo(obs.position) < distToColumn) {
                            valid = false;
                            break;
                        }
                    }
                }

                if (valid) {
                    for (const t of treasures) {
                        if (pos.distanceTo(t.position) < distToTreasure) {
                            valid = false;
                            break;
                        }
                    }
                }

                if (valid && player) {
                    if (pos.distanceTo(player.position) < distToPlayer) {
                        valid = false;
                    }
                }

                attempts++;
            } while (!valid && attempts < maxAttempts);
            
            if (!valid) { 
                 pos.set(0, 3, -boundary + 20);
            }
            return pos;
        }

        function createExit() {
            exit_portal = new THREE.Group();
            const frame_w = 10, frame_h = 16;
            
            // 1. é–€çš„æœ¬é«” (ä¿æŒä¸è®Š)
            const portal_geom = new THREE.PlaneGeometry(frame_w, frame_h);
            const portal_mesh = new THREE.Mesh(portal_geom, portalMaterial);
            portal_mesh.position.y = frame_h / 2;
            exit_portal.add(portal_mesh);

            // 2. åœ°æ¿æŠ•å°„å…‰
            const lightW = 72;  // [å…‰ç·šæœ€å¤§å¯¬åº¦] æ§åˆ¶å…‰æŠ•å°„åœ¨åœ°ä¸Šçš„æœ€å¯¬è™• (å–®ä½:ç±³)
            const lightL = 69;  // [å…‰ç·šæŠ•å°„é•·åº¦] æ§åˆ¶å…‰å¾€å‰å°„å¤šé  (å–®ä½:ç±³)
            // ------------------

            const lightGeo = new THREE.PlaneGeometry(lightW, lightL);
            const lightTexture = createDoorLightTexture();
            
            const lightMaterial = new THREE.MeshBasicMaterial({ 
                map: lightTexture, 
                color: 0xffffff, 
                transparent: true, 
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                side: THREE.DoubleSide
            });
            
            const lightMesh = new THREE.Mesh(lightGeo, lightMaterial);
            // 1. èººå¹³
            lightMesh.rotation.x = -Math.PI / 2; 
            lightMesh.rotation.z = Math.PI; 
            lightMesh.position.set(0, 0.01, lightL / 2); 
            
            exit_portal.add(lightMesh);

            // [ä¿®æ­£] ç¨ç«‹çš„é–€ç”Ÿæˆé‚è¼¯ï¼šæ”¾å¯¬é™åˆ¶ï¼Œç¢ºä¿é é›¢ç©å®¶
            let pos = new THREE.Vector3();
            let valid = false;
            let attempts = 0;
            const doorRadius = 8; // é–€çš„åŠå¾‘ (å¯¬åº¦çš„ä¸€åŠ + ä¸€é»ç·©è¡)
            const spawnLimit = boundary - 20; // é¿å…é–€ç”Ÿæˆåœ¨ç‰†å£è£¡

            do {
                valid = true;
                attempts++;

                // 1. éš¨æ©Ÿç”Ÿæˆåº§æ¨™
                pos.set(
                    (Math.random() - 0.5) * 2 * spawnLimit, 
                    0, 
                    (Math.random() - 0.5) * 2 * spawnLimit
                );

                // 2. åš´æ ¼æª¢æŸ¥ï¼šå¿…é ˆè·é›¢ç©å®¶ 150 ä»¥ä¸Š
                if (pos.distanceTo(player.position) < 150) {
                    valid = false;
                    continue;
                }

                // 3. æ”¾å¯¬æª¢æŸ¥ï¼šåªæª¢æŸ¥æŸ±å­ï¼Œåªè¦ä¸é‡ç–Šå°±å¥½
                for (const obs of obstacles) {
                    if (obs.userData.isColumn) {
                        const colRadius = obs.userData.collisionRadius || 12;
                        // è·é›¢ > (æŸ±å­åŠå¾‘ + é–€åŠå¾‘)ï¼Œå‰›å¥½ä¸é‡ç–Š
                        if (pos.distanceTo(obs.position) < (colRadius + doorRadius)) {
                            valid = false;
                            break;
                        }
                    }
                }
            } while (!valid && attempts < 600); // å˜—è©¦ 600 æ¬¡ï¼Œç¢ºä¿èƒ½æ‰¾åˆ°ä½ç½®

            // 4. [ä¿éšª] è¬ä¸€çœŸçš„é›–åˆ°æ‰¾ä¸åˆ°ï¼Œå¼·åˆ¶æ”¾åœ¨åœ°åœ–å°è§’ç·šæœ€é è™•ï¼Œçµ•ä¸æ”¾ä¸­é–“
            if (!valid) {
                // å¦‚æœç©å®¶åœ¨ Z æ­£åŠéƒ¨ï¼Œé–€å°±å» Z è² åŠéƒ¨ï¼Œåä¹‹äº¦ç„¶
                const safeZ = player.position.z > 0 ? -spawnLimit : spawnLimit;
                const safeX = -player.position.x; // X è»¸ç›¸å
                pos.set(safeX, 0, safeZ);
            }

            exit_portal.position.copy(pos);
            exit_portal.position.y = 0;
            exit_portal.visible = false; 
            exit_portal.userData.winZone = new THREE.Box3( new THREE.Vector3(-frame_w / 2, 0, -1), new THREE.Vector3(frame_w / 2, frame_h, 0.1) );
            
            const blockerGeom = new THREE.BoxGeometry(frame_w, frame_h, 0.5);
            const blockerMat = new THREE.MeshBasicMaterial({visible: false});
            const blockerMesh = new THREE.Mesh(blockerGeom, blockerMat);
            blockerMesh.position.set(0, frame_h / 2, 0.75);
            exit_portal.add(blockerMesh);
            blockerMesh.userData = { isMovable: false, isPortalBlocker: true, bbox: new THREE.Box3(), collisionRadius: frame_w / 2 };
            obstacles.push(blockerMesh);
            
            scene.add(exit_portal);
        }
        
        // [æ–°å¢] èƒŒæ™¯é£„æµ®éšæ¢¯ç”Ÿæˆå™¨
        function createSkyStairs() {
            // 1. å®šç¾©å–®ä¸€éšæ¢¯å½¢ç‹€ (æ¨™æº–ä¸Šæ‰¿å¼ L å‹)
            const treadGeo = new THREE.BoxGeometry(21.5, 1, 9); 
            const riserGeo = new THREE.BoxGeometry(21, 9.5, 1); 
                        
            // è¸æ¿: ä¸­å¿ƒåœ¨ (0,0,0)
            treadGeo.translate(0, 0, 0); 
            
            // å‚ç›´æ¿: ä½æ–¼è¸æ¿ "å‰æ–¹(+Z)" ä¸” "å¾€ä¸Š(+Y)"
            // Z = 4.5 (è¸æ¿å‰ç·£) + 0.5 (å‚ç›´æ¿åŠåš) = 5.0
            // Y = 0.5 (è¸æ¿é ‚é¢) + 4.5 (å‚ç›´æ¿åŠé«˜) = 5.0
            riserGeo.translate(0, 4.5, 4.5); 
            
            const stepGeometry = BufferGeometryUtils.mergeGeometries([treadGeo, riserGeo]);
            treadGeo.dispose();
            riserGeo.dispose();

            // 2. åƒæ•¸è¨­å®š
            const staircasesCount = 24; 
            const stepsPerStair = 36;   
            const totalInstances = staircasesCount * stepsPerStair;

            // 3. æè³ªè¨­å®š
            const material = new THREE.MeshLambertMaterial({ 
                color: 0xAABBC0, // æŒ‡å®šçš„ç°ç™½è‰²
                side: THREE.DoubleSide,
                fog: true // é–‹å•Ÿéœ§æ°£ï¼Œè®“é è™•æ¼¸éš±
            });

            const mesh = new THREE.InstancedMesh(stepGeometry, material, totalInstances);
            mesh.instanceMatrix.setUsage(THREE.StaticDrawUsage);
            
            const dummy = new THREE.Object3D();
            let index = 0;
            const noGoZone = { minX: -300, maxX: 300, minZ: -300, maxZ: 300, minY: -30 };

            for (let i = 0; i < staircasesCount; i++) {
                let startPos, globalRot, globalQuat;
                let isCurved, curveRadius, curveDir;
                let isValidPosition = false;
                let attempts = 0;

                const stepHeight = 9.0;
                const stepDepth = 9.0; 

                // ä½ç½®åµæ¸¬è¿´åœˆ
                while (!isValidPosition && attempts < 50) {
                    attempts++;
                    const spawnAngle = Math.random() * Math.PI * 2;
                    const spawnDist = 460 + Math.random() * 290; 
                    const randomY = (Math.random() * 330) - 180;
                    startPos = new THREE.Vector3(Math.cos(spawnAngle)*spawnDist, randomY, Math.sin(spawnAngle)*spawnDist);

                    globalRot = new THREE.Euler((Math.random()-0.5)*0.3, Math.random()*Math.PI*2, (Math.random()-0.5)*0.3);
                    globalQuat = new THREE.Quaternion().setFromEuler(globalRot);

                    isCurved = Math.random() > 0.5;
                    curveRadius = 150 + Math.random() * 150; 
                    curveDir = Math.random() > 0.5 ? 1 : -1;

                    //å¤šé»æª¢æ¸¬ï¼šè¨ˆç®— "çµ‚é»" èˆ‡ "ä¸­é»"
                    const lastIndex = stepsPerStair;
                    const midIndex = Math.floor(stepsPerStair / 2);

                    const getLocalPos = (k) => {
                        if (isCurved) {
                            const angle = (k * stepDepth / curveRadius) * curveDir;
                            return new THREE.Vector3(
                                curveRadius * (1 - Math.cos(angle)), 
                                k * stepHeight, 
                                curveRadius * Math.sin(angle)
                            );
                        } else {
                            return new THREE.Vector3(0, k * stepHeight, k * stepDepth);
                        }
                    };

                    const endLocal = getLocalPos(lastIndex);
                    const midLocal = getLocalPos(midIndex);
                    
                    const endPos = endLocal.applyQuaternion(globalQuat).add(startPos);
                    const midPos = midLocal.applyQuaternion(globalQuat).add(startPos);

                    // æª¢æŸ¥å‡½å¼ï¼šæ˜¯å¦åœ¨ç¦å€å…§
                    const isInZone = (p) => {
                        return (p.x > noGoZone.minX && p.x < noGoZone.maxX) && 
                               (p.z > noGoZone.minZ && p.z < noGoZone.maxZ) && 
                               (p.y > noGoZone.minY);
                    };

                    // åªè¦ èµ·é»ã€ä¸­é»ã€çµ‚é» ä»»ä½•ä¸€å€‹åœ¨ç¦å€ï¼Œå°±è¦–ç‚ºå¤±æ•—
                    if (!isInZone(startPos) && !isInZone(midPos) && !isInZone(endPos)) {
                        isValidPosition = true;
                    }
                }

                // ç”Ÿæˆæ¯ä¸€éš
                for (let j = 0; j < stepsPerStair; j++) {
                    const currPos = new THREE.Vector3();
                    const nextPos = new THREE.Vector3();

                    if (isCurved) {
                        // å½æ›²é‚è¼¯ï¼šæ²¿è‘—åœ“å¼§å‰é€²
                        const angleCurr = (j * stepDepth / curveRadius) * curveDir;
                        const angleNext = ((j + 1) * stepDepth / curveRadius) * curveDir;

                        currPos.set(
                            curveRadius * (1 - Math.cos(angleCurr)), 
                            j * stepHeight, 
                            curveRadius * Math.sin(angleCurr)
                        );
                        nextPos.set(
                            curveRadius * (1 - Math.cos(angleNext)), 
                            j * stepHeight,
                            curveRadius * Math.sin(angleNext)
                        );
                    } else {
                        // ç›´ç·šé‚è¼¯ï¼šå¾€ +Z å‰é€²
                        currPos.set(0, j * stepHeight, j * stepDepth);
                        nextPos.set(0, j * stepHeight, (j + 1) * stepDepth);
                    }

                    dummy.position.copy(currPos);
                    dummy.lookAt(nextPos); // é—œéµï¼šçœ‹å‘ä¸‹ä¸€éšï¼Œä¿è­‰æ–¹å‘æ­£ç¢º
                    dummy.quaternion.premultiply(globalQuat);
                    dummy.position.applyQuaternion(globalQuat).add(startPos);

                    dummy.updateMatrix();
                    mesh.setMatrixAt(index++, dummy.matrix);
                }
            }

            mesh.instanceMatrix.needsUpdate = true;
            mesh.renderOrder = -10; 
            scene.add(mesh);
            mesh.userData.isBackgroundStairs = true;
            obstacles.push(mesh); 
        }

        // [ä¿®æ”¹ç‰ˆ] é åˆ¤ç©å®¶èµ°ä½å‡½å¼ (åŠ å…¥ 60/40 åšå¼ˆé‚è¼¯)
        function getPredictedPlayerPos(flightTimeSeconds) {
            const currentVelocity = velocity.clone();
            
            // [é—œéµä¿®æ”¹] åšå¼ˆé‚è¼¯ Math.random() < 0.6 ä»£è¡¨ 60% çš„æ©Ÿç‡
            // å¦‚æœæˆç«‹(60%) -> factor = 0.6 (é åˆ¤ä½ æœƒå¾€å‰è·‘ï¼Œå°„ä½ å‰é¢)
            // å¦‚æœä¸æˆç«‹(40%) -> factor = -0.6 (é åˆ¤ä½ æœƒæ€¥åœæˆ–åè·‘ï¼Œå°„ä½ å¾Œé¢)
            const predictionFactor = Math.random() < 0.6 ? 0.7 : -0.3;

            const prediction = currentVelocity.multiplyScalar(flightTimeSeconds * predictionFactor); 
            
            const predictedPos = player.position.clone().add(prediction);
            
            // é™åˆ¶åœ¨é‚Šç•Œå…§
            const limit = 230;
            predictedPos.x = Math.max(-limit, Math.min(limit, predictedPos.x));
            predictedPos.z = Math.max(-limit, Math.min(limit, predictedPos.z));
            predictedPos.y = 0; 
            
            return predictedPos;
        }

// --- æ¼©æ¸¦å‹•ç•«å‡½å¼ ---
function startVortexAnimation(position) {
    if (!vortexTexture) return;
    if (vortexManager.pivot) scene.remove(vortexManager.pivot);

    const baseMaterial = new THREE.MeshBasicMaterial({
        map: vortexTexture,
        transparent: true,
        opacity: 1.0,
        alphaTest: 0.01,
        side: THREE.DoubleSide,
        fog: false // [æ–°å¢] é—œé–‰è¿·éœ§å½±éŸ¿
    });
    const geometry = new THREE.PlaneGeometry(1, 1);

    const vortexUpright = new THREE.Mesh(geometry, baseMaterial);
    const vortexTilted = new THREE.Mesh(geometry, baseMaterial.clone());
    vortexTilted.rotation.x = Math.PI / 1.8;

    const pivot = new THREE.Group();
    pivot.add(vortexUpright);
    pivot.add(vortexTilted);

    const desiredDiameter = 78;

    // --- ã€é—œéµä¿®æ­£ã€‘æ¢å¾©ä½ç½®èˆ‡é«˜åº¦è¨­å®š ---

    // 1. è¨ˆç®—BOSSçš„æ­£å‰æ–¹å‘é‡
    const forward = new THREE.Vector3(0, 0, 1);
    forward.applyQuaternion(bossManager.mesh.quaternion);

    // 2. è¨­å®šè»¸å¿ƒé»çš„åˆå§‹ä½ç½®åœ¨BOSSä¸­å¿ƒ
    pivot.position.copy(position);

    // 3. æé«˜åˆ°æ‚¨æƒ³è¦çš„é ­éƒ¨é«˜åº¦
    pivot.position.y += 30; 

    // 4. æ²¿è‘—BOSSçš„æ­£å‰æ–¹ï¼Œå°‡æ•´å€‹ç‰¹æ•ˆæ¨å‡º33ç±³
    pivot.position.add(forward.multiplyScalar(33));

    // --- (å¾Œé¢ä¸è®Š) ---
    pivot.scale.set(0, 0, 0);

    scene.add(pivot);
    vortexManager.pivot = pivot;
    vortexManager.active = true;
    vortexManager.animation = {
        state: 'scaling_in',
        startTime: performance.now(),
        targetScale: desiredDiameter
    };
}

function updateVortex(time, delta) {
    if (!vortexManager.active || !vortexManager.pivot) return;

    const anim = vortexManager.animation;
    const elapsed = time - anim.startTime;
    const pivot = vortexManager.pivot;

    // --- ã€é—œéµä¿®æ­£ã€‘ ---
    // æ¯ä¸€å¹€éƒ½è®“æ•´å€‹è»¸å¿ƒé»(åŒ…å«å…©å€‹æ¼©æ¸¦)é¢å‘æ”å½±æ©Ÿ
    pivot.lookAt(camera.position);
    // --- ã€ä¿®æ­£çµæŸã€‘ ---

    // è®“è»¸å¿ƒé»è£¡çš„å…©å€‹æ¼©æ¸¦ã€Œå„è‡ªã€ç¶­æŒè‡ªå·±çš„åŸåœ°è‡ªè½‰
    const rotationSpeed = 4;
    pivot.children.forEach(child => {
        child.rotation.z += rotationSpeed * delta;
    });

    switch (anim.state) {
        case 'scaling_in': {
            const duration = 1000;
            const progress = Math.min(elapsed / duration, 1);
            const scale = anim.targetScale * progress * progress;
            pivot.scale.set(scale, scale, scale);
            if (progress >= 1) {
                anim.state = 'spinning';
                anim.startTime = time;
            }
            break;
        }
        case 'spinning': {
            const duration = 2000;
            if (elapsed >= duration) {
                anim.state = 'fading_out';
                anim.startTime = time;
            }
            break;
        }
        case 'fading_out': {
            const duration = 500;
            const progress = Math.min(elapsed / duration, 1);
            const opacity = 1.0 - progress;
            pivot.children.forEach(child => {
                child.material.opacity = opacity;
            });

            if (progress >= 1) {
                vortexManager.active = false;
                scene.remove(pivot);
                pivot.children[0].geometry.dispose();
                pivot.children[0].material.dispose();
                pivot.children[1].material.dispose();
                vortexManager.pivot = null;
            }
            break;
        }
    }
}

// --- æ”»æ“Šç‰¹æ•ˆå‹•ç•«å‡½å¼ ---
function startAttackEffect(position) {
    if (!attackEffectTexture) return;
    if (attackEffectManager.sprite) scene.remove(attackEffectManager.sprite);

    const material = new THREE.SpriteMaterial({ 
        map: attackEffectTexture, 
        transparent: true, 
        opacity: 1.0,
        blending: THREE.NormalBlending, 
        alphaTest: 0.01,
        fog: false // [æ–°å¢] é—œé–‰è¿·éœ§å½±éŸ¿ï¼Œè®“åœ–æ¡ˆä¿æŒæ¸…æ™°
    });
    const sprite = new THREE.Sprite(material);

    // ã€é—œéµä¿®æ­£ã€‘åŒæ¨£è¨ˆç®—BOSSçš„æ­£å‰æ–¹å‘é‡
    const forward = new THREE.Vector3(0, 0, 1);
    forward.applyQuaternion(bossManager.mesh.quaternion);

    sprite.position.copy(position);
    sprite.position.y += 45;
    sprite.position.add(forward.multiplyScalar(36)); // å°‡ç‰¹æ•ˆæ²¿è‘—BOSSå‰æ–¹æ¨å‡º33ç±³

    sprite.scale.set(0, 0, 1);

    scene.add(sprite);
    attackEffectManager.sprite = sprite;
    attackEffectManager.active = true;
    attackEffectManager.animation = {
        state: 'active',
        startTime: performance.now(),
        nextRotationTime: performance.now() // [æ–°å¢] åˆå§‹åŒ–æ—‹è½‰è¨ˆæ™‚å™¨
    };
}

function updateAttackEffect(time, delta) {
    if (!attackEffectManager.active || !attackEffectManager.sprite) return;

    const anim = attackEffectManager.animation;
    const elapsed = time - anim.startTime;
    const sprite = attackEffectManager.sprite;
    const duration = 2000; // ç¸½æŒçºŒæ™‚é–“1ç§’

    // æ¯ 0.2 ç§’éš¨æ©Ÿè®Šæ›ä¸€å€‹è§’åº¦
    if (time > anim.nextRotationTime) {
        sprite.material.rotation = Math.random() * Math.PI * 2; // 0~360åº¦éš¨æ©Ÿ
        anim.nextRotationTime = time + 50; // è¨­ç½®ä¸‹ä¸€æ¬¡è®Šæ›çš„æ™‚é–“ (0.05ç§’å¾Œ)
    }

    const progress = Math.min(elapsed / duration, 1);

    // å‰åŠæ®µæ”¾å¤§
    const scaleProgress = Math.min(elapsed / (duration * 0.5), 1);
    const scale = 69 * (1 - Math.pow(1 - scaleProgress, 3)); // ç·©å‹•æ”¾å¤§
    sprite.scale.set(scale, scale, 1);

    // å¾ŒåŠæ®µæ·¡å‡º
    if (elapsed > duration * 0.5) {
        const fadeProgress = Math.min((elapsed - duration * 0.5) / (duration * 0.5), 1);
        sprite.material.opacity = 1.0 - fadeProgress;
    }

    if (progress >= 1) {
        attackEffectManager.active = false;
        scene.remove(sprite);
        attackEffectManager.sprite = null;
    }
}

        function createBird() {
            if (birdManager.isActive) return;
            const birdGroup = new THREE.Group();
            const birdGeo = new THREE.PlaneGeometry(39, 39);
            const birdMat = new THREE.MeshBasicMaterial({ map: birdTexture, transparent: true, alphaTest: 0.01, side: THREE.DoubleSide });
            const birdPlane = new THREE.Mesh(birdGeo, birdMat);
            
            birdPlane.rotation.x = -Math.PI / 2;
            birdPlane.rotation.z = Math.PI; 
            birdGroup.add(birdPlane);
            
            birdManager.mesh = birdGroup;

            const side = Math.floor(Math.random() * 4);
            const randomCoord = (Math.random() - 0.5) * boundary * 1.8;
            let spawnPos;
            switch(side) {
                case 0: spawnPos = new THREE.Vector3(boundary - 2, 0.4, randomCoord); break; 
                case 1: spawnPos = new THREE.Vector3(-boundary + 2, 0.4, randomCoord); break;
                case 2: spawnPos = new THREE.Vector3(randomCoord, 0.4, boundary - 2); break;
                case 3: spawnPos = new THREE.Vector3(randomCoord, 0.4, -boundary + 2); break;
            }
            birdGroup.position.copy(spawnPos);

            const directionToCenter = new THREE.Vector3(0, 0, 0).sub(birdGroup.position);
            const initialAngle = Math.atan2(directionToCenter.x, directionToCenter.z);
            birdGroup.rotation.y = initialAngle;

            scene.add(birdGroup);
            birdManager.isActive = true;
            birdManager.state = 'arc';
            birdManager.targetTimerActive = false; 
            birdManager.nextTargetTime = 0;
            birdManager.arcData.turnRate = (Math.random() > 0.5 ? 1 : -1) * 0.4;
            birdManager.dailyCrossCount = 0; // [æ–°å¢] æ¯æ—¥ç©¿è¶Šè¨ˆæ•¸å™¨
        }

        function updateBird(time, delta) {
            if (!birdManager.isActive || !birdManager.mesh) return;
            const bird = birdManager.mesh;

            // [æ–°å¢] æ·¡å‡ºæ¶ˆå¤±ç‹€æ…‹
            if (birdManager.state === 'fading_out') {
                bird.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.opacity = (child.material.opacity || 1) - delta * 0.5; // 2ç§’å…§æ·¡å‡º
                    }
                });
                bird.position.y += delta * 5;
                
                if (bird.children[0].material.opacity <= 0) {
                    scene.remove(bird);
                    birdManager.isActive = false;
                    birdManager.mesh = null;
                }
                return; // è™•æ–¼æ·¡å‡ºç‹€æ…‹æ™‚ï¼Œä¸åŸ·è¡Œå¾Œé¢çš„ç§»å‹•é‚è¼¯
            }

            if (skyCycleState === 'day' || skyCycleState === 'fadingToDay') {
                if (!birdManager.targetTimerActive && birdManager.dailyCrossCount < 1) {
                    birdManager.nextTargetTime = time + 4000 + Math.random() * 4000;
                    birdManager.targetTimerActive = true;
                }
            } else { 
                if (birdManager.targetTimerActive) {
                    birdManager.targetTimerActive = false;
                    birdManager.state = 'arc';
                }
            }
            if (birdManager.targetTimerActive && time >= birdManager.nextTargetTime) {
                birdManager.state = 'targeting';
                birdManager.dailyCrossCount++;
            }

            let moveSpeed;
            if (birdManager.state === 'targeting') {
                moveSpeed = birdManager.speed * 2;
                const directionToPlayer = player.position.clone().sub(bird.position);
                directionToPlayer.y = 0; 
                const distanceToPlayer = directionToPlayer.length();
                
                if (distanceToPlayer > 0.1) {
                    const targetAngle = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                    let angleDiff = targetAngle - bird.rotation.y;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    bird.rotation.y += angleDiff * delta * 4.0; 
                }
               
                if (distanceToPlayer < 4) { 
                    statusEffectManager.addStatus('huntingMark', 9); // ä½¿ç”¨æ–°çš„ç®¡ç†å™¨ï¼ŒæŒçºŒ9ç§’
                    birdManager.state = 'arc';
                    birdManager.nextTargetTime = time + 4000 + Math.random() * 4000;
                    birdManager.arcData.turnRate = (Math.random() > 0.5 ? 1 : -1) * 0.4;
                }
            } else { 
                moveSpeed = birdManager.speed;
                bird.rotation.y += birdManager.arcData.turnRate * delta;

                if (Math.abs(bird.position.x) > boundary - 10 || Math.abs(bird.position.z) > boundary - 10) {
                    const directionToCenter = new THREE.Vector3(0, 0, 0).sub(bird.position).normalize();
                    const targetAngle = Math.atan2(directionToCenter.x, directionToCenter.z);
                    let angleDiff = targetAngle - bird.rotation.y;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    birdManager.arcData.turnRate = Math.sign(angleDiff) * Math.abs(birdManager.arcData.turnRate);
                }
            }
            const forward = new THREE.Vector3(0, 0, 1);
            forward.applyQuaternion(bird.quaternion);
            bird.position.add(forward.multiplyScalar(moveSpeed * delta));
            bird.position.y = 0.4;
        }

        function activateSummoningPuzzle() {
            if (summoningCircle.active) return;
            createLissajousFigure();
            createSummoningCircle();
            summoningCircle.active = true;
            lissajousFigure.active = true;
        }

        function createLissajousCurve({A, B, C, a, b, c}) {
            const points = [];
            const delta = Math.PI / 2;
            const numPoints = 1000;
            for (let i = 0; i <= numPoints; i++) {
                const t = (i / numPoints) * Math.PI * 2;
                const x = A * Math.sin(a * t + delta);
                const y = B * Math.sin(b * t);
                const z = C * Math.sin(c * t);
                points.push(new THREE.Vector3(x, y, z));
            }
            return new THREE.CatmullRomCurve3(points, true);
        }
        
        function createLissajousFigure() {
            let symbolsPool = [...ZODIAC_SYMBOLS];
            requiredSymbols = [];
            for (let i = 0; i < 6; i++) {
                const randomIndex = Math.floor(Math.random() * symbolsPool.length);
                requiredSymbols.push(symbolsPool.splice(randomIndex, 1)[0]);
            }
            let orbSymbols = [...requiredSymbols, ...requiredSymbols];
            for (let i = orbSymbols.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [orbSymbols[i], orbSymbols[j]] = [orbSymbols[j], orbSymbols[i]];
            }

            const figureParams = { A: 75, B: 75, C: 75, a: 4, b: 3, c: 7 };
            const curve = createLissajousCurve(figureParams);
            
            lissajousFigure.group = new THREE.Group();
            lissajousFigure.orbs = [];
            lissajousFigure.curve = curve;
            const orbGeo = new THREE.SphereGeometry(8, 32, 16);

            for(let i=0; i<12; i++){
                const orbMesh = new THREE.Mesh(orbGeo, createOrbMaterial());
                
                const symbol = orbSymbols[i];
                const symbolTexture = createSymbolTexture(symbol, '#66ccff', 256);
                const symbolMaterial = new THREE.SpriteMaterial({ map: symbolTexture, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.9 });
                const symbolSprite = new THREE.Sprite(symbolMaterial);
                symbolSprite.scale.set(10, 10, 10);
                orbMesh.add(symbolSprite);
                orbMesh.userData.symbol = symbol;

                lissajousFigure.group.add(orbMesh);
                lissajousFigure.orbs.push({ mesh: orbMesh, progress: Math.random(), speed: 0.02 + Math.random() * 0.03 });
            }
            lissajousFigure.group.position.set(0, 78, 0);
            scene.add(lissajousFigure.group);
        }

        function createSummoningCircle() {
            summoningCircle.group = new THREE.Group();
            summoningCircle.symbols = [];
            const radius = 96 / 2;

            for (let i = 0; i < 12; i++) {
                const symbol = ZODIAC_SYMBOLS[i];
                const angle = (i / 12) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                const whiteGlowTexture = createGlowSymbolTexture(symbol, '#FFFFFF', 'rgba(255, 255, 255, 1.0)', 'rgba(200, 200, 255, 0.6)', 512, 0.9);
                const goldGlowTexture = createGlowSymbolTexture(symbol, '#FFFFE0', 'rgba(255, 223, 100, 1.0)', 'rgba(255, 180, 0, 0.6)', 512, 1.05);

                const material = new THREE.SpriteMaterial({
                    map: whiteGlowTexture,
                    transparent: true,
                    alphaTest: 0.01,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                });

                const sprite = new THREE.Sprite(material);
                sprite.position.set(x, 5.5, z);
                sprite.scale.set(20, 20, 20);

                const symbolObject = {
                    mesh: sprite,
                    symbol: symbol,
                    isActive: false,
                    whiteTexture: whiteGlowTexture,
                    goldTexture: goldGlowTexture,
                    lastTouchTime: 0
                };
                summoningCircle.symbols.push(symbolObject);
                summoningCircle.group.add(sprite);
            }
            summoningCircle.group.position.set(0, 0.1, 0);
            scene.add(summoningCircle.group);
        }
        
        function updateLissajousFigure(time, delta) {
            if (!lissajousFigure.active || !lissajousFigure.group || !lissajousFigure.curve || summoningCircle.puzzleSolved) return;
            
            lissajousFigure.group.rotation.y -= delta * 0.08;
            lissajousFigure.group.rotation.z += delta * 0.06;

            lissajousFigure.orbs.forEach(orb => {
                orb.progress = (orb.progress + orb.speed * delta) % 1;
                const newPos = lissajousFigure.curve.getPointAt(orb.progress);
                orb.mesh.position.copy(newPos);
            });
        }

        function updateSummoningCircle(time, delta) {
            if (!summoningCircle.active || !summoningCircle.group || summoningCircle.puzzleSolved) return;
            const worldPos = new THREE.Vector3();
            
            summoningCircle.symbols.forEach((symbolObj, i) => {
                symbolObj.mesh.rotation.y += delta * 0.4;
                symbolObj.mesh.position.y = 5.5 + Math.sin(time * 0.0025 + i * 0.5) * 0.5;

                symbolObj.mesh.getWorldPosition(worldPos);

                if (player.position.distanceTo(worldPos) < 8 && time - symbolObj.lastTouchTime > 2400) {
                    symbolObj.isActive = !symbolObj.isActive;
                    const newTexture = symbolObj.isActive ? symbolObj.goldTexture : symbolObj.whiteTexture;
                    if (symbolObj.mesh.material.map !== newTexture) {
                        symbolObj.mesh.material.map = newTexture;
                        symbolObj.mesh.material.needsUpdate = true;
                    }
                    symbolObj.lastTouchTime = time;
                    checkSummoningPuzzle(time);
                }
            });
        }

        function checkSummoningPuzzle(time) {
             if (summoningCircle.puzzleSolved) return;
             const activeSymbols = summoningCircle.symbols.filter(s => s.isActive).map(s => s.symbol);
             if (activeSymbols.length !== 6) return;

             const activeSet = new Set(activeSymbols);
             const requiredSet = new Set(requiredSymbols);

             if (activeSet.size === requiredSet.size && [...activeSet].every(symbol => requiredSet.has(symbol))) {
                summoningCircle.puzzleSolved = true;
                startSummoningAnimation(time);
             }
        }

        function startSummoningAnimation(time) {
            summoningCircle.animation.active = true;
            summoningCircle.animation.startTime = time;
            summoningCircle.animation.state = 'ring_appearing';
            const center = summoningCircle.group.position;
            const radius = 87 / 2;

            const ringGeo = new THREE.TorusGeometry(radius, 0.8, 16, 100);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, transparent: true, opacity: 0, blending: THREE.AdditiveBlending });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.copy(center).y += 0.1;
            ring.rotation.x = Math.PI / 2;
            summoningCircle.animation.ring = ring;
            scene.add(ring);
        }

        function updateSummoningAnimation(time, delta) {
            if (!summoningCircle.animation.active) return;
            const anim = summoningCircle.animation;
            const elapsed = time - anim.startTime;

            switch(anim.state) {
                case 'ring_appearing':
                    anim.ring.material.opacity = Math.min(1, elapsed / 1000);
                    if (elapsed > 1500) {
                        anim.state = 'hexagram_appearing';
                         const center = summoningCircle.group.position;
                         const size = 87 / 2 * 0.866;
                         
                         const hexagramGroup = new THREE.Group();
                         const shape = new THREE.Shape();
                         const createTriangle = (shape, size, reverse) => {
                            const angleOffset = reverse ? Math.PI : 0;
                            shape.moveTo(size * Math.cos(angleOffset), size * Math.sin(angleOffset));
                            shape.lineTo(size * Math.cos(angleOffset + 2/3 * Math.PI), size * Math.sin(angleOffset + 2/3 * Math.PI));
                            shape.lineTo(size * Math.cos(angleOffset + 4/3 * Math.PI), size * Math.sin(angleOffset + 4/3 * Math.PI));
                            shape.closePath();
                         }
                         createTriangle(shape, size, false);
                         createTriangle(shape, size, true);

                         const hexFillMat = new THREE.MeshBasicMaterial({ color: 0xFFFFE0, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });
                         const hexFill = new THREE.Mesh(new THREE.ShapeGeometry(shape), hexFillMat);
                         
                         const hexOutlineMat = new THREE.LineBasicMaterial({ color: 0xFFD700, transparent: true, opacity: 0, blending: THREE.AdditiveBlending, linewidth: 20 });
                         const points = shape.getPoints();
                         const hexOutline = new THREE.LineLoop(new THREE.BufferGeometry().setFromPoints(points), hexOutlineMat);
                         hexagramGroup.add(hexFill);
                         hexagramGroup.add(hexOutline);
                         
                         hexagramGroup.position.copy(center).y += 0.1;
                         hexagramGroup.rotation.x = -Math.PI / 2;
                         anim.hexagram = hexagramGroup;
                         scene.add(hexagramGroup);
                         
                         const curtainGeo = new THREE.CylinderGeometry(size * 1.05, size * 1.15, 100, 64, 20, true);
                         const curtainMat = new THREE.ShaderMaterial({
                             uniforms: { time: { value: 0 }},
                             vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                             fragmentShader: `
                                uniform float time; varying vec2 vUv;
                                void main() {
                                    float line = pow(sin((vUv.x + time * 0.1) * 30.0) * 0.5 + 0.5, 2.0);
                                    float falloff = pow(1.0 - vUv.y, 2.0);
                                    gl_FragColor = vec4(1.0, 0.84, 0.0, line * falloff * 0.7);
                                }`,
                             transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
                         });
                         const lightCurtain = new THREE.Mesh(curtainGeo, curtainMat);
                         lightCurtain.position.copy(center).y += 50;
                         anim.lightCurtain = lightCurtain;
                         scene.add(lightCurtain);
                    }
                    break;
                case 'hexagram_appearing':
                    const hexOpacity = Math.min(1, (elapsed - 1500) / 1000);
                    anim.hexagram.children[1].material.opacity = hexOpacity;
                    anim.hexagram.children[0].material.opacity = 0;
                    if (elapsed > 3000) {
                        anim.state = 'rotating';
                    }
                    break;
                case 'rotating':
                    const rotationElapsed = elapsed - 3000;
                    let speedMultiplier = 1;
                    if (rotationElapsed < 6000) {
                        speedMultiplier = 1 + (rotationElapsed / 6000) * 9;
                    } else {
                        speedMultiplier = 10;
                    }
                    anim.hexagram.rotation.z += delta * 0.5 * speedMultiplier;
                    summoningCircle.group.rotation.y -= delta * 0.3 * speedMultiplier;
                    
                    if (rotationElapsed > 6000) {
                        const fillElapsed = rotationElapsed - 6000;
                        const fillDuration = 3000;
                        const fillOpacity = Math.min(1, fillElapsed / fillDuration);
                        anim.hexagram.children[0].material.opacity = fillOpacity;
                    }

                    if (rotationElapsed > 9000) {
                        anim.state = 'disappearing';
                    }
                    break;
                case 'disappearing':
                    const disappearElapsed = elapsed - (3000 + 9000);
                    const opacity = 1.0 - Math.min(1, disappearElapsed / 1000);
                    anim.ring.material.opacity = opacity;
                    anim.hexagram.children.forEach(child => child.material.opacity = opacity);
                    if(anim.lightCurtain) anim.lightCurtain.material.opacity = opacity;
                    
                    lissajousFigure.group.traverse(child => { if(child.material) child.material.opacity = opacity; });
                    summoningCircle.group.traverse(child => { if(child.material) child.material.opacity = opacity; });

                    if (opacity <= 0) {
                        if (anim.ring.parent) scene.remove(anim.ring);
                        if (anim.hexagram.parent) scene.remove(anim.hexagram);
                        if (anim.lightCurtain.parent) scene.remove(anim.lightCurtain);
                        if (summoningCircle.group.parent) scene.remove(summoningCircle.group);
                        if (lissajousFigure.group.parent) scene.remove(lissajousFigure.group);
                        spawnSpecificTreasure(new THREE.Vector3(0, 3, 0), 4);
                        anim.active = false;
                        lissajousFigure.active = false;
                        summoningCircle.active = false;
                    }
                    break;
            }
            if (anim.lightCurtain) {
                anim.lightCurtain.material.uniforms.time.value = time * 0.001;
            }
        }
        
        function onTouchStart(event) { 
            if (event.target.closest('#brain-modal-content') || 
                event.target.closest('#info-modal-content') || 
                event.target.closest('#end-door-icon') ||
                event.target.closest('#info-icon') ||
                event.target.closest('#brain-icon') ||
                event.target.closest('#shoot-button') ||  // æ–°å¢ï¼šå°„æ“ŠæŒ‰éˆ•
                event.target.closest('#skill-button')) {    // æ–°å¢ï¼šæŠ€èƒ½æŒ‰éˆ•
                return;
            }

            event.preventDefault(); // é–å®šç•«é¢ (é˜²æ­¢é›™æ“Šæ”¾å¤§æˆ–æ‹‰å‹•ç¶²é )
            
            if (!gameStarted) return; 
            
            const touch = event.changedTouches[0]; 
            
            // åˆ¤æ–·å·¦åŠè¢å¹• (æ–æ¡¿)
            if (touch.clientX < window.innerWidth / 2) { 
                if (!joystick.active) { 
                    joystick.id = touch.identifier; 
                    joystick.active = true; 
                    joystick.startX = touch.clientX; 
                    joystick.startY = touch.clientY; 
                    joystick.base.style.left = `${touch.clientX - 60}px`; 
                    joystick.base.style.top = `${touch.clientY - 60}px`; 
                    joystick.handle.style.left = `${touch.clientX - 30}px`; 
                    joystick.handle.style.top = `${touch.clientY - 30}px`; 
                    joystick.base.style.display = 'block'; 
                    joystick.handle.style.display = 'block'; 
                } 
            } else { 
                // å³åŠè¢å¹• (è¦–è§’)
                if (!look.active) { 
                    look.id = touch.identifier; 
                    look.active = true; 
                    look.lastX = touch.clientX; 
                    look.lastY = touch.clientY; 
                } 
            } 
        }
        
        function onTouchMove(event) { 
            if (event.target.closest('#brain-modal-content') || event.target.closest('#info-modal-content')) {
                return;
            }

            event.preventDefault(); // éŠæˆ²ä¸­é–å®šç•«é¢
            
            if (!gameStarted) return; 
            
            for (let touch of event.changedTouches) { 
                if (touch.identifier === joystick.id) { 
                    const vecX = touch.clientX - joystick.startX, vecY = touch.clientY - joystick.startY; 
                    let dist = Math.hypot(vecX, vecY); 
                    const angle = Math.atan2(vecY, vecX); 
                    if (dist > joystick.maxDist) dist = joystick.maxDist; 
                    direction.x = (Math.cos(angle) * dist) / joystick.maxDist; 
                    direction.z = (Math.sin(angle) * dist) / joystick.maxDist; 
                    joystick.handle.style.left = `${joystick.startX + Math.cos(angle) * dist - 30}px`; 
                    joystick.handle.style.top = `${joystick.startY + Math.sin(angle) * dist - 30}px`; 
                } else if (touch.identifier === look.id) { 
                    if(playerLookDisabled) { look.lastX = touch.clientX; look.lastY = touch.clientY; return; } 
                    const movementX = (touch.clientX - look.lastX) * 0.007, movementY = (touch.clientY - look.lastY) * 0.007; 
                    player.rotation.y -= movementX; 
                    camera.rotation.x -= movementY; 
                    camera.rotation.x = Math.max(-PI_2, Math.min(PI_2, camera.rotation.x)); 
                    look.lastX = touch.clientX; 
                    look.lastY = touch.clientY; 
                } 
            } 
        }

        function onTouchEnd(event) { if (!gameStarted) return; for (let touch of event.changedTouches) { if (touch.identifier === joystick.id) { joystick.id = -1; joystick.active = false; joystick.base.style.display = 'none'; joystick.handle.style.display = 'none'; direction.x = 0; direction.z = 0; } else if (touch.identifier === look.id) { look.id = -1; look.active = false; } } }

function addPCControls() {
    const keyStates = {};
    document.addEventListener('keydown', (event) => {
        keyStates[event.code] = true;
    });
    document.addEventListener('keyup', (event) => {
        keyStates[event.code] = false;
    });

    sceneContainer.addEventListener('mousedown', () => {
        document.body.requestPointerLock();
    });

    document.addEventListener('mousemove', (event) => {
        if (document.pointerLockElement === document.body && !playerLookDisabled) {
            player.rotation.y -= event.movementX * 0.002;
            camera.rotation.x -= event.movementY * 0.002;
            camera.rotation.x = Math.max(-PI_2, Math.min(PI_2, camera.rotation.x));
        }
    });

    const pcUpdateInterval = setInterval(() => {
        if (!gameStarted || joystick.active) return; // å¦‚æœæ‰‹æ©Ÿæ–æ¡¿æ­£åœ¨ä½¿ç”¨ï¼Œå‰‡ä¸åŸ·è¡Œéµç›¤æ“ä½œ

        direction.x = 0;
        direction.z = 0;
        if (keyStates['KeyW']) direction.z = -1;
        if (keyStates['KeyS']) direction.z = 1;
        if (keyStates['KeyA']) direction.x = -1;
        if (keyStates['KeyD']) direction.x = 1;
    }, 16);
}
        
        // [ä¿®æ­£ç‰ˆ] è¢å¹•éœ‡å‹• (æ’é™¤å½±å­ + æ•´åˆå…¨åŸŸéœ‡å‹•)
        function updateScreenShake(playerPos) {
            if (endingState.active && !isHiddenEnding) {
                sceneContainer.style.transform = 'translate(0, 0)';
                return;
            } 
            let closestDist = Infinity; 
            
            // 1. è¨ˆç®—èˆ‡æœ€è¿‘æ£‹å­çš„è·é›¢ (æ’é™¤å…±æ„Ÿäººå½±å­)
            obstacles.forEach(obs => { 
                if (obs.userData.isMovable) { 
                    // [ä¿®æ­£] å¢åŠ åˆ¤æ–·ï¼šå¦‚æœæ˜¯å½±å­ (isShadow)ï¼Œå‰‡å¿½ç•¥ï¼Œä¸ç”¢ç”Ÿéœ‡å‹•
                    if (obs.userData.isShadow) return;

                    const dist = playerPos.distanceTo(obs.position); 
                    if (dist < closestDist) closestDist = dist; 
                } 
            }); 
            
            let shakeX = 0;
            let shakeY = 0;

            // 2. è¨ˆç®—æ£‹å­é è¿‘çš„éœ‡å‹•
            const maxShakeDist = 75; 
            const maxShakeIntensity = 15; 
            
            if (closestDist < maxShakeDist) { 
                const intensity = Math.pow(1 - (closestDist / maxShakeDist), 2) * maxShakeIntensity; 
                shakeX += (Math.random() - 0.5) * intensity;
                shakeY += (Math.random() - 0.5) * intensity;
            }

            // 3. è¨ˆç®—å…¨åŸŸäº‹ä»¶éœ‡å‹• (æŸ±å­å‡é™)
            if (globalShake.active) {
                const now = performance.now();
                const elapsed = now - globalShake.start;
                
                if (elapsed < globalShake.duration) {
                    const progress = elapsed / globalShake.duration;
                    let currentIntensity = 0;

                    if (globalShake.type === 'build-up') {
                        currentIntensity = globalShake.intensity * Math.pow(progress, 2);
                    } else {
                        currentIntensity = globalShake.intensity * (1 - progress);
                    }
                    
                    shakeX += (Math.random() - 0.5) * currentIntensity;
                    shakeY += (Math.random() - 0.5) * currentIntensity;
                } else {
                    globalShake.active = false;
                }
            }

            // 4. å¥—ç”¨ç¸½éœ‡å‹•
            if (Math.abs(shakeX) > 0.1 || Math.abs(shakeY) > 0.1) {
                sceneContainer.style.transform = `translate(${shakeX}px, ${shakeY}px)`; 
            } else { 
                sceneContainer.style.transform = 'translate(0, 0)'; 
            } 
        }
        function updateSanBar() { 
            // é‚è¼¯ï¼šç©å®¶ç•¶å‰è¡€é‡ - å‚²å¬ŒæŠ€èƒ½æš«å­˜çš„å‚·å®³ = ç¶ è‰²æ¢é•·åº¦
            let visualCurrentHP = playerSan;
            if (tsundereManager.storedDamage > 0) {
                visualCurrentHP = Math.max(0, playerSan - tsundereManager.storedDamage);
            }

            // 2. ç¹ªè£½ç¶ è‰²/é»ƒè‰²/ç´…è‰²è¡€æ¢ (Inner)
            const p = Math.max(0, visualCurrentHP) / MAX_SAN; 
            const b = document.getElementById('san-bar-inner'); 
            const pPercent = p * 100; // ç®—å‡ºç¶ è‰²æ¢çš„ç™¾åˆ†æ¯”
            
            b.style.width = `${pPercent}%`; 
            
            if (p > 0.6) b.style.backgroundColor = '#22dd22'; 
            else if (p > 0.3) b.style.backgroundColor = '#dddd22'; 
            else b.style.backgroundColor = '#dd2222'; 

            // 3. ç¹ªè£½å‚²å¬Œæš—ç´…è‰²å¹»å½±è¡€æ¢ (Phantom)
            const phantom = document.getElementById('san-bar-phantom');
            if (phantom) {
                if (tsundereManager.storedDamage > 0) {
                    phantom.style.left = `${pPercent}%`;

                    let phantomWidth = (tsundereManager.storedDamage / MAX_SAN) * 100;
                    
                    if (pPercent + phantomWidth > 100) {
                        phantomWidth = 100 - pPercent;
                    }

                    phantom.style.width = `${phantomWidth}%`;
                } else {
                    phantom.style.width = '0%';
                }
            }
        }
        
        // [ä¿®æ­£] å—å‚·é‚è¼¯
        function takeDamage(amount, isInstant = false) { 
            if (gameOver || !gameStarted) return; 
            
            // [æ–°å¢] å‚²å¬ŒæŠ€èƒ½é‚è¼¯
            if (tsundereManager.active) {
                // æŠ€èƒ½ç™¼å‹•ä¸­ï¼šåªç´€éŒ„å‚·å®³ï¼Œä¸æ‰£è¡€
                tsundereManager.storedDamage += amount;
                updateSanBar(); // æ›´æ–°è¡€æ¢é¡¯ç¤º (é¡¯ç¤ºæš—ç´…è‰²éƒ¨åˆ†)
                
                // è§¸ç™¼ç²‰è‰²é–ƒçˆ
                sanBarUI.classList.remove('damage-flash-short', 'damage-flash-long', 'damage-flash-pink'); 
                void sanBarUI.offsetWidth; 
                sanBarUI.classList.add('damage-flash-pink');
                return; // ç›´æ¥è¿”å›ï¼Œä¸åŸ·è¡Œå¾Œé¢æ‰£è¡€
            }

            // [æ–°å¢] å‚²å¬ŒæŠ€èƒ½å¼•çˆ†æª¢æŸ¥
            // å¦‚æœæŠ€èƒ½å·²çµæŸ(primed)ï¼Œä¸”é€™æ¬¡å—å‚·äº† -> å…ˆæ‰£é€™æ¬¡çš„è¡€ï¼Œå†å¼•çˆ†ä¹‹å‰çš„å‚·å®³
            let explosionDamage = 0;
            if (tsundereManager.isPrimed) {
                explosionDamage = tsundereManager.triggerExplosion();
            }

            let finalDamage = amount + explosionDamage;

            playerSan -= finalDamage; 
            updateSanBar(); 
            
            // è§¸ç™¼ç´…å…‰èˆ‡å¼•çˆ†æª¢æŸ¥
            if (erosionSystem.projectionStacks > 0) {
                triggerProjectionExplosion();
            } else {
                triggerDamageFlash(isInstant || explosionDamage > 0); 
            }

            if (playerSan <= 0) {
                playerSan = 0; // æ­¸é›¶é˜²æ­¢è² æ•¸
                handlePlayerDefeat(); 
            }
        }

        // [æ–°å¢] å¼•çˆ†æŠ•å°„é‚è¼¯
        function triggerProjectionExplosion() {
            if (erosionSystem.projectionStacks <= 0) return;

            const stacks = erosionSystem.projectionStacks;
            const damage = stacks * 1.5; // æ¯å±¤æ‰£ 1.5 ç†æ™º 

            // æ¸…é™¤å±¤æ•¸èˆ‡ç‹€æ…‹
            erosionSystem.projectionStacks = 0;
            statusEffectManager.removeStatus('projection');

            playerSan -= damage;
            updateSanBar();
            if (playerSan <= 0) handlePlayerDefeat();

            // åŸ·è¡Œç‰¹æ•ˆ
            triggerGlitchRipple();
            
            // [ä¿®æ­£] ç´…è‰²é–ƒçˆæŒçºŒ 1.5 ç§’
            sanBarUI.classList.remove('damage-flash-short', 'damage-flash-long', 'heal-flash'); 
            void sanBarUI.offsetWidth; 
            sanBarUI.classList.add('damage-flash-long'); // CSS ä¸­ long æ˜¯ 0.8sï¼Œæˆ‘å€‘éœ€è¦æ›´é•·çš„
            
            sanBarUI.style.animationDuration = '1.5s';
            // 1.5ç§’å¾Œé‚„åŸ
            setTimeout(() => { sanBarUI.style.animationDuration = ''; }, 1500);
        }

        // [æ–°å¢] æ¢å¾©ç†æ™ºå€¼å‡½å¼
        function healPlayer(amount) {
            if (gameOver) return;
            playerSan = Math.min(playerSan + amount, MAX_SAN); // ä¸èƒ½è¶…éä¸Šé™
            updateSanBar();
            triggerHealFlash();
        }

        // [æ–°å¢] ç¶ è‰²é–ƒçˆç‰¹æ•ˆ
        function triggerHealFlash() {
            const ui = document.getElementById('san-bar-container');
            ui.classList.remove('damage-flash-short', 'damage-flash-long', 'heal-flash', 'damage-flash-pink');
            
            void ui.offsetWidth; // å¼·åˆ¶é‡ç¹ª
            
            ui.classList.add('heal-flash');
        }

        // [ä¿®æ­£] å¼•çˆ†æŠ•å°„çš„æ•…éšœæ¼£æ¼ªç‰¹æ•ˆ
        function triggerGlitchRipple() {
            if (!glitchCanvas) return;
            glitchCanvas.style.display = 'block';
            const startTime = performance.now();
            const duration = 450; 

            function animateGlitch() {
                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(elapsed / duration, 1);

                glitchCtx.clearRect(0, 0, glitchCanvas.width, glitchCanvas.height);

                if (progress >= 1) {
                    glitchCanvas.style.display = 'none';
                    return;
                }

                const w = glitchCanvas.width;
                const h = glitchCanvas.height;
                const cx = w / 2;
                const cy = h / 2;

                // èƒŒæ™¯é–ƒçˆ
                const bgAlpha = Math.max(0, 0.8 - progress * 2.0); 
                glitchCtx.fillStyle = `rgba(10, 5, 20, ${bgAlpha})`;
                glitchCtx.fillRect(0, 0, w, h);

                const maxRadius = Math.max(w, h) * 0.9;
                const waveCount = 15; 
                // ä½é£½å’Œç°æš—è‰²èª¿
                const colors = ['rgba(150, 80, 80, ', 'rgba(80, 130, 110, ', 'rgba(90, 100, 140, '];

                for (let i = 0; i < waveCount; i++) {
                    const waveProgress = (progress * 1.5 - i * 0.04); 
                    if (waveProgress < 0 || waveProgress > 1) continue;

                    const r = waveProgress * maxRadius;
                    const alpha = 1.0 - waveProgress; 
                    const colorBase = colors[i % 3];
                    const baseWidth = 4 + Math.random() * 4;
                    
                    drawJitterOval(cx, cy, r, progress, colorBase + (alpha * 0.2) + ')', baseWidth + 12);
                    drawJitterOval(cx, cy, r, progress, colorBase + (alpha * 0.3) + ')', baseWidth + 6);
                    drawJitterOval(cx, cy, r, progress, colorBase + (alpha * 0.5) + ')', baseWidth);
                }

                requestAnimationFrame(animateGlitch);
            }
            
            // è¼”åŠ©ç¹ªåœ–å‡½å¼
            function drawJitterOval(cx, cy, r, progress, colorStyle, lineWidth) {
                glitchCtx.strokeStyle = colorStyle;
                glitchCtx.lineWidth = lineWidth;
                glitchCtx.beginPath();
                const segments = 40; // é™ä½æ®µæ•¸æå‡æ•ˆèƒ½
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    const jitter = (Math.random() - 0.5) * 30 * (1 - progress); 
                    const x = cx + Math.cos(angle) * (r + jitter);
                    const y = cy + Math.sin(angle) * (r * 0.8 + jitter); 
                    if (j === 0) glitchCtx.moveTo(x, y);
                    else glitchCtx.lineTo(x, y);
                }
                glitchCtx.closePath();
                glitchCtx.stroke();
            }

            animateGlitch();
        }

        function triggerDamageFlash(isLong) { 
            sanBarUI.classList.remove('damage-flash-short', 'damage-flash-long', 'damage-flash-pink', 'heal-flash'); 
            void sanBarUI.offsetWidth; 
            sanBarUI.classList.add(isLong ? 'damage-flash-long' : 'damage-flash-short'); 
        }
        
        function handlePlayerDefeat() { 
            if(gameOver) return; 

            statusEffectManager.clearAll();
            // [æ–°å¢] æš´åŠ›æ­¸é›¶é™°é™½æ•¸å€¼ï¼Œé˜²æ­¢åœ–ç¤ºæ­»ç°å¾©ç‡ƒ
            if (typeof magicCircle !== 'undefined') {
                magicCircle.yinEnergy = 0;
                magicCircle.yangEnergy = 0;
            }
            // é›™é‡ä¿éšªï¼šå†æ¬¡å¼·åˆ¶ç§»é™¤é€™å…©å€‹ç‰¹å®š ID
            statusEffectManager.removeStatus('yin');
            statusEffectManager.removeStatus('yang');
            forceHideSkillUI();

            // [æ–°å¢] æ­»äº¡æ™‚å¼·åˆ¶ç§»é™¤ SVG æ¿¾é¡
            const sc = document.getElementById('scene-container');
            if (sc) sc.style.filter = 'none';
            
            // æ­¸é›¶ SVG åç§»é‡
            const sr = document.getElementById('svg-offset-red');
            const sb = document.getElementById('svg-offset-blue');
            if(sr) sr.setAttribute('dx', 0);
            if(sb) sb.setAttribute('dx', 0);

            // [æ–°å¢] æ­»äº¡æ™‚æ¸…é™¤å™ªé»
            const noise = document.getElementById('noise-overlay');
            if(noise) {
                noise.style.display = 'none';
                noise.style.opacity = '0';
            }

            if(camera) {
                camera.fov = 75; // å¼·åˆ¶é‚„åŸè¦–é‡è§’åº¦
                camera.updateProjectionMatrix();
            }

            const r = document.getElementById('chromatic-red');
            const b = document.getElementById('chromatic-blue');
            if(r) { r.style.display = 'none'; r.style.opacity = '0'; }
            if(b) { b.style.display = 'none'; b.style.opacity = '0'; }
            
            // 1. å¼·åˆ¶éš±è—æ‰€æœ‰éŠæˆ² UI
            if(bossHpContainer) bossHpContainer.classList.remove('visible');
            showShootButton(false); 
            
            // [ä¿®æ­£] è¼¸æ‰æ™‚ï¼Œç«‹åˆ»éš±è—ä¸€éµé€šé—œæŒ‰éˆ•
            const debugBtn = document.getElementById('debug-win-btn');
            if (debugBtn) debugBtn.style.display = 'none';
            // [æ–°å¢] è¼¸æ‰æ™‚ï¼Œç«‹åˆ»éš±è—æš´é›·éš±è—çµå±€æŒ‰éˆ•
            const hiddenDebugBtn = document.getElementById('debug-hidden-win-btn');
            if (hiddenDebugBtn) hiddenDebugBtn.style.display = 'none';
            
            // 2. éš±è—æ··æ²Œå…‰åœ˜ UI
            if (chaosHpContainer) {
                chaosHpContainer.classList.remove('visible');
                chaosHpContainer.style.opacity = '0'; 
            }
            
            // 3. [ä¿®æ­£] å¼·åˆ¶æ¸…ç©ºç‹€æ…‹åœ–ç¤º (åŒ…å«å¤±è¡¡ã€ç‹©çµå°è¨˜ç­‰)
            const statusContainer = document.getElementById('status-effect-container');
            if (statusContainer) statusContainer.innerHTML = ''; 
            
            weatherManager.reset();

            // 4. [ä¿®æ­£] éš±è—å¤§é–€æ–‡å­—
            const tcText = document.getElementById('treasure-counter-text');
            if (tcText) {
                tcText.style.display = 'none';
                tcText.textContent = '';
                tcText.style.opacity = '0';
            }

            // 5. éš±è—æ”¶é›†æ¢èˆ‡ç‰¹æ•ˆ
            if (collectionUI.container) collectionUI.container.style.display = 'none';
            if (vignetteCanvas) {
                vignetteCanvas.style.display = 'none';
                vignetteCtx.clearRect(0, 0, vignetteCanvas.width, vignetteCanvas.height);
            }
            if (document.getElementById('trauma-vignette-canvas')) {
                document.getElementById('trauma-vignette-canvas').style.display = 'none';
            }
            if (glitchCanvas) {
                glitchCanvas.style.display = 'none';
            }

            gameOver = true; 
            gameStarted = false; 
            
            // éš±è—å¸¸é§ UI
            treasureCanvas.style.display = 'none'; 
            sanBarUI.style.display = 'none'; 
            
            // æ’­æ”¾æ­»äº¡å‹•ç•«
            gameOverAnimation.active = true; 
            gameOverAnimation.start = performance.now(); 
            camera.getWorldPosition(gameOverAnimation.initialCamPos); 
            camera.getWorldQuaternion(gameOverAnimation.initialCamQuat); 
            scene.add(camera); 
            player.remove(camera); 
        }

        // [æ¥µè‡´ç©©å®šç‰ˆ] å•Ÿå‹•çµå±€æµç¨‹ (åªéš±è—ç‰©ä»¶ï¼Œçµ•ä¸åŸ·è¡Œé‡åº¦æ¸…ç†ï¼Œé˜²æ­¢å¡æ­»)
        function startEndingSequence() {
            console.log("çµå±€æµç¨‹å•Ÿå‹• - å„ªåŒ–ç‰ˆ");

            if (typeof hasChaosOrbBeenAbsorbed !== 'undefined' && hasChaosOrbBeenAbsorbed) {
                isHiddenEnding = true;
            } else {
                isHiddenEnding = false;
            }
        
            // 1. åˆ‡æ–·æ“ä½œèˆ‡é‚è¼¯
            gameStarted = false; 
            isBeingPushed = false;
            pushingPiece = null;
            velocity.set(0, 0, 0);   
            direction.set(0, 0, 0);
            if (player) player.userData.isTraumaActive = false; 

            // 2. éš±è—æ‰€æœ‰éŠæˆ² UI
            const uiToHide = [
                sanBarUI, 
                document.getElementById('treasure-counter-text'), 
                bossHpContainer, 
                chaosHpContainer,
                collectionUI.container, 
                treasureCanvas,
                joystick.base, 
                joystick.handle,
                vignetteCanvas,
                glitchCanvas,
                document.getElementById('trauma-vignette-canvas'),
                document.getElementById('shoot-button'),
                document.getElementById('skill-button'),
                document.getElementById('debug-win-btn'),
                document.getElementById('debug-hidden-win-btn')
            ];
            uiToHide.forEach(el => { if(el) el.style.display = 'none'; });
            forceHideSkillUI(); 
        
            // 3. å‡çµæ‰€æœ‰ç®¡ç†å™¨
            fallingPiecesManager.isActive = false;
            smileyBallManager.isActive = false;
            lightningManager.isActive = false;
            birdManager.isActive = false;
            duckManager.isActive = false;
            bossManager.active = false;
            chaosOrb.active = false;
            chaosOrb.state = 'idle';
            summoningCircle.active = false;
            lissajousFigure.active = false;
            weatherManager.reset();
            statusEffectManager.clearAll();

            // 4. ã€é¡¯ç¤ºç™½å±ã€‘
            endingState.active = true;
            endingState.stage = 1;
        
            if (endingOverlay) {
                endingOverlay.style.transition = 'none';
                endingOverlay.style.opacity = '0';
                endingOverlay.style.display = 'block';
                endingOverlay.style.zIndex = '9999'; 
                void endingOverlay.offsetWidth; // å¼·åˆ¶æ¸²æŸ“
                endingOverlay.style.transition = 'opacity 1.5s ease-out';
                endingOverlay.style.opacity = '1';
            }

            const loadingText = document.getElementById('cleanup-loading-text');
            if (loadingText) loadingText.style.display = 'none'; 
        
            // 5. ã€è¼•é‡åŒ–éš±è—èˆ‡åˆ†æµæ¸…ç†ã€‘
            // åœ¨ç™½å±è®Šç™½å¾Œ (1.5ç§’å¾Œ)ï¼Œé–‹å§‹å°‡ç‰©ä»¶åŠ å…¥æ¸…ç†æ’ç¨‹ï¼Œåˆ©ç”¨å‰©ä¸‹çš„ 4.5 ç§’æ¸…ç†
            setTimeout(() => {
                // å¦‚æœæ˜¯éš±è—çµå±€ï¼Œæˆ‘å€‘è¦ä¿ç•™å ´æ™¯é€²å…¥ Stage 3ï¼Œæ‰€ä»¥åªåšéš±è—ä¸æ¸…ç†
                if (isHiddenEnding) {
                     // 1. éš±è—ä¸€èˆ¬éšœç¤™ç‰© (æŸ±å­èˆ‡æ¨“æ¢¯é™¤å¤–)
                     obstacles.forEach(o => {
                         if (!o) return;
                         if (moyingManager && (o === moyingManager.yanGroup || o === moyingManager.moyingSprite)) return;
                         
                         // [é—œéµ] éš±è—çµå±€ä¸‹ï¼Œåªéš±è—éäº’å‹•æ€§ç‰©ä»¶
                         if (!o.userData.isColumn && !o.userData.isMovable && !o.userData.isBackgroundStairs) {
                             o.visible = false;
                         }
                     });
                     
                     treasures.forEach(t => { if(t) t.visible = false; });
                     if(bossManager.mesh) bossManager.mesh.visible = false;
                     if(chaosOrb.mesh) chaosOrb.mesh.visible = false;
                     if(exit_portal) exit_portal.visible = false;
                     if(summoningCircle.group) summoningCircle.group.visible = false;
                     if(lissajousFigure.group) lissajousFigure.group.visible = false;
                     shieldCageManager.cages.forEach(c => { if(c.mesh) c.mesh.visible = false; });
                     
                } else {
                    // [æ­£å¸¸çµå±€] å•Ÿå‹•åˆ†æµæ¸…ç†ï¼ä¿ç•™ç’°å¢ƒç‰©ä»¶(åœ°æ¿/é­˜/æ¥µå…‰)
                    queueSceneForCleanup(true); 
                }
            
            }, 1600);
        
            // 6. ã€é€²å…¥åœ–ç‰‡éšæ®µã€‘(çµ•å°è¨ˆæ™‚ï¼Œ6ç§’å¾ŒåŸ·è¡Œ)
            setTimeout(() => {
                // [é—œéµ] åœ¨é¡¯ç¤ºåœ–ç‰‡å‰ï¼Œæš«åœæ¸…ç†ï¼Œé¿å… CPU é£†å‡å°è‡´åœ–ç‰‡è·‘ä¸å‡ºä¾†
                pauseGradualCleanup();

                // éš±è—ç™½å±
                if (endingOverlay) endingOverlay.style.display = 'none'; 
            
                // é€²å…¥åœ–ç‰‡éšæ®µ (Stage 2)
                endingState.stage = 2;

                if (endingContainer) {
                    endingContainer.removeEventListener('pointerup', handleEndingClick);

                    endingContainer.style.display = 'flex';
                    endingContainer.style.zIndex = '10000'; // ç¢ºä¿æœ€ä¸Šå±¤
                    endingContainer.style.opacity = '1'; 

                    if (imgA) {
                        imgA.style.display = 'block';
                        imgA.style.opacity = '0';
                        void imgA.offsetWidth; 
                        imgA.style.transition = 'opacity 1s ease-in-out';
                        imgA.style.opacity = '1';
                    }
                
                    setTimeout(() => {
                        endingContainer.addEventListener('pointerup', handleEndingClick);
                    }, 500);
                }
            
            }, 6000); // ç¢ºå¯¦æ˜¯ 6 ç§’
        }

        // [ä¿®æ­£] è™•ç†çµå±€é»æ“Š
        function handleEndingClick(e) {
            e.stopPropagation();

            if (endingState.stage === 2) {
                endingState.stage = 3;
                
                imgA.style.transition = 'opacity 2s ease-in-out';
                imgA.style.opacity = '0';

                setGameTimeout(() => {
                    enterPostGameWorld(); 
                    
                    endingContainer.style.transition = 'opacity 2s ease-in-out';
                    endingContainer.style.opacity = '0';
                    
                    if (endingOverlay) {
                        endingOverlay.style.transition = 'opacity 2s ease-in-out';
                        endingOverlay.style.opacity = '0';
                    }

                    setGameTimeout(() => {
                        endingContainer.style.display = 'none';
                        endingContainer.style.opacity = '1';
                        
                        if (endingOverlay) {
                            endingOverlay.style.display = 'none';
                        }

                        endingState.postGameStartTime = performance.now();
                    }, 2000);

                }, 2000); 
            }
            else if (endingState.stage === 4) {
                endingState.stage = 5;
                void imgC.offsetWidth; 
                imgC.style.transition = 'opacity 1.5s ease-in-out'; 
                imgC.style.opacity = '1'; 
            }
            else if (endingState.stage === 5) {
                endingContainer.removeEventListener('pointerup', handleEndingClick);
                
                imgB.style.transition = 'opacity 1.5s ease-in-out';
                imgB.style.opacity = '0';
                imgC.style.transition = 'opacity 1.5s ease-in-out';
                imgC.style.opacity = '0';
                
                setGameTimeout(() => {
                    returnToStartScreen();

                    endingContainer.style.transition = 'opacity 1.5s ease-in-out';
                    endingContainer.style.opacity = '0';
                    
                    if (endingOverlay) {
                        endingOverlay.style.transition = 'opacity 1.5s ease-in-out';
                        endingOverlay.style.opacity = '0';
                    }
                    
                    setGameTimeout(() => {
                        endingContainer.style.display = 'none';
                        endingContainer.style.opacity = '1';
                        if (endingOverlay) endingOverlay.style.display = 'none';
                        imgB.style.opacity = '0';
                        imgC.style.opacity = '0';
                    }, 1500);

                }, 1500);
            }
        }

        // [ä¿®æ­£ç‰ˆ] çµå±€å¾ŒåŠæ®µ (ç¢ºä¿åœ–ç‰‡ B/C çµ•å°é¡¯ç¤º)
        function startEndingPhase2() {
            console.log("é€²å…¥çµå±€ Phase 2");
        
            if (moyingManager) {
                if (moyingManager.yanGroup) { scene.remove(moyingManager.yanGroup); moyingManager.yanGroup = null; }
                if (moyingManager.moyingSprite) { scene.remove(moyingManager.moyingSprite); moyingManager.moyingSprite = null; }
                moyingManager.active = false;
            }
        
            // 1. è¨­å®šç™½å± (ç•¶èƒŒæ™¯)
            const endingOverlay = document.getElementById('ending-overlay');
            endingOverlay.style.display = 'block';
            endingOverlay.style.zIndex = '10000'; // ç¢ºä¿å¾ˆé«˜ï¼Œä½†æ¯”åœ–ç‰‡ä½
            endingOverlay.style.opacity = '0';    // [ä¿®æ­£] å…ˆè¨­ç‚ºé€æ˜
            
            void endingOverlay.offsetWidth;       // [ä¿®æ­£] å¼·åˆ¶è®€å–ï¼Œè§¸ç™¼å‹•ç•«
            endingOverlay.style.transition = 'opacity 1.5s ease-in-out'; // [ä¿®æ­£] è¨­å®š 1.5 ç§’å‹•ç•«
            endingOverlay.style.opacity = '1';    // [ä¿®æ­£] é–‹å§‹è®Šç™½

            // 2. åœæ­¢æ“ä½œ
            joystick.base.style.display = 'none';
            joystick.handle.style.display = 'none';
            velocity.set(0,0,0);
            direction.set(0,0,0);
            gameStarted = false; // é€™è£¡è¦é–æ“ä½œ
        
            setTimeout(() => {
                endingState.stage = 4;

                // 3. è¨­å®šåœ–ç‰‡å®¹å™¨ (æœ€é‡è¦çš„ä¸€æ­¥)
                endingContainer.style.display = 'flex';
                endingContainer.style.zIndex = '10001'; // ã€é—œéµã€‘å¿…é ˆæ¯” overlay (10000) é«˜
                endingContainer.style.opacity = '1';
                endingContainer.style.pointerEvents = 'auto';

                // 4. é‡ç½®åœ–ç‰‡ç‹€æ…‹
                imgA.style.display = 'none'; 

                imgB.style.display = 'block'; // ç¢ºä¿é¡¯ç¤º
                imgB.style.opacity = '0';     // å…ˆé€æ˜

                imgC.style.display = 'block'; // ç¢ºä¿é¡¯ç¤º
                imgC.style.opacity = '0';     // å…ˆé€æ˜

                // å¼·åˆ¶ Reflow è®“ç€è¦½å™¨çŸ¥é“ç‹€æ…‹è®Šäº†
                void endingContainer.offsetWidth;
                void imgB.offsetWidth;

                // 5. æ·¡å…¥åœ–ç‰‡ B
                imgB.style.transition = 'opacity 1s ease-in-out';
                imgB.style.opacity = '1'; 

                // 6. ç™½å±æ·¡å‡º (é€™ä¸€æ­¥å…¶å¯¦å¯æœ‰å¯ç„¡ï¼Œå› ç‚ºåœ–ç‰‡è“‹åœ¨ä¸Šé¢ï¼Œä½†ç‚ºäº†ä¿éšªé‚„æ˜¯æ·¡å‡º)
                endingOverlay.style.transition = 'opacity 2s ease-in-out';
                endingOverlay.style.opacity = '0';
                setTimeout(() => {
                   endingOverlay.style.display = 'none';
                }, 2000);

                // 7. é‡æ–°ç¶å®šé»æ“Šäº‹ä»¶
                endingContainer.removeEventListener('pointerup', handleEndingClick);
                endingContainer.addEventListener('pointerup', handleEndingClick);

            }, 3000); // 3ç§’å¾Œé¡¯ç¤ºåœ–ç‰‡
        }

        // [ä¿®æ­£] é€²å…¥ç©ºåœ°åœ–æ¨¡å¼ (æ­£å¸¸) æˆ– BOSS è¦–è§’æ¨¡å¼ (éš±è—)
        function enterPostGameWorld() {
            // 0. å†æ¬¡ç¢ºä¿æŠ€èƒ½ UI éš±è— (è§£æ±ºé–ƒçˆå•é¡Œ)
            forceHideSkillUI();
            const skillBtn = document.getElementById('skill-button');
            if (skillBtn) skillBtn.style.display = 'none';

            // 1. ã€æ ¸å¿ƒä¿®æ­£ã€‘å¼·åˆ¶è¨­å®šå¤©ç©ºç‚ºäº®ç™½è‰²ï¼Œè§£æ±ºå¤œæ™šé€²å…¥è®Šé»‘çš„å•é¡Œ
            const skyColor = new THREE.Color(0xf6f9fa);
            const fogColor = new THREE.Color(0xf4f6f7);
            
            scene.background = skyColor;
            scene.fog.color = fogColor; // ç¢ºä¿éœ§æ°£ä¹Ÿæ˜¯ç™½çš„
            
            // å¼·åˆ¶é‡ç½®ç’°å¢ƒå…‰ï¼Œé¿å…æ™šä¸Šçš„æš—å…‰æ®˜ç•™
            ambientLight.intensity = 0.9;
            directionalLight.intensity = 0.5;
            ambientLight.color.setHex(0xADC8D6); // å›å¾©æˆç™½å¤©çš„è‰²èª¿
            directionalLight.color.setHex(0xffffff);
            skyCycleState = 'frozen_day';

            // 2. æ ¹æ“šçµå±€é¡å‹è™•ç†å ´æ™¯
            // [æ¥µè‡´ä¿®æ­£] ç§»é™¤ setTimeout å»¶é²ï¼Œç›´æ¥åŸ·è¡Œï¼Œé¿å…ç•«é¢ç©¿å¹«
            if (isHiddenEnding) {
                gameStarted = true;

                // 1. é‡ç½®æ‰€æœ‰æŠ€èƒ½é‚è¼¯ (æ¸…é™¤å¤§Iäººã€å‚²å¬Œã€å¤¢æƒ³å®¶ç‰†å£ã€å…±æ„Ÿäººå½±å­ç­‰ç‰¹æ•ˆ)
                resetAllSkills(); 

                const skillBtn = document.getElementById('skill-button');
                if (skillBtn) skillBtn.style.display = 'none';

                // 2. å¼·åˆ¶å•Ÿå‹•é´¨å­ï¼Œè®“ç‰ å€‘æœƒå‹•ï¼
                duckManager.isActive = true; 

                // 3. æ¸…é™¤ã€Œæ­£åœ¨æ‰è½ä¸­ã€çš„æŠ€èƒ½æ£‹å­ (ç©ºä¸­åƒåœ¾æ¸…é™¤)
                if (window.skillFalls) {
                    window.skillFalls.forEach(f => {
                        if(f.piece && f.piece.parent) scene.remove(f.piece);
                        if(f.shadow && f.shadow.parent) scene.remove(f.shadow);
                    });
                    window.skillFalls = [];
                }

                // [ç·Šæ€¥è£œå›] é€²å…¥éš±è—çµå±€æ™‚ï¼Œè¨ˆç®—å ´ä¸Šå¯æ¨å€’çš„ç‰©ä»¶ç¸½æ•¸
                totalToppleableCount = 0;
                toppledObjectsCount = 0;
                
                // 1. è¨ˆç®—æŸ±å­èˆ‡æ£‹å­
                obstacles.forEach(obs => {
                    // æ’é™¤å½±å­ã€æ¨“æ¢¯ã€èˆ‡ä¸å¯ç§»å‹•çš„ç‰©ä»¶(å¦‚æœæ˜¯æ£‹å­æˆ–æŸ±å­ç®—å…¥)
                    if (obs.userData.isColumn || (obs.userData.isMovable && !obs.userData.isShadow)) {
                        totalToppleableCount++;
                        // é‡ç½®å€’å¡Œç‹€æ…‹ï¼Œç¢ºä¿æ˜¯ç›´ç«‹çš„
                        obs.userData.isToppled = false;
                        obs.userData.isToppling = false;
                    }
                });

                // 2. è¨ˆç®—é´¨å­
                if (duckManager && duckManager.ducks) {
                    totalToppleableCount += duckManager.ducks.length;
                    // é‡ç½®é´¨å­ç‹€æ…‹
                    duckManager.ducks.forEach(d => {
                         d.hp = 1; // ç¢ºä¿æœ‰è¡€
                         d.state = 'visible'; // ç¢ºä¿å¯è¦‹
                    });
                }
                console.log("éš±è—çµå±€é–‹å§‹ï¼Œç¸½ç›®æ¨™æ•¸:", totalToppleableCount);

                // === éš±è—çµå±€è¨­å®š ===
                // A. æ‹‰é«˜æ”å½±æ©Ÿ (BOSS è¦–è§’ 72ç±³) - ç¬é–“åŸ·è¡Œ
                player.position.set(0, 0, 150); 
                player.rotation.set(0, 0, 0);
                camera.position.set(0, 72, 0); 
                camera.rotation.set(0, 0, 0);
                
                // B. ç©å®¶èº«ä¸Šçš„å…­é‚Šå½¢è­·ç›¾ (å„ªåŒ–ç‰ˆï¼šä½¿ç”¨ç·©å­˜è²¼åœ–)
                if (!cachedShieldTexture) {
                    cachedShieldTexture = createBrokenHexShieldTexture();
                    cachedShieldTexture.wrapS = THREE.RepeatWrapping;
                    cachedShieldTexture.wrapT = THREE.RepeatWrapping;
                    cachedShieldTexture.repeat.set(5, 1);
                }
                
                const shieldGeo = new THREE.SphereGeometry(6, 32, 32); 
                const shieldMat = new THREE.MeshBasicMaterial({
                    map: cachedShieldTexture, // ä½¿ç”¨ç·©å­˜
                    color: 0xFFD700,
                    transparent: true,
                    opacity: 0.6, 
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                playerBossShield = new THREE.Mesh(shieldGeo, shieldMat);
                playerBossShield.position.set(0, 72, 0); 
                player.add(playerBossShield);
                
                // [é—œéµå„ªåŒ–] å»ºç«‹ VIP é‹ç®—åå–® (åªæŠŠçœŸæ­£éœ€è¦ç‰©ç†é‹ç®—çš„æ±è¥¿æŠ“å‡ºä¾†)
                bossLevelTargets = [];
                obstacles.forEach(obs => {
                    // åªåŠ å…¥ï¼šæŸ±å­ã€å¯ç§»å‹•çš„æ£‹å­(æ’é™¤å½±å­)
                    if (obs.userData.isColumn || (obs.userData.isMovable && !obs.userData.isShadow)) {
                         bossLevelTargets.push(obs);
                    }
                });
                // æŠŠé´¨å­ä¹ŸåŠ é€²å»
                if (duckManager && duckManager.ducks) {
                    duckManager.ducks.forEach(d => {
                    });
                }

                initBubblePool();

                // C. é¡¯ç¤º ğŸ’¦ å°„æ“ŠæŒ‰éˆ•
                const bubbleBtn = document.getElementById('bubble-shoot-button');
                if (bubbleBtn) bubbleBtn.style.display = 'flex';

                // D. ç¢ºä¿èƒŒæ™¯éšæ¢¯é‚„åœ¨
                let hasStairs = false;
                scene.traverse(child => { if (child.userData.isBackgroundStairs) hasStairs = true; });
                if (!hasStairs) createSkyStairs();

                // E. é‡ç½®åœ°æ¿ç´‹ç†
                if (floor && floor.material && floor.material.map) {
                    floor.material.map.repeat.set(25, 25);
                }
                
                if(moyingManager) { 
                    moyingManager.active = true;
                    if (moyingManager.yanGroup) {
                        moyingManager.yanGroup.visible = true; // ç¢ºä¿æœ¬é«”å¯è¦‹
                        moyingManager.yanGroup.children.forEach(child => {
                            if (child.isPoints || child.isSprite) {
                                child.visible = false;
                            }
                        });
                    }
                }

            } else {
                // === æ­£å¸¸çµå±€è¨­å®š (ç©ºä¸–ç•Œ) ===
                gameStarted = true; 
                playerLookDisabled = false; // è§£é–è¦–è§’
                joystick.active = false; 
                joystick.id = -1;
                let hasStairs = false;
                scene.traverse(child => { if (child.userData.isBackgroundStairs) hasStairs = true; });
                
                clearScene(true); // æ¸…é™¤å…¶ä»–åƒåœ¾
                
                if (floor) floor.visible = true;
                if (skydome) skydome.visible = true; // æ¥µå…‰å›ä¾†
                if (moyingManager) {
                    moyingManager.active = true;
                    if (moyingManager.yanGroup) moyingManager.yanGroup.visible = true; // é­˜å›ä¾†
                    if (moyingManager.moyingSprite) moyingManager.moyingSprite.visible = true; // æ­¿å½±å›ä¾†
                }

                if (!hasStairs) createSkyStairs();
                
                if (floor && floor.material && floor.material.map) {
                    floor.material.map.repeat.set(25, 25);
                }
            }

            // ç¢ºä¿ä»‹é¢éš±è— (ç„¡è«–ä½•ç¨®çµå±€)
            if (vignetteCanvas) vignetteCanvas.style.display = 'none';
            if (glitchCanvas) glitchCanvas.style.display = 'none';
            const traumaCanvas = document.getElementById('trauma-vignette-canvas');
            if (traumaCanvas) traumaCanvas.style.display = 'none';
            
            const shootBtn = document.getElementById('shoot-button');
            if (shootBtn) shootBtn.style.display = 'none';


            // 3. é¡¯ç¤ºé–€åœ–ç¤º (çµæŸäº’å‹•ç”¨)
            const endIcon = document.getElementById('end-door-icon');
            if (endIcon) {
                endIcon.style.display = 'block';
                const newIcon = endIcon.cloneNode(true);
                endIcon.parentNode.replaceChild(newIcon, endIcon);
                
                newIcon.addEventListener('pointerup', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    
                    if (isHiddenEnding) {
                        // éš±è—çµå±€é›¢å ´åˆ¤æ–·
                        checkHiddenEndingExit(newIcon);
                    } else {
                        // æ­£å¸¸çµå±€æµç¨‹
                        startEndingPhase2(); 
                        newIcon.style.display = 'none';
                    }
                });
            }
            
            if (typeof endingOverlay !== 'undefined' && endingOverlay) {
                endingOverlay.style.display = 'none';
            }
        }

        // [æ¥µè‡´ç©©å®šç‰ˆ] éš±è—çµå±€é›¢å ´ (è§£æ±ºç™½å±è·³è½‰å¡é “)
        function checkHiddenEndingExit(iconElement) {
            // 1. ç«‹å³éš±è—æ“ä½œ UI
            const skillBtn = document.getElementById('skill-button');
            if (skillBtn) skillBtn.style.display = 'none';
            const bubbleBtn = document.getElementById('bubble-shoot-button');
            if (bubbleBtn) bubbleBtn.style.display = 'none';
            iconElement.style.display = 'none';

            // 2. åœæ­¢éŠæˆ²é‚è¼¯ (ä½†ä¸éŠ·æ¯€ç‰©ä»¶ï¼Œé˜²æ­¢å¡æ­»)
            gameStarted = false;
            isHiddenEnding = false; 
            const isWin = toppledObjectsCount >= totalToppleableCount * 0.5;
            
            // 3. ç™½å±é®ç½©æ·¡å…¥ (è¦–è¦ºå„ªå…ˆ)
            const overlay = document.getElementById('ending-overlay');
            const loadingText = document.getElementById('cleanup-loading-text');

            overlay.style.display = 'block';
            overlay.style.zIndex = '9999'; 
            overlay.style.opacity = '0';
            if (loadingText) loadingText.style.display = 'block'; // é¡¯ç¤ºè¼‰å…¥ä¸­æ–‡å­—
        
            void overlay.offsetWidth; // å¼·åˆ¶é‡ç¹ª
            
            // è¨­å®š 3 ç§’æ·¡å…¥ï¼Œçµ¦ç€è¦½å™¨å–˜æ¯æ™‚é–“
            overlay.style.transition = 'opacity 3.0s ease-in-out';
            overlay.style.opacity = '1';

            // 4. [é—œéµ] ä»€éº¼éƒ½ä¸åšï¼Œè®“ç•«é¢å…ˆè®Šç™½ã€‚
            // æˆ‘å€‘æŠŠã€Œå›åˆ°æ¨™é¡Œã€çš„å‹•ä½œå»¶å¾Œï¼Œè®“ç™½å±å‹•ç•«å…ˆè·‘å®Œï¼Œé€™æ¨£ç©å®¶å°±ä¸æœƒæ„Ÿè¦ºåˆ°å¡é “ã€‚
        
            // 3ç§’å¾Œ (ç™½å±å®Œå…¨è®Šç™½) åŸ·è¡Œå ´æ™¯åˆ‡æ›
            setTimeout(() => {
                pauseGradualCleanup(); // åœæ­¢èƒŒæ™¯æ¸…ç†
                if (loadingText) loadingText.style.display = 'none';
            
                if (isWin) {
                    // è´äº† -> å›æ¨™é¡Œ (é€™æ™‚å€™ç•«é¢å…¨ç™½ï¼Œå·æ›å ´æ™¯ä¸æœƒè¢«ç™¼ç¾)
                    returnToStartScreen();
                    
                    // ç¨å¾®ç­‰ä¸€ä¸‹å†æ·¡å‡ºç™½å±
                    requestAnimationFrame(() => {
                        overlay.style.transition = 'opacity 3.0s ease-in-out';
                        overlay.style.opacity = '0';
                        setTimeout(() => { overlay.style.display = 'none'; }, 3000);
                    });
                } else {
                    // è¼¸äº† -> é€²åœ–ç‰‡ 2/3
                    startEndingPhase2();
                }

            }, 3000);
        }

        // [ä¿®æ­£] åˆå§‹åŒ–æ³¡æ³¡æ±  (è‡ªå‹•ä¿®å¾©æå£çš„æ³¡æ³¡ï¼Œè§£æ±ºé‡ç©æ¶ˆå¤±èˆ‡å¡é “å•é¡Œ)
        function initBubblePool() {
            if (!sharedBubbleGeo || (sharedBubbleGeo.id === undefined)) { 
                sharedBubbleGeo = new THREE.SphereGeometry(1.5, 8, 8); 
            }
            if (!sharedBubbleMat || (sharedBubbleMat.id === undefined)) { // ç°¡å–®æª¢æŸ¥æè³ªæ˜¯å¦æœ‰æ•ˆ
                sharedBubbleMat = new THREE.MeshBasicMaterial({ color: 0x88ddff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
            }

            // 2. æª¢æŸ¥ç¾æœ‰æ± å­
            if (bubblePool.length > 0) {
                let needsRebuild = false;
                if (!bubblePool[0].mesh.geometry || !bubblePool[0].mesh.parent) {
                    needsRebuild = true;
                }

                if (!needsRebuild) {
                    bubblePool.forEach(p => {
                        p.active = false;
                        if (p.mesh) {
                            p.mesh.visible = false;
                            p.mesh.position.set(0, -999, 0);
                        }
                    });
                    return;
                } else {
                    bubblePool = [];
                }
            }

            // 3. å»ºç«‹/é‡å»ºæ³¡æ³¡
            for (let i = 0; i < MAX_BUBBLES; i++) {
                const bubble = new THREE.Mesh(sharedBubbleGeo, sharedBubbleMat);
                bubble.visible = false;
                bubble.position.set(0, -999, 0);
                bubble.renderOrder = 999;
                scene.add(bubble); // ç¢ºä¿åŠ å…¥å ´æ™¯
                
                bubblePool.push({
                    mesh: bubble,
                    active: false,
                    velocity: new THREE.Vector3(),
                    life: 0
                });
            }
        }

        // [ä¿®æ­£] ç™¼å°„è—è‰²æ³¡æ³¡ (æ¥µè‡´å„ªåŒ–ç‰ˆï¼šä½¿ç”¨ç‰©ä»¶æ± )
        function fireBubbleShot() {
            if (bubbleCooldown > 0) return;
            
            // è¨­å®šå†·å»èˆ‡ UI (é€™éƒ¨åˆ†ä¿æŒä¸è®Š)
            bubbleCooldown = bubbleMaxCooldown;
            const ring = document.querySelector('#bubble-shoot-button .cooldown-ring circle');
            const ammoText = document.getElementById('bubble-ammo-count'); 

            if (ammoText) ammoText.textContent = '0';
            if(ring) {
                ring.style.transition = 'none';
                ring.style.strokeDashoffset = '239';
                setTimeout(() => {
                    ring.style.transition = `stroke-dashoffset ${bubbleMaxCooldown/1000}s linear`;
                    ring.style.strokeDashoffset = '0';
                }, 10);
            }
            setTimeout(() => { if (ammoText) ammoText.textContent = '15'; }, bubbleMaxCooldown);

            // ç²å–ç›¸æ©Ÿæ–¹å‘
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const startPos = player.position.clone();
            startPos.y = 69;

            // [ä¿®æ”¹] å¾æ± å­ä¸­ç™¼å°„ 15 é¡†
            let firedCount = 0;
            for (let i = 0; i < bubblePool.length; i++) {
                if (firedCount >= 15) break; // å°„æ»¿15é¡†å°±åœ

                const p = bubblePool[i];
                if (!p.active) {
                    p.active = true;
                    p.life = 3.0;
                    p.mesh.visible = true;
                    p.mesh.position.copy(startPos);
                    
                    // æ•£å°„é‚è¼¯
                    const spreadX = (Math.random() - 0.5) * 0.8;
                    const spreadY = (Math.random() - 0.5) * 0.5;
                    const spreadZ = (Math.random() - 0.5) * 0.8;
                    
                    p.velocity.copy(camDir).add(new THREE.Vector3(spreadX, spreadY, spreadZ)).normalize().multiplyScalar(60);
                    
                    firedCount++;
                }
            }
        }

        // [æ¥µè‡´å„ªåŒ–] éš±è—çµå±€å°ˆç”¨å…±ç”¨è®Šæ•¸ (é¿å…åœ¨è¿´åœˆä¸­ new ç‰©ä»¶)
        const _he_vec3_a = new THREE.Vector3();
        const _he_vec3_b = new THREE.Vector3();
        const _he_quat_a = new THREE.Quaternion();
        const _he_axisY = new THREE.Vector3(0, 1, 0);
        const _he_tempDiff = new THREE.Vector3();
        const _he_calc_vec = new THREE.Vector3(); 
        
        // [æ–°å¢] ç‰©ç†é‹ç®—å°ˆç”¨ç·©å­˜ (è§£æ±ºå°„æ“Šå¡é “)
        const _he_hit_velocity = new THREE.Vector3();
        const _he_rot_axis = new THREE.Vector3();
        
        // [æ–°å¢] å¤©ç©ºé¡è‰²ç·©å­˜ (è§£æ±ºé•·æ™‚é–“éŠç©å¾Œçš„è¨˜æ†¶é«”å¡æ­»)
        const _he_sky_start = new THREE.Color(0xf6f9fa); // äº®ç™½
        const _he_fog_start = new THREE.Color(0xf4f6f7); // äº®ç™½éœ§
        
        // [æ–°å¢] æ•¸å­¸å·¥å…·ï¼šè¨ˆç®—é»åˆ°ç·šæ®µçš„æœ€çŸ­è·é›¢å¹³æ–¹ (ç”¨æ–¼æŸ±èº«ç¢°æ’)
        function distToSegmentSquared(p, v, w) {
            const l2 = v.distanceToSquared(w);
            if (l2 === 0) return p.distanceToSquared(v);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.z - v.z) * (w.z - v.z)) / l2; // åªè¨ˆç®— XZ å¹³é¢
            t = Math.max(0, Math.min(1, t));
            const distSq = (p.x - (v.x + t * (w.x - v.x))) ** 2 + (p.z - (v.z + t * (w.z - v.z))) ** 2;
            return distSq;
        }

        // [æ¥µè‡´æ•ˆèƒ½ä¿®å¾©ç‰ˆ] éš±è—çµå±€é‚è¼¯ (å¼·åˆ¶ä¼‘çœ æ©Ÿåˆ¶ï¼Œæœçµ•å¡æ­»)
        function updateHiddenEndingLogic(delta) {
            // 1. æ›´æ–°å†·å»èˆ‡è­·ç›¾
            if (bubbleCooldown > 0) bubbleCooldown -= delta * 1000;
            if (playerBossShield) {
                playerBossShield.rotation.y += delta * 0.25; 
                playerBossShield.rotation.z += delta * 0.125;
            }
        
            // 2. ç’°å¢ƒæ°›åœæ¼¸è®Š
            if (endingState.triggerGloomy) {
                const gloomyElapsed = performance.now() - endingState.gloomyStartTime;
                if (gloomyElapsed < 4100) { 
                    const progress = Math.min(gloomyElapsed / 4000, 1.0); 
                    if (scene.background.isColor) scene.background.lerpColors(_he_sky_start, new THREE.Color(0x786a11), progress);
                    scene.fog.color.lerpColors(_he_fog_start, new THREE.Color(0x64401e), progress);
                    ambientLight.intensity = THREE.MathUtils.lerp(0.9, 0.4, progress);
                    directionalLight.intensity = THREE.MathUtils.lerp(0.5, 0.3, progress);
                }
            } else if (totalToppleableCount > 0 && toppledObjectsCount >= totalToppleableCount * 0.5) {
                if (!endingState.triggerGloomy) { 
                    endingState.triggerGloomy = true;
                    endingState.gloomyStartTime = performance.now();
                    _he_sky_start.copy(scene.background);
                    _he_fog_start.copy(scene.fog.color);
                }
            }

            // 3. æ³¡æ³¡å­å½ˆåˆ¤å®š
            // [å„ªåŒ–] åå‘è¿´åœˆï¼Œä¸”åªæª¢æŸ¥é‚„åœ¨ç•«é¢å…§çš„
            for (let i = bubblePool.length - 1; i >= 0; i--) {
                const p = bubblePool[i];
                if (!p.active) continue; 

                p.life -= delta;
                p.mesh.position.addScaledVector(p.velocity, delta);

                if (p.life <= 0 || p.mesh.position.y < -20) {
                    p.active = false;
                    p.mesh.visible = false;
                    p.mesh.position.set(0, -999, 0);
                    continue;
                }

                let hit = false;
                
                // [é—œéµä¿®æ­£] åªå°ã€Œé‚„ç«™è‘—ã€æˆ–ã€Œæ­£åœ¨å€’ã€çš„ç‰©ä»¶åšåˆ¤å®šï¼Œå·²æ­»ç‰©ä»¶ç•¥é
                const checkList = bossLevelTargets; 
                for (let j = 0; j < checkList.length; j++) {
                    const obs = checkList[j];
                    if (!obs.visible || obs.position.y < -50) continue;
                    
                    // ç²—ç•¥è·é›¢ç¯©é¸ (å¤§å¹…æå‡æ•ˆèƒ½)
                    if (Math.abs(p.mesh.position.x - obs.position.x) > 12 || Math.abs(p.mesh.position.z - obs.position.z) > 12) continue;

                    const hitRadius = (obs.userData.collisionRadius || 5) + 2;
                    const distSqXZ = (p.mesh.position.x - obs.position.x)**2 + (p.mesh.position.z - obs.position.z)**2;

                    if (distSqXZ > hitRadius * hitRadius) continue;
                    
                    const height = obs.userData.isColumn ? 66.0 : 20;
                    if (p.mesh.position.y > 0 && p.mesh.position.y < height) {
                        hit = true;
                        triggerObjectTopple(obs, p.velocity);
                        break;
                    }
                }

                if (!hit) {
                    for (const duck of duckManager.ducks) {
                        if (duck.state === 'visible' || duck.state === 'vibrating') {
                            if (Math.abs(p.mesh.position.x - duck.group.position.x) > 20 || Math.abs(p.mesh.position.z - duck.group.position.z) > 20) continue;
                            const distSq = p.mesh.position.distanceToSquared(duck.group.position);
                            const hitR = duck.radius + 3;
                            if (distSq < hitR * hitR) {
                                hit = true; duck.hp = 0; 
                                if (duck.state !== 'charging' && duck.state !== 'dying') {
                                    if (duck.isSpecial) { duck.state = 'dying'; duck.vibrateEndTime = performance.now() + 500; } 
                                    else { duck.state = 'vibrating'; duck.vibrateEndTime = performance.now() + 5100; duck.normalMesh.visible = false; duck.angryMesh.visible = true; }
                                }
                                break;
                            }
                        }
                    }
                }
                if (hit) { p.active = false; p.mesh.visible = false; p.mesh.position.set(0, -999, 0); }
            }
        
            // 4. ç‰©ä»¶å€’å¡Œç‰©ç†é‹ç®— (æ¥µè‡´å„ªåŒ–æ ¸å¿ƒ)
            // [é—œéµ] ä¸€æ—¦ç‰©ä»¶ã€Œç¢°æ’ã€æˆ–ã€Œå€’åˆ°åº•ã€ï¼Œç«‹åˆ»å°‡å…¶ç§»é™¤å‡º active list
            for (let i = bossLevelTargets.length - 1; i >= 0; i--) {
                const obs = bossLevelTargets[i];
                
                // é›™é‡ä¿éšªï¼šå¦‚æœå·²å€’å¡Œï¼Œç›´æ¥ç§»é™¤ï¼Œä¸å†é‹ç®—
                if (obs.userData.isToppled && !obs.userData.isToppling) {
                    bossLevelTargets.splice(i, 1);
                    continue;
                }

                if (obs.userData.isToppling) {
                    const data = obs.userData.toppleData;
                    
                    // [å¼·åˆ¶ä¼‘çœ ] å¦‚æœå·²ç¶“å€’è¶…é 2 ç§’ (å‡è¨­å€¼)ï¼Œå¼·åˆ¶è¦–ç‚ºå€’å¡Œå®Œæˆï¼Œé˜²æ­¢ç„¡é™éœ‡å‹•
                    if (!data.startTime) data.startTime = performance.now();
                    if (performance.now() - data.startTime > 2000) {
                        obs.userData.isToppling = false;
                        obs.userData.isToppled = true;
                        toppledObjectsCount++;
                        bossLevelTargets.splice(i, 1); // å¼·åˆ¶ç§»é™¤
                        continue;
                    }

                    const nextProgress = data.progress + delta * 0.8;
                    const height = data.objHeight || 66; 
                    const nextAngle = (Math.PI / 2) * Math.sin(nextProgress * Math.PI / 2);

                    _he_quat_a.setFromAxisAngle(data.axis, nextAngle);
                    _he_vec3_a.copy(_he_axisY).applyQuaternion(obs.quaternion); 
                    const currentQuat = _he_quat_a.multiply(data.initialQuat); 
                    
                    _he_calc_vec.copy(_he_axisY).applyQuaternion(currentQuat);
                    _he_vec3_b.copy(obs.position).addScaledVector(_he_calc_vec, height);

                    let hasCollision = false;
                    const impactRadius = height + 8; // ç¸®å°æª¢æŸ¥ç¯„åœ
                
                    // ç¢°æ’æª¢æŸ¥ï¼šåªæª¢æŸ¥ã€Œå…¶ä»–é‚„åœ¨å‹•çš„ã€æˆ–ã€Œé‚„åœ¨åå–®å…§çš„ã€
                    // ç‚ºäº†æ•ˆèƒ½ï¼Œæˆ‘å€‘çŠ§ç‰²ä¸€é»ç‰©ç†ç²¾ç¢ºåº¦ï¼Œä¸å°å·²ç¶“å®Œå…¨éœæ­¢çš„å±é«”åšç²¾ç´°ç¢°æ’
                    for (let k = 0; k < bossLevelTargets.length; k++) {
                        const other = bossLevelTargets[k];
                        if (other === obs) continue;
                        
                        // å¿«é€Ÿæ’é™¤
                        if (Math.abs(obs.position.x - other.position.x) > impactRadius) continue;
                        if (Math.abs(obs.position.z - other.position.z) > impactRadius) continue;

                        const r = (other.userData.collisionRadius || 10) + 2; 

                        // ç°¡åŒ–åˆ¤å®š
                        const h = other.userData.isColumn ? 66 : 20;
                        const distDiffX = _he_vec3_b.x - other.position.x;
                        const distDiffZ = _he_vec3_b.z - other.position.z;
                        
                        // å¦‚æœé ­éƒ¨æ’åˆ°åˆ¥äººçš„èº«é«”ç¯„åœ
                        if (_he_vec3_b.y < h && (distDiffX*distDiffX + distDiffZ*distDiffZ) < r*r) {
                            hasCollision = true; 
                            break;
                        }
                    }
                
                    if (hasCollision) {
                        // æ’åˆ°äº† -> åœæ­¢å€’å¡Œï¼Œè¦–ç‚ºå·²å€’å¡Œï¼Œç§»é™¤å‡ºåå–®
                        obs.userData.isToppling = false;
                        obs.userData.isToppled = true;
                        toppledObjectsCount++;
                        triggerGlobalShake(10, 300);
                        bossLevelTargets.splice(i, 1); // [é—œéµ] ç§»é™¤ï¼
                    } else {
                        data.progress = nextProgress;
                        if (data.progress < 1) {
                            const angle = (Math.PI / 2) * Math.sin(data.progress * Math.PI / 2);
                            _he_quat_a.setFromAxisAngle(data.axis, angle);
                            obs.quaternion.copy(data.initialQuat).premultiply(_he_quat_a);
                            const riseAmount = Math.sin(angle) * data.radiusOffset;
                            obs.position.y = data.initialY + riseAmount;
                        } else {
                            // å€’åˆ°åº•äº† -> åœæ­¢ï¼Œè¦–ç‚ºå·²å€’å¡Œï¼Œç§»é™¤å‡ºåå–®
                            _he_quat_a.setFromAxisAngle(data.axis, Math.PI / 2);
                            obs.quaternion.copy(data.initialQuat).premultiply(_he_quat_a);
                            obs.position.y = data.initialY + data.radiusOffset;
                            obs.userData.isToppling = false;
                            obs.userData.isToppled = true;
                            toppledObjectsCount++;
                            triggerGlobalShake(15, 500);
                            bossLevelTargets.splice(i, 1); // [é—œéµ] ç§»é™¤ï¼
                        }
                    }
                }
            }
        }

        // [ä¿®æ­£] è§¸ç™¼ç‰©ä»¶å€’ä¸‹ (ä¿®æ­£æ–¹å‘èˆ‡ç´€éŒ„é«˜åº¦ï¼Œé›¶åƒåœ¾ç”¢å‡ºç‰ˆ)
        function triggerObjectTopple(obj, hitVelocity) {
            if (obj.userData.isToppled || obj.userData.isToppling) return;

            obj.userData.isToppling = true;
            
            // 1. [ç‰©ç†ä¿®æ­£] è¨ˆç®—å€’å¡Œæ—‹è½‰è»¸ (ä½¿ç”¨å…¨åŸŸè®Šæ•¸ï¼Œä¸ new ç‰©ä»¶)
            _he_hit_velocity.copy(hitVelocity).normalize();
            _he_rot_axis.crossVectors(_he_axisY, _he_hit_velocity).normalize();
            
            // 2. å–å¾—åŠå¾‘èˆ‡é«˜åº¦åƒæ•¸
            const radius = obj.userData.collisionRadius || 5;
            const height = obj.userData.isColumn ? 66 : (obj.userData.targetHeight || 20);
            const offset = obj.userData.isColumn ? radius : (radius * 0.65);

            // é€™è£¡å¿…é ˆå‰µå»ºæ–°ç‰©ä»¶ä¾†å„²å­˜ç‹€æ…‹ï¼Œä½†é€™æ˜¯å¿…è¦çš„ä¸”æ•¸é‡æœ‰é™
            obj.userData.toppleData = {
                progress: 0,
                axis: _he_rot_axis.clone(), // é€™è£¡éœ€è¦ clone å­˜ä¸‹ä¾†ï¼Œå› ç‚º _he_rot_axis æœƒè¢«è¦†å¯«
                initialQuat: obj.quaternion.clone(),
                initialY: obj.position.y,
                radiusOffset: offset,
                objHeight: height 
            };
        }

        // [å…¨æ–°] å›åˆ°é–‹å§‹ç•«é¢ (éš±è—æŒ‰éˆ•)
        function returnToStartScreen() {
            pauseGradualCleanup();
            cleanupQueue = []; 
            
            // 1. å¼·åŠ›éš±è—æ‰€æœ‰éŠæˆ²ä»‹é¢
            const elementsToHide = [
                gameOverScreen, endingOverlay, endingContainer, sanBarUI, 
                document.getElementById('chromatic-red'),
                document.getElementById('chromatic-blue'),
                treasureCanvas, collectionUI.container, 
                bossHpContainer, chaosHpContainer,
                document.getElementById('trauma-vignette-canvas'),
                vignetteCanvas, glitchCanvas,
                document.getElementById('shoot-button'),
                document.getElementById('debug-win-btn'),
                document.getElementById('debug-hidden-win-btn'), // [é—œéµ] åœ¨æ¨™é¡Œç•«é¢æ™‚éš±è—ï¼Œé–‹å§‹éŠæˆ²å¾Œç”± resetGame é¡¯ç¤º
                document.getElementById('status-effect-container')
            ];
            
            elementsToHide.forEach(el => {
                if(el) {
                    el.style.display = 'none';
                    el.style.opacity = '0';
                    el.style.zIndex = '-1'; 
                }
            });

            if (gameOverScreen) {
                gameOverScreen.style.display = 'none';
                gameOverScreen.style.zIndex = '-1';
                gameOverScreen.removeEventListener('pointerdown', returnToStartScreen);
            }

            statusEffectManager.clearAll();
            statusEffectManager.activeStatuses = [];

            const endIcon = document.getElementById('end-door-icon');
            if (endIcon) endIcon.style.display = 'none';

            // 2. é¡¯ç¤ºé–‹å§‹ç•«é¢
            startScreen.style.display = 'flex';
            startScreen.style.opacity = '1';
            startScreen.style.zIndex = '1000';
            startScreen.style.pointerEvents = 'auto';

            if (infoIcon) { infoIcon.style.display = 'block'; infoIcon.style.opacity = '1'; infoIcon.style.zIndex = '1001'; }
            if (brainIcon) { brainIcon.style.display = 'block'; brainIcon.style.opacity = '1'; brainIcon.style.zIndex = '1001'; }
            if (startBgContainer) startBgContainer.style.opacity = '1';
            if (startFgImage) startFgImage.style.opacity = '1';
            
            gameOver = false;
            gameStarted = false;
            window.isRestarting = true; 

            startScreen.removeEventListener('pointerup', handleFirstClick);
            startScreen.removeEventListener('pointerup', startGameHandler);
            
            if (window.isRestarting) {
                startScreen.addEventListener('pointerdown', () => {
                     startScreen.addEventListener('pointerup', startGameHandler, { once: true });
                }, { once: true });
            } else {
                startScreen.addEventListener('pointerup', handleFirstClick, { once: true });
            }
        }

// [å…¨æ–°] æª¢æŸ¥ä¸¦è«‹æ±‚å…¨è¢å¹•çš„å°ˆç”¨å‡½å¼
function requestFullScreenIfNeeded() {
    if (!document.fullscreenElement) { // æª¢æŸ¥æ˜¯å¦å·²åœ¨å…¨è¢å¹•æ¨¡å¼
        const elem = document.documentElement;
        if (elem.requestFullscreen) {
            elem.requestFullscreen().catch(err => {
                console.log(`å…¨è¢å¹•è«‹æ±‚å¤±æ•—: ${err.message}`);
            });
        }
    }
}

        function handleFirstClick(e) {
            // 1. æª¢æŸ¥æ˜¯å¦æœ‰è¦–çª—é–‹å•Ÿ (é˜²å‘†)
            const infoModal = document.getElementById('info-modal');
            const brainModal = document.getElementById('brain-modal');
            
            const isInfoOpen = infoModal && infoModal.style.display === 'flex';
            const isBrainOpen = brainModal && brainModal.style.display === 'flex';

            if (isInfoOpen || isBrainOpen) {
                if (isInfoOpen) hideInfoModal();
                if (isBrainOpen) brainModal.style.display = 'none';
                return;
            }

            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleDeviceTilt);
                            startScreen.removeEventListener('pointerup', handleFirstClick);
                            startScreen.addEventListener('pointerup', startGameHandler, { once: true });
                            
                            console.log("é™€èºå„€æ¬Šé™å·²å–å¾—ï¼Œè«‹å†æ¬¡é»æ“Šä»¥é–‹å§‹éŠæˆ²");
                        } else {
                            startGameHandler();
                        }
                    })
                    .catch(console.error);
            } else {
                startGameHandler();
            }
        }

        function startGameHandler() {
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) loadingOverlay.style.display = 'flex';

            requestFullScreenIfNeeded();

            // å®‰å“é–å®šæ©«å‘
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {});
            }

            // é iOS è£ç½®åœ¨é€™è£¡åŠ ç›£è½
            if (!(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function')) {
                window.addEventListener('deviceorientation', handleDeviceTilt);
            }

            setTimeout(() => startGame(), 4200);
        }

        function updateSkyCycle(time) {
            let progress;
            switch(skyCycleState) {
                case 'day': if (time > nextSkyCycleTime) { skyCycleState = 'fadingToNight'; skyCycleTimer = 0; } break;
                case 'fadingToNight': 
                    skyCycleTimer += time - prevTime; progress = Math.min(skyCycleTimer / skyCycleConfig.fadeDuration, 1); 
                    scene.background.lerpColors(originalColors.background, nightColors.background, progress); 
                    scene.fog.color.lerpColors(originalColors.fog, nightColors.fog, progress); 
                    ambientLight.color.lerpColors(originalColors.ambient, nightColors.ambient, progress); 
                    directionalLight.color.lerpColors(originalColors.directional, nightColors.directional, progress);
                    ambientLight.intensity = THREE.MathUtils.lerp(lightIntensities.day.ambient, lightIntensities.night.ambient, progress);
                    directionalLight.intensity = THREE.MathUtils.lerp(lightIntensities.day.directional, lightIntensities.night.directional, progress);
                    if (treasuresFound >= 1 && isInitialGridSize) {
                        const texture = floor.material.map;
                        texture.repeat.set(500 / 20, 500 / 20);
                        isInitialGridSize = false;
                    }
                    if (progress >= 1) { skyCycleState = 'night'; nextSkyCycleTime = time + skyCycleConfig.nightDuration; } 
                    break;
                case 'night': if (time > nextSkyCycleTime) { skyCycleState = 'fadingToDay'; skyCycleTimer = 0; } break;
                case 'fadingToDay': 
                    skyCycleTimer += time - prevTime; progress = Math.min(skyCycleTimer / skyCycleConfig.fadeDuration, 1); 
                    scene.background.lerpColors(nightColors.background, originalColors.background, progress); 
                    scene.fog.color.lerpColors(nightColors.fog, originalColors.fog, progress); 
                    ambientLight.color.lerpColors(nightColors.ambient, originalColors.ambient, progress); 
                    directionalLight.color.lerpColors(nightColors.directional, originalColors.directional, progress);
                    ambientLight.intensity = THREE.MathUtils.lerp(lightIntensities.night.ambient, lightIntensities.day.ambient, progress);
                    directionalLight.intensity = THREE.MathUtils.lerp(lightIntensities.night.directional, lightIntensities.day.directional, progress);
                    if (progress >= 1) { 
                        skyCycleState = 'day'; 
                        birdManager.dailyCrossCount = 0; // [æ–°å¢] æ–°çš„ä¸€å¤©ï¼Œé‡ç½®é³¥çš„ç©¿è¶Šæ¬¡æ•¸
                        const dayDuration = skyCycleConfig.dayDurationMin + Math.random() * (skyCycleConfig.dayDurationMax - skyCycleConfig.dayDurationMin); 
                        nextSkyCycleTime = time + dayDuration;
                    } 
                    break;
            }
        }
        
        function activateFallingPieces() {
            const darkMaterial = new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.4, metalness: 0.2, name: 'Black'});
            const lightMaterial = new THREE.MeshStandardMaterial({color: 0xeeeeee, roughness: 0.4, metalness: 0.2, name: 'White'});
            const piecePool = [ 
                { data: { name: 'pawn', targetHeight: 18 }, mat: darkMaterial, speedRange: [5, 9] }, 
                { data: { name: 'rook', targetHeight: 22 }, mat: lightMaterial, speedRange: [8, 13] }, 
                { data: { name: 'knight', targetHeight: 24 }, mat: darkMaterial, speedRange: [11, 18] },
                { data: { name: 'bishop', targetHeight: 26 }, mat: lightMaterial, speedRange: [9, 15] },
                { data: { name: 'queen', targetHeight: 28 }, mat: darkMaterial, speedRange: [12, 20] },
                { data: { name: 'king', targetHeight: 30 }, mat: lightMaterial, speedRange: [4, 7] },
            ];
            const fallablePieces = [...piecePool, ...piecePool]; 
            for (let i = fallablePieces.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [fallablePieces[i], fallablePieces[j]] = [fallablePieces[j], fallablePieces[i]]; }
            fallingPiecesManager.piecesToFall = fallablePieces;
            fallingPiecesManager.isActive = true; 
            fallingPiecesManager.nextFallTime = performance.now() + 2000; 
            fallingPiecesManager.fallsCompleted = 0;
        }
        
        function startNewFall(time) {
            if (fallingPiecesManager.piecesToFall.length === 0) return;
            const pieceInfo = fallingPiecesManager.piecesToFall.pop(); 
            const piece = createPieceLOD(pieceInfo.data, pieceInfo.mat);
            if(!piece) return;
            const targetPos = player.position.clone(); targetPos.y = 0; const startY = 100; piece.position.set(targetPos.x, startY, targetPos.z); scene.add(piece);
            const shadow = new THREE.Mesh( new THREE.PlaneGeometry(piece.userData.collisionRadius * 2.5, piece.userData.collisionRadius * 2.5), new THREE.MeshBasicMaterial({ map: shadowTexture, transparent: true, alphaTest: 0.01, opacity: 0, color: 0x000000 }) );
            shadow.position.copy(targetPos); shadow.position.y = 0.1; shadow.rotation.x = -Math.PI / 2; scene.add(shadow);
            fallingPiecesManager.currentFall = { piece, shadow, targetPos, startY, startTime: time, duration: 1500, landed: false, landTime: 0, speedRange: pieceInfo.speedRange };
        }

        // [æ–°å¢] é¡¯ç¤ºè­¦å‘Šæ–‡å­—çš„è¼”åŠ©å‡½å¼
        function showSkillWarning(text) {
            const el = document.getElementById('skill-warning');
            if (el) {
                el.textContent = text;
                el.style.opacity = '1';
                
                // å¦‚æœä¹‹å‰æœ‰æ­£åœ¨å€’æ•¸çš„è¨ˆæ™‚å™¨ï¼Œå…ˆæ¸…é™¤ï¼Œé¿å…æ–‡å­—é–ƒçˆ
                if (window.skillWarningTimer) clearTimeout(window.skillWarningTimer);
                
                window.skillWarningTimer = setTimeout(() => {
                    el.style.opacity = '0';
                }, 2000); // 2ç§’å¾Œæ¶ˆå¤±
            }
        }
        
        // [ä¿®æ­£ç‰ˆ] è½åœ°é‚è¼¯ï¼šå€åˆ†ã€ŒæŠ€èƒ½æ£‹å­(éœæ­¢)ã€èˆ‡ã€Œä¸€èˆ¬æ£‹å­(æœƒå‹•)ã€
        function landFallingPiece(fall, time){
            if (fall.landed) return;
            fall.landed = true; 
            fall.landTime = time; 
            fall.piece.position.y = 0;
            if(fall.shadow.parent) scene.remove(fall.shadow);

            if (fall.isSkillPiece) {
                // å¦‚æœæ˜¯æŠ€èƒ½å¬å–šçš„ï¼šè¨­ç‚ºä¸å¯ç§»å‹• (isMovable: false)
                fall.piece.userData = { 
                    ...fall.piece.userData, 
                    isMovable: false, 
                    isSkillPiece: true
                };
            } else {
                // å¦‚æœæ˜¯ä¸€èˆ¬æ‰è½ï¼šç¶­æŒåŸæœ¬é‚è¼¯ (è¨­ç‚ºå¯ç§»å‹• isMovable: true)
                const speed = fall.speedRange[0] + Math.random() * (fall.speedRange[1] - fall.speedRange[0]);
                fall.piece.userData = { 
                    ...fall.piece.userData, 
                    isMovable: true, 
                    moveAxis: Math.random() > 0.5 ? 'x' : 'z', 
                    range: 100 + Math.random() * 200, 
                    speed: 0, 
                    direction: Math.random() > 0.5 ? 1 : -1, 
                    initialPos: fall.piece.position.clone(), 
                    isFallen: true, 
                    landTime: time, 
                    targetSpeed: speed, 
                    acceleration: speed / 1.5 
                };
            }

            obstacles.push(fall.piece);
            unstickFromObstacles(fall.piece);
        }

        function unstickFromObstacles(movedObject) {
            const maxIterations = 5;
            let iteration = 0;
            let overlapped;
            do {
                overlapped = false;
                for (const staticObject of obstacles) {
                    if (staticObject === movedObject || !staticObject.userData) continue;
                    const distXZ = Math.hypot(movedObject.position.x - staticObject.position.x, movedObject.position.z - staticObject.position.z);
                    const combinedRadius = (movedObject.userData.collisionRadius || 0) + (staticObject.userData.collisionRadius || staticObject.userData.radius || 0);

                    if (distXZ < combinedRadius && distXZ > 0.001) {
                        overlapped = true;
                        const penetration = combinedRadius - distXZ;
                        const correction = movedObject.position.clone().sub(staticObject.position).setY(0).normalize();
                        movedObject.position.add(correction.multiplyScalar(penetration));
                    }
                }
                iteration++;
            } while (overlapped && iteration < maxIterations);
        }

        // [ä¿®æ­£ç‰ˆ] è®“ç•Œå¤–æ£‹å­è‡ªç„¶å¢œè½è‡³æ·±æ·µï¼Œä¸å†åœé “
        function updateFallingPieces(time, delta) {
            if (window.skillFalls && window.skillFalls.length > 0) {
                for (let i = window.skillFalls.length - 1; i >= 0; i--) {
                    const skillFall = window.skillFalls[i];
                    const elapsed = time - skillFall.startTime;
                    
                    // è¶…æ™‚ç§»é™¤
                    if (elapsed > 5000) {
                        if (skillFall.shadow && skillFall.shadow.parent) scene.remove(skillFall.shadow);
                        if (skillFall.piece && skillFall.piece.parent) scene.remove(skillFall.piece);
                        window.skillFalls.splice(i, 1);
                        continue;
                    }

                    const fallProgress = Math.min(elapsed / skillFall.duration, 1);
                    
                    // é™°å½±è™•ç† (åªæœ‰éæ·±æ·µæ‰è½æ‰æœ‰é™°å½±)
                    if (!skillFall.isVoidFall && skillFall.shadow) {
                        const shadowProgress = 1 - Math.pow(1 - fallProgress, 3);
                        skillFall.shadow.material.opacity = shadowProgress;
                    }
                    
                    if (!skillFall.landed) {
                        // [é—œéµä¿®æ­£] æ‰è½é«˜åº¦è¨ˆç®—
                        let verticalY;
                        
                        if (skillFall.isVoidFall) {
                            // A. æ·±æ·µæ‰è½æ¨¡å¼ï¼š
                            const targetVoidY = -100;
                            verticalY = skillFall.startY + (targetVoidY - skillFall.startY) * (elapsed / skillFall.duration);
                        } else {
                            verticalY = skillFall.startY - skillFall.startY * (1 - Math.pow(1 - fallProgress, 2));
                        }
                        
                        skillFall.piece.position.set(skillFall.targetPos.x, verticalY, skillFall.targetPos.z);
                        
                        // [ç§»é™¤åˆ¤å®š] æ‰åˆ°åœ°åº•æ·±è™• (-60) ç§»é™¤
                        if (verticalY < -60) {
                            if (skillFall.shadow && skillFall.shadow.parent) scene.remove(skillFall.shadow);
                            if (skillFall.piece && skillFall.piece.parent) scene.remove(skillFall.piece);
                            window.skillFalls.splice(i, 1);
                            continue;
                        }
                        
                        if (!skillFall.isVoidFall) {
                            if (fallProgress >= 1 || verticalY <= 0) {
                                skillFall.piece.position.y = 0;
                                const playerDist = player.position.clone().setY(0).distanceTo(skillFall.targetPos);
                                const playerCollisionRadius = skillFall.piece.userData.playerCollisionRadius || skillFall.piece.userData.collisionRadius;
                                if (playerDist < playerCollisionRadius + playerRadius) {
                                    takeDamage(21, true); 
                                }
                                landFallingPiece(skillFall, time);
                                window.skillFalls.splice(i, 1);
                            } else if (verticalY < 2.1) {
                                const playerDist = player.position.clone().setY(0).distanceTo(skillFall.targetPos);
                                const playerCollisionRadius = skillFall.piece.userData.playerCollisionRadius || skillFall.piece.userData.collisionRadius;
                                if (playerDist < playerCollisionRadius + playerRadius) {
                                    takeDamage(21, true); 
                                    skillFall.piece.position.y = 0;
                                    landFallingPiece(skillFall, time);
                                    window.skillFalls.splice(i, 1);
                                }
                            }
                        }
                    }
                }
            }

            // --- åŸæœ¬çš„éš¨æ©Ÿæ‰è½é‚è¼¯ (ä¿æŒä¸è®Š) ---
            if (gameOver || !fallingPiecesManager.isActive || (fallingPiecesManager.fallsCompleted >= fallingPiecesManager.totalFalls && !fallingPiecesManager.currentFall)) return;
            
            if (fallingPiecesManager.currentFall) {
                const fall = fallingPiecesManager.currentFall; const elapsed = time - fall.startTime; 
                if(elapsed > 5000) { 
                    fall.piece.position.copy(fall.targetPos);
                    landFallingPiece(fall, time);
                    fallingPiecesManager.currentFall = null; 
                    return;
                }
                const fallProgress = Math.min(elapsed / fall.duration, 1);
                const shadowProgress = 1 - Math.pow(1 - fallProgress, 3);
                fall.shadow.material.opacity = shadowProgress; 
                if (!fall.landed) {
                    fall.piece.position.y = fall.startY - fall.startY * (1 - Math.pow(1 - fallProgress, 2));
                    if (fallProgress >= 1) {
                        const playerDist = player.position.clone().setY(0).distanceTo(fall.targetPos);
                        const playerCollisionRadius = fall.piece.userData.playerCollisionRadius || fall.piece.userData.collisionRadius;
                        if (playerDist < playerCollisionRadius + playerRadius) { 
                            takeDamage(21, true); 
                        }
                        landFallingPiece(fall, time);
                        fallingPiecesManager.currentFall = null;
                    } else {
                        if (fall.piece.position.y < 2.1) {
                             const playerDist = player.position.clone().setY(0).distanceTo(fall.targetPos);
                             const playerCollisionRadius = fall.piece.userData.playerCollisionRadius || fall.piece.userData.collisionRadius;
                             if (playerDist < playerCollisionRadius + playerRadius) {
                                 takeDamage(21, true); 
                                 fall.piece.position.copy(fall.targetPos); 
                                 landFallingPiece(fall, time);
                                 fallingPiecesManager.currentFall = null;
                             }
                        }
                    }
                }
            } else if (time >= fallingPiecesManager.nextFallTime && fallingPiecesManager.fallsCompleted < fallingPiecesManager.totalFalls) { 
                startNewFall(time); 
                fallingPiecesManager.nextFallTime = time + fallingPiecesManager.interval; 
                fallingPiecesManager.fallsCompleted++; 
            }
        }
        
        function activateSmileyBalls() { smileyBallManager.isActive = true; smileyBallManager.nextSpawnTime = performance.now() + 1000; }
        function spawnNewBall() {
            const radius = 12; 
            const geo = new THREE.SphereGeometry(radius, 32, 16);
            const mat = new THREE.MeshStandardMaterial({ map: smileyTexture, roughness: 0.8, metalness: 0.1 });
            const ballMesh = new THREE.Mesh(geo, mat);
            
            const playerPos = player.position;
            const dists = [ { side: 0, dist: boundary - playerPos.x }, { side: 1, dist: playerPos.x - (-boundary) }, { side: 2, dist: boundary - playerPos.z }, { side: 3, dist: playerPos.z - (-boundary) } ];
            dists.sort((a,b) => a.dist - b.dist);
            const spawnSide = dists[0].side;
            let spawnPos = new THREE.Vector3();
            const spacing = (boundary * 2) / 7;
            const gapIndex = Math.floor(Math.random() * 7);
            const randomCoord = -boundary + spacing * (gapIndex + 0.5);

            let moveDirection = new THREE.Vector3();
            if (spawnSide === 0) { // Right edge
                spawnPos.set(boundary + radius, -radius * 2, randomCoord); 
                moveDirection.set(-1, 0, 0);
            } else if (spawnSide === 1) { // Left edge
                spawnPos.set(-boundary - radius, -radius * 2, randomCoord); 
                moveDirection.set(1, 0, 0);
            } else if (spawnSide === 2) { // Top edge
                spawnPos.set(randomCoord, -radius * 2, boundary + radius); 
                moveDirection.set(0, 0, -1);
            } else { // Bottom edge
                spawnPos.set(randomCoord, -radius * 2, -boundary - radius); 
                moveDirection.set(0, 0, 1);
            }
            ballMesh.position.copy(spawnPos);
            
            scene.add(ballMesh);
            ballMesh.userData = { isMovable: false, collisionRadius: radius, isSmiley: true };
            obstacles.push(ballMesh);
            smileyBallManager.activeBalls.push({
                mesh: ballMesh,
                velocity: moveDirection.multiplyScalar(12),
                state: 'spawning', verticalVelocity: 40, lastDamageTime: 0, bounceBoost: 0,
            });
            smileyBallManager.spawnsCompleted++;
        }

        function updateSmileyBalls(time, delta) {
            if (!smileyBallManager.isActive || (smileyBallManager.spawnsCompleted >= smileyBallManager.totalSpawns && smileyBallManager.activeBalls.length === 0)) return;
            if (smileyBallManager.spawnsCompleted < smileyBallManager.totalSpawns && time >= smileyBallManager.nextSpawnTime) { 
                spawnNewBall(); smileyBallManager.nextSpawnTime = time + smileyBallManager.interval; }
            
            for (let i = smileyBallManager.activeBalls.length - 1; i >= 0; i--) {
                const ball = smileyBallManager.activeBalls[i];
                const ballMesh = ball.mesh;
                const radius = ballMesh.userData.collisionRadius;
                
                if (ball.state === 'spawning') {
                    ballMesh.position.y += ball.verticalVelocity * delta; ball.verticalVelocity -= 98 * delta;
                    if (ballMesh.position.y <= radius) { ballMesh.position.y = radius; ball.state = 'rolling'; }
                } else if (ball.state === 'rolling') {
                    ballMesh.position.y = radius;
                    
                    let moveVector = ball.velocity.clone();
                    if (ball.bounceBoost > 0) { moveVector.multiplyScalar(1 + ball.bounceBoost); ball.bounceBoost = Math.max(0, ball.bounceBoost - 4 * delta); }
                    
                    ballMesh.position.add(moveVector.clone().multiplyScalar(delta));
                    
                    for (const obs of obstacles) {
                        if (obs === ballMesh || obs.userData.isPortalBlocker) continue;
                        const distXZ = Math.hypot(ballMesh.position.x - obs.position.x, ballMesh.position.z - obs.position.z);
                        const combinedRadius = radius + (obs.userData.collisionRadius || 0);
                        if (distXZ < combinedRadius) {
                           const penetration = combinedRadius - distXZ;
                           const normal = ballMesh.position.clone().sub(obs.position).setY(0).normalize();
                           ballMesh.position.add(normal.clone().multiplyScalar(penetration));
                           const speed = ball.velocity.length();
                           ball.velocity.reflect(normal).setLength(speed);
                           ball.bounceBoost = 2;
                        }
                    }

                    const rotationAxis = new THREE.Vector3(ball.velocity.z, 0, -ball.velocity.x).normalize();
                    const rotationAmount = moveVector.length() * delta / radius;
                    ballMesh.rotateOnWorldAxis(rotationAxis, rotationAmount);
                    
                    if (Math.abs(ballMesh.position.x) > boundary + radius * 2 || Math.abs(ballMesh.position.z) > boundary + radius * 2) { 
                        ball.state = 'falling'; 
                        ball.verticalVelocity = 0; 
                    }
                } else if (ball.state === 'falling') {
                    ballMesh.position.y += ball.verticalVelocity * delta; ball.verticalVelocity -= 98 * delta;
                    if (ballMesh.position.y < -50) {
                        scene.remove(ballMesh); 
                        const obsIndex = obstacles.indexOf(ballMesh);
                        if (obsIndex > -1) obstacles.splice(obsIndex, 1);
                        ballMesh.geometry.dispose(); if(ballMesh.material.map) ballMesh.material.map.dispose(); ballMesh.material.dispose();
                        smileyBallManager.activeBalls.splice(i, 1);
                    }
                }
            }
        }

        function updateLightning(time, delta) {
            if (!lightningManager.isActive || skyCycleState !== 'night' || gameOver) {
                const targetAmb = (skyCycleState === 'night') ? lightIntensities.night.ambient : lightIntensities.day.ambient;
                const targetDir = (skyCycleState === 'night') ? lightIntensities.night.directional : lightIntensities.day.directional;
                if(Math.abs(ambientLight.intensity - targetAmb) > 0.01) ambientLight.intensity = THREE.MathUtils.lerp(ambientLight.intensity, targetAmb, delta * 5);
                if(Math.abs(directionalLight.intensity - targetDir) > 0.01) directionalLight.intensity = THREE.MathUtils.lerp(directionalLight.intensity, targetDir, delta * 5);
                return;
            }

            if (lightningManager.state === 'idle' && time > lightningManager.nextFlashTime) {
                lightningManager.state = 'flashing';
                lightningManager.flashCount = Math.floor(Math.random() * 3) + 1;
                lightningManager.flashTimer = 0;
            }
            if (lightningManager.state === 'flashing') {
                lightningManager.flashTimer += delta;
                const flashProgress = Math.sin(lightningManager.flashTimer * 30);
                if (flashProgress > 0) {
                    ambientLight.intensity = lightIntensities.night.ambient + flashProgress * 2.5;
                    directionalLight.intensity = lightIntensities.night.directional + flashProgress * 2.5;
                } else {
                    ambientLight.intensity = lightIntensities.night.ambient;
                    directionalLight.intensity = lightIntensities.night.directional;
                }
                
                if (lightningManager.flashTimer > Math.PI / 30 * lightningManager.flashCount) {
                     lightningManager.state = 'idle';
                     lightningManager.nextFlashTime = time + 1500 + Math.random() * 3000;
                     ambientLight.intensity = lightIntensities.night.ambient;
                     directionalLight.intensity = lightIntensities.night.directional;
                }
            }
        }
        
        function activateChaosOrb() {
            if (chaosOrb.active) return;
            chaosOrb.active = true;

            setTimeout(() => {
                // [ä¿®æ­£] æª¢æŸ¥éŠæˆ²æ˜¯å¦å·²é‡ç½®
                if (!gameStarted || !chaosOrb.active) return;

                if (!chaosOrb.mesh) {
                    const orbGeo = new THREE.IcosahedronGeometry(4, 5);
                    chaosOrb.mesh = new THREE.Mesh(orbGeo, chaosOrbMaterial);
                    const light = new THREE.PointLight(0xffffff, 0, 300, 1.5);
                    chaosOrb.light = light;
                    chaosOrb.mesh.add(light);
                    
                    const laserGroup = new THREE.Group();
                    const laserGeo = new THREE.CylinderGeometry(2.4, 0.8, 150, 8, 1, true);
                    laserGeo.translate(0, 75, 0);
                    laserGeo.rotateX(Math.PI / 2);
                    for(let i = 0; i < 24; i++) {
                        const laser = new THREE.Mesh(laserGeo, laserMaterial.clone());
                        laser.quaternion.setFromEuler(new THREE.Euler(
                            Math.random() * Math.PI * 2,
                            Math.random() * Math.PI * 2,
                            Math.random() * Math.PI * 2
                        ));
                        laserGroup.add(laser);
                    }
                    chaosOrb.laserBeams = laserGroup;
                    chaosOrb.mesh.add(laserGroup);
                    
                    // [ä¿®æ­£] é€™è£¡ä¸å†å»ºç«‹ 3D è¡€æ¢
                }
                
                // åˆå§‹åŒ–è¡€é‡èˆ‡å—å‚·å‡½å¼
                chaosOrb.maxHP = 90;
                chaosOrb.currentHP = 90;
                
                // [æ–°å¢] ç”¨æ–¼æ§åˆ¶ UI é¡¯ç¤ºçš„è¨ˆæ™‚å™¨
                chaosOrb.uiTimer = 0; 

                // [ä¿®æ­£] å—å‚·å‡½å¼ï¼Œåš´æ ¼å€åˆ†ä¾†æº
                chaosOrb.takeDamage = function(amount, source) {
                    if (!this.active || this.state === 'despawning' || this.state === 'flying_to_boss' || this.state === 'attached_to_boss') return;
                    
                    this.currentHP -= amount;
                    
                    if (chaosHpContainer) chaosHpContainer.style.display = 'flex';
                    if (chaosHpContainer && chaosHpFill) {
                        chaosHpContainer.classList.add('visible'); 
                        chaosHpContainer.style.opacity = ''; 
                        this.uiTimer = 3000; 
                        const pct = Math.max(0, (this.currentHP / this.maxHP) * 100);
                        chaosHpFill.style.width = `${pct}%`;
                    }

                    if (this.currentHP <= 0) {
                        if (source === 'boss' && bossManager.active && bossManager.mesh && bossManager.mesh.visible) {
                            this.state = 'flying_to_boss';
                        } 
                        else {
                            this.state = 'despawning';
                            this.attackStartTime = performance.now() - 5000;
                        }
                    }
                };

                chaosOrb.lightFlash = { active: true, startTime: performance.now(), duration: 2000, maxIntensity: 200 };
                
                chaosOrb.mesh.position.set(0, 15, 0);
                chaosOrb.mesh.material.uniforms.u_dissolve.value = 0.0;
                
                // ç¢ºä¿ UI ä¸€é–‹å§‹æ˜¯æ»¿è¡€ä¸”éš±è—çš„
                if(chaosHpContainer) chaosHpContainer.classList.remove('visible');
                if(chaosHpFill) chaosHpFill.style.width = '100%';

                scene.add(chaosOrb.mesh);
                chaosOrb.state = 'intro';
                
                playerLookDisabled = true;
                const lookAtDuration = 1000;
                const startTime = performance.now();
                const startPlayerRotY = player.rotation.y;
                const startCameraRotX = camera.rotation.x;
                const eyePosition = new THREE.Vector3();
                camera.getWorldPosition(eyePosition);
                const direction = chaosOrb.mesh.position.clone().sub(eyePosition).normalize();
                const targetPlayerRotY = Math.atan2(-direction.x, -direction.z);
                const horizontalDist = Math.hypot(direction.x, direction.z);
                const targetCameraRotX = Math.atan2(direction.y, horizontalDist);
                function lerpAngle(start, end, t) {
                    let delta = end - start;
                    if (delta > Math.PI) delta -= 2 * Math.PI;
                    if (delta < -Math.PI) delta += 2 * Math.PI;
                    return start + delta * t;
                }
                function forceLook() {
                    // ä¸­æ–·åˆ¤å®š
                    if (!gameStarted || !chaosOrb.active || chaosOrb.state === 'idle') {
                        playerLookDisabled = false;
                        return;
                    }

                    const elapsed = performance.now() - startTime;
                    const progress = Math.min(elapsed / lookAtDuration, 1);
                    const easedProgress = 1 - Math.pow(1 - progress, 3);
                    player.rotation.y = lerpAngle(startPlayerRotY, targetPlayerRotY, easedProgress);
                    camera.rotation.x = THREE.MathUtils.lerp(startCameraRotX, targetCameraRotX, easedProgress);
                    if (progress < 1) {
                        requestAnimationFrame(forceLook);
                    } else {
                        player.rotation.y = targetPlayerRotY;
                        camera.rotation.x = targetCameraRotX;
                        playerLookDisabled = false;
                        chaosOrb.state = 'stalking';
                    }
                }
                forceLook();

            }, 500);
        }
        
        function updateVignetteEffect(time) {
            const w = vignetteCanvas.width;
            const h = vignetteCanvas.height;
            const centerX = w / 2;
            const centerY = h / 2;
            
            vignetteCtx.clearRect(0, 0, w, h);

            const gradient = vignetteCtx.createRadialGradient(centerX, centerY, w * 0.25, centerX, centerY, w * 0.7);
            gradient.addColorStop(0, 'rgba(108, 20, 126, 0)');
            gradient.addColorStop(1, 'rgba(88, 10, 106, 0.9)');
            vignetteCtx.fillStyle = gradient;
            vignetteCtx.fillRect(0, 0, w, h);
            
            const tentacleCount = 12;
            vignetteCtx.lineCap = 'round';
            
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

            // [èª¿æ•´ 1] æ¨¡ç³Šç¨‹åº¦æ§åˆ¶
            // æ‰‹æ©Ÿ(å°è¢å¹•)ç´„ 20pxï¼Œé›»è…¦(å¤§è¢å¹•)é™åˆ¶åœ¨ 45pxï¼Œé¿å…ç³Šåˆ°æ¶ˆå¤±
            let blurAmount = Math.min(45, Math.max(20, w * 0.02)); 

            if (!isIOS) {
                vignetteCtx.globalCompositeOperation = 'screen'; 
                vignetteCtx.shadowBlur = 0;
                // PC/Android ä½¿ç”¨æ¿¾é¡æ¨¡ç³Š
                vignetteCtx.filter = `blur(${blurAmount}px)`; 
            }

            for (let i = 0; i < tentacleCount; i++) {
                const angle = (i / tentacleCount) * Math.PI * 2;
                const baseRadius = Math.min(w, h) * 0.6;

                const path = new Path2D();
                const startX = centerX + Math.cos(angle) * baseRadius;
                const startY = centerY + Math.sin(angle) * baseRadius;
                path.moveTo(startX, startY);
                
                const length = 450 + Math.sin(time * 0.0005 * (i * 0.5 + 1)) * 150;
                const segments = 20;
                for (let j = 1; j < segments; j++) {
                    const t = j / segments;
                    const radius = baseRadius - t * length;
                    
                    const wobbleAngle = angle + Math.sin(t * 5 + time * 0.001) * 0.3 * (1 - t);
                    const wobbleX = centerX + Math.cos(wobbleAngle) * radius;
                    const wobbleY = centerY + Math.sin(wobbleAngle) * radius;
                    path.lineTo(wobbleX, wobbleY);
                }
                
                // [èª¿æ•´ 2] æé«˜ä¸é€æ˜åº¦ (Alpha)
                // åŸæœ¬æ˜¯ 0.15ï¼Œç¾åœ¨æå‡åˆ° 0.4 èµ·è·³ï¼Œç¢ºä¿æ¨¡ç³Šå¾Œä¾ç„¶æ¸…æ™°å¯è¦‹
                const alpha = 0.4 + (Math.sin(time * 0.0008 + i * 2) + 1) / 2 * 0.3; 
                
                // [èª¿æ•´ 3] ç¨å¾®åŠ ç²—ç·šæ¢ï¼Œå¢åŠ å­˜åœ¨æ„Ÿ
                const lineWidth = (35 + (Math.cos(time * 0.0007 + i) + 1) / 2 * 45);

                if (isIOS) {
                    // [iOS ç¶­æŒé™°å½±æ–¹æ¡ˆ] 
                    // é™°å½±åŠå¾‘ä¹ŸåšåŒæ¨£é™åˆ¶
                    const iosBlur = Math.min(50, Math.max(25, w * 0.03)); 
                    
                    vignetteCtx.globalCompositeOperation = 'source-over';
                    vignetteCtx.shadowBlur = iosBlur; 
                    vignetteCtx.shadowColor = `rgba(200, 130, 235, ${alpha})`; // é€™è£¡ alpha é«˜ä¸€é»æ²’é—œä¿‚
                    vignetteCtx.strokeStyle = 'rgba(0,0,0,0)'; 
                    vignetteCtx.lineWidth = lineWidth;
                    vignetteCtx.filter = 'none';
                    vignetteCtx.stroke(path);
                    vignetteCtx.shadowBlur = 0;
                } else {
                    // [PC/Android]
                    vignetteCtx.strokeStyle = `rgba(200, 130, 235, ${alpha})`;
                    vignetteCtx.lineWidth = lineWidth;
                    vignetteCtx.stroke(path);
                }
            }
            
            vignetteCtx.globalCompositeOperation = 'source-over';
            vignetteCtx.filter = 'none';
        }

        function updateChaosOrb(time, delta) {
            // [ä¿®æ­£] UI è¡€æ¢æ·¡å‡ºé‚è¼¯
            if (chaosOrb.uiTimer > 0) {
                chaosOrb.uiTimer -= delta * 1000;
                if (chaosOrb.uiTimer <= 0) {
                    if (chaosHpContainer) {
                        chaosHpContainer.classList.remove('visible');
                        chaosHpContainer.style.opacity = '';
                    }
                }
            }

            if (chaosOrb.lightFlash && chaosOrb.lightFlash.active) {
                const elapsed = time - chaosOrb.lightFlash.startTime;
                if (elapsed < chaosOrb.lightFlash.duration) {
                    const progress = elapsed / chaosOrb.lightFlash.duration;
                    const intensity = Math.sin(progress * Math.PI) * chaosOrb.lightFlash.maxIntensity;
                    chaosOrb.light.intensity = intensity;
                    const opacity = Math.sin(progress * Math.PI) * 0.7;
                    chaosOrb.laserBeams.children.forEach((laser, i) => {
                       laser.material.uniforms.u_opacity.value = opacity;
                       laser.rotation.y += delta * (i % 2 === 0 ? 0.5 : -0.5);
                       laser.rotation.z += delta * (i % 3 === 0 ? 0.3 : -0.3);
                    });
                } else {
                    chaosOrb.light.intensity = 0;
                    chaosOrb.laserBeams.children.forEach(laser => laser.material.uniforms.u_opacity.value = 0);
                    chaosOrb.lightFlash.active = false;
                }
            }
            
            if (!chaosOrb.active || chaosOrb.state === 'idle' || chaosOrb.state === 'intro') return;
            
            chaosOrb.mesh.material.uniforms.u_time.value = time * 0.001;
            
            // --- ç‹€æ…‹æ©Ÿé‚è¼¯ ---
            if (chaosOrb.state === 'stalking') {
                projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                cameraFrustum.setFromProjectionMatrix(projScreenMatrix);
                const isOnScreen = cameraFrustum.intersectsObject(chaosOrb.mesh);
                
                if (isOnScreen) {
                    vignetteCanvas.style.display = 'none';
                } else {
                    vignetteCanvas.style.display = 'block';
                    updateVignetteEffect(time);
                    const moveDir = player.position.clone().sub(chaosOrb.mesh.position);
                    moveDir.y = 0;
                    chaosOrb.mesh.position.add(moveDir.normalize().multiplyScalar(22 * delta));
                    chaosOrb.mesh.position.y = 15;
                }
                
                const distanceXZ = Math.hypot(player.position.x - chaosOrb.mesh.position.x, player.position.z - chaosOrb.mesh.position.z);
                if (distanceXZ < 6) {
                    chaosOrb.state = 'attacking';
                    chaosOrb.attackStartTime = time;
                    chaosOrb.lastSanDrainTime = time;
                    takeDamage(10, true);
                    vignetteCanvas.style.display = 'none';
                }

            } else if (chaosOrb.state === 'attacking') {
                const targetPos = new THREE.Vector3(player.position.x, 5, player.position.z);
                chaosOrb.mesh.position.lerp(targetPos, delta * 5);

                if (time > chaosOrb.lastSanDrainTime + 1000) {
                    takeDamage(10, true);
                    chaosOrb.lastSanDrainTime = time;
                }
                if (time > chaosOrb.attackStartTime + 5000) {
                    chaosOrb.state = 'despawning';
                }

            } else if (chaosOrb.state === 'flying_to_boss') {
                if (bossManager.mesh) {
                    // Vector3(0, 32, 25) ä»£è¡¨ï¼šç›¸å°æ–¼ BOSS è…³åº•ï¼Œå¾€ä¸Š 32 (é ­éƒ¨é«˜åº¦)ï¼Œå¾€è‡‰å‰ 25
                    const localOffset = new THREE.Vector3(0, 33, 27).applyQuaternion(bossManager.mesh.quaternion);
                    const targetPos = bossManager.mesh.position.clone().add(localOffset);

                    chaosOrb.mesh.position.lerp(targetPos, delta * 3);
                    
                    if (chaosOrb.mesh.position.distanceTo(targetPos) < 2) {
                        chaosOrb.state = 'attached_to_boss';
                        chaosOrb.attachStartTime = time;
                    }
                } else {
                    chaosOrb.state = 'despawning'; 
                }

            } else if (chaosOrb.state === 'attached_to_boss') {
                if (bossManager.mesh) {
                    // [æ–°å¢] æ¨™è¨˜å…‰çƒå·²è¢« BOSS å¸æ”¶ (è§¸ç™¼éš±è—çµå±€æ¢ä»¶1)
                    hasChaosOrbBeenAbsorbed = true; 
                    // [å®Œç¾ä¿®æ­£] é™„èº«æ™‚åŒæ¨£ä½¿ç”¨å€åŸŸåº§æ¨™ï¼Œç¢ºä¿æ­»æ­»é»åœ¨è‡‰å‰
                    const localOffset = new THREE.Vector3(0, 33, 27).applyQuaternion(bossManager.mesh.quaternion);
                    chaosOrb.mesh.position.copy(bossManager.mesh.position).add(localOffset);
                    
                    // [æ™‚é–“èª¿æ•´] é€™è£¡æ§åˆ¶é™„èº«æŒçºŒæ™‚é–“ 5000 (å³ 5 ç§’)
                    if (time > chaosOrb.attachStartTime + 6600) { 
                        chaosOrb.state = 'despawning';
                        chaosOrb.attackStartTime = time - 6600; 
                    }
                } else {
                    chaosOrb.state = 'despawning';
                }

            } else if (chaosOrb.state === 'despawning') {
                const despawnDuration = 1500;
                let progress = 0;
                if (time > chaosOrb.attackStartTime + 5000) {
                     progress = Math.min((time - (chaosOrb.attackStartTime + 5000)) / despawnDuration, 1.0);
                } else {
                     progress += delta * 2; 
                }
                
                chaosOrb.mesh.material.uniforms.u_dissolve.value = progress;
                
                // æ¶ˆå¤±æ™‚ä¹Ÿéš±è— UI
                if (chaosHpContainer) chaosHpContainer.classList.remove('visible');
                
                if (progress >= 1 || chaosOrb.mesh.material.uniforms.u_dissolve.value >= 1) {
                    chaosOrb.active = false;
                    chaosOrb.state = 'idle';
                    scene.remove(chaosOrb.mesh);
                    vignetteCanvas.style.display = 'none';
                }
            }
        }
        
        function drawMagicCircle(time) {
            const ctx = treasureCtx;
            const w = 110; const h = 110;
            const center = { x: w/2, y: h/2 };
            ctx.clearRect(0,0,w,h);

            if(magicCircle.finish.active) {
                const elapsed = time - magicCircle.finish.startTime;
                const progress = Math.min(elapsed / magicCircle.finish.duration, 1.0);
                const scale = 1.0 + progress * 0.5;
                const alpha = 1.0 - progress;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(center.x, center.y);
                ctx.scale(scale, scale);
                ctx.translate(-center.x, -center.y);
                drawMagicCircleBase(time, true);
                ctx.restore();

                if (progress >= 1 && !magicCircle.finish.textFired) {
                    const tcText = document.getElementById('treasure-counter-text');
                    tcText.textContent = 'é€šå¾€çœŸå¯¦çš„å¤§é–€å·²é–‹å•Ÿ';
                    tcText.style.display = 'block';
                    setTimeout(() => tcText.style.opacity = '1', 10);
                    magicCircle.finish.textFired = true;
                }
                return;
            }

            let glow = 8;
            let color = 'rgba(255, 255, 255, 0.8)';
            if (magicCircle.flash.active) {
                const elapsed = time - magicCircle.flash.startTime;
                if (elapsed < magicCircle.flash.duration) {
                    const flashProgress = (Math.sin(elapsed / (magicCircle.flash.duration / (6 * Math.PI))) + 1) / 2;
                    glow = 8 + flashProgress * 12;
                    const r = Math.floor(255 + (255 - 255) * flashProgress);
                    const g = Math.floor(255 + (215 - 255) * flashProgress);
                    const b = Math.floor(255 + (0 - 255) * flashProgress);
                    color = `rgba(${r}, ${g}, ${b}, ${0.8 + flashProgress * 0.2})`;
                } else {
                    magicCircle.flash.active = false;
                }
            }

            drawMagicCircleBase(time, false, color, glow);
        }

        function drawMagicCircleBase(time, isRainbow = false, color = 'white', glow = 8) {
            const ctx = treasureCtx;
            const w = 110; const h = 110;
            const center = { x: w/2, y: h/2 };
                
            // --- ç¹ªè£½åŸæœ¬çš„å…­èŠ’æ˜Ÿçµæ§‹ (ç¨‹å¼ç¢¼ä¸è®Š) ---
            const r_star_tips = 38; 
            const side_length = r_star_tips * 2;
            const r_outermost = side_length * Math.SQRT2 / 2;
            ctx.lineCap = 'round'; ctx.lineWidth = 1.5;
            ctx.save(); ctx.translate(center.x, center.y);
            ctx.save(); ctx.rotate(magicCircle.rotations.sq2);
            ctx.strokeStyle = isRainbow ? `hsl(${time*0.1 % 360}, 100%, 75%)` : color;
            ctx.shadowColor = isRainbow ? `hsl(${time*0.1 % 360}, 100%, 75%)` : 'gold';
            ctx.shadowBlur = glow * 1.5; ctx.strokeRect(-side_length/2, -side_length/2, side_length, side_length); ctx.restore();
            ctx.save(); ctx.rotate(magicCircle.rotations.sq1 + Math.PI / 4);
            ctx.strokeStyle = isRainbow ? `hsl(${(time*0.1 + 180) % 360}, 100%, 75%)` : color;
            ctx.shadowColor = isRainbow ? `hsl(${(time*0.1 + 180) % 360}, 100%, 75%)` : 'gold';
            ctx.shadowBlur = glow * 1.5; ctx.strokeRect(-side_length/2, -side_length/2, side_length, side_length); ctx.restore();
            ctx.strokeStyle = isRainbow ? `hsl(${(time*0.1 + 90) % 360}, 100%, 75%)` : color;
            ctx.shadowColor = isRainbow ? `hsl(${(time*0.1 + 90) % 360}, 100%, 75%)` : 'gold';
            ctx.shadowBlur = glow; ctx.beginPath(); ctx.arc(0, 0, r_outermost, 0, Math.PI * 2); ctx.stroke();
            ctx.rotate(magicCircle.rotations.star); ctx.strokeStyle = isRainbow ? `hsl(${(time*0.1 + 270) % 360}, 100%, 75%)` : color;
            const points = [];
            for (let i = 0; i < 6; i++) { const angle = (i * 60 - 90) * Math.PI / 180; points.push({ x: Math.cos(angle) * r_star_tips, y: Math.sin(angle) * r_star_tips }); }
            ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); ctx.lineTo(points[2].x, points[2].y); ctx.lineTo(points[4].x, points[4].y); ctx.closePath(); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(points[1].x, points[1].y); ctx.lineTo(points[3].x, points[3].y); ctx.lineTo(points[5].x, points[5].y); ctx.closePath(); ctx.stroke();
            ctx.beginPath(); ctx.arc(0, 0, r_star_tips, 0, Math.PI * 2); ctx.stroke();
            const circleRadius = 7.1; const circleCenterRadius = r_star_tips - circleRadius - 1;
            for (let i = 0; i < 6; i++) {
                const angle = (i * 60 - 60) * Math.PI / 180;
                const cx = Math.cos(angle) * circleCenterRadius; const cy = Math.sin(angle) * circleCenterRadius;
                ctx.beginPath(); ctx.arc(cx, cy, circleRadius, 0, Math.PI * 2);
                if (i < magicCircle.collectedColors.length) {
                    ctx.fillStyle = magicCircle.collectedColors[i]; ctx.shadowColor = magicCircle.collectedColors[i];
                    ctx.shadowBlur = 15; ctx.fill(); ctx.shadowBlur = 0;
                }
                ctx.stroke();
            }
            ctx.restore();
        
            // --- [å…¨æ–°] ç¹ªè£½æ—¥æœˆ (å°ºå¯¸ã€ä½ç½®ã€é¡è‰²ã€å…‰æšˆå·²å®Œå…¨é‡å¯«) ---
            ctx.save();
            ctx.translate(center.x, center.y);
        
            const orbitRadius = 9.6;    // å…¬è½‰åŠå¾‘
            const moonRadius = 10;      // æœˆäº®å¤§å°
            const sunRadius = 8;       // å¤ªé™½å¤§å° (æ¯”æœˆäº®ç¨å°)
            const moonAngle = magicCircle.orbitAngle;
            const sunAngle = magicCircle.orbitAngle + Math.PI;
        
            // é¡è‰²å®šç¾© (RGBé™£åˆ—ï¼Œæ–¹ä¾¿åšé¡è‰²æ’å€¼)
            const sunColorStart = [255, 255, 224];   // å¹¾ä¹åƒç™½è‰²çš„é»ƒè‰²
            const sunColorEnd = [255, 96, 0];    // æ©˜ç´…è‰²
            const moonColorStart = [224, 240, 255];  // å¹¾ä¹åƒç™½è‰²çš„è—è‰²
            const moonColorEnd = [75, 0, 130];   // æ·±ç´«è‰²
        
            // è¼”åŠ©å‡½å¼ï¼šç·šæ€§æ’å€¼è¨ˆç®—é¡è‰²
            const lerpColor = (start, end, progress) => {
                const r = Math.round(start[0] + (end[0] - start[0]) * progress);
                const g = Math.round(start[1] + (end[1] - start[1]) * progress);
                const b = Math.round(start[2] + (end[2] - start[2]) * progress);
                return `rgb(${r}, ${g}, ${b})`;
            };

            // ç¹ªè£½å¤ªé™½
            ctx.save();
            ctx.translate(Math.cos(sunAngle) * orbitRadius, Math.sin(sunAngle) * orbitRadius);
            ctx.beginPath(); ctx.arc(0, 0, sunRadius, 0, Math.PI * 2);

            const sunCycle = Math.floor(magicCircle.yangEnergy / 6); // è¨ˆç®—ç›®å‰æ˜¯ç¬¬å¹¾è¼ª (0, 1, 2...)
            const sunProgress = magicCircle.yangEnergy > 0 ? ((magicCircle.yangEnergy - 1) % 6) / 5 : 0; // è¨ˆç®—åœ¨æœ¬è¼ªä¸­çš„é€²åº¦ (0.0 to 1.0)

            ctx.fillStyle = lerpColor(sunColorStart, sunColorEnd, sunProgress); // æ ¹æ“šé€²åº¦è¨ˆç®—å¡«è‰²
            ctx.fill();

            // [ä¿®æ”¹] è®“æ¡†ç·šèˆ‡å…‰æšˆé¡è‰²ã€å¼·åº¦éƒ½æ ¹æ“šè¼ªæ¬¡è®ŠåŒ–
            const isSunAltCycle = (sunCycle % 2 === 1);
            ctx.strokeStyle = isSunAltCycle ? 'rgba(255, 36, 0, 1)' : color; // ç¬¬äºŒè¼ªè®Šç‚ºäº®ç´…è‰²æ¡†ç·š
            ctx.shadowColor = isSunAltCycle ? 'red' : 'gold';
            ctx.shadowBlur = isSunAltCycle ? glow * 1.8 : glow; // ç¬¬äºŒè¼ªå…‰æšˆç¯„åœå¢åŠ 80%
            ctx.stroke();
            ctx.restore();

            // ç¹ªè£½æœˆäº®
            ctx.save();
            ctx.translate(Math.cos(moonAngle) * orbitRadius, Math.sin(moonAngle) * orbitRadius);
            ctx.beginPath();
            ctx.arc(0, 0, moonRadius, -Math.PI * 0.5, Math.PI * 0.5, false);
            ctx.quadraticCurveTo(moonRadius * 0.5, 0, 0, -moonRadius);
            ctx.closePath();

            const moonCycle = Math.floor(magicCircle.yinEnergy / 6);
            const moonProgress = magicCircle.yinEnergy > 0 ? ((magicCircle.yinEnergy - 1) % 6) / 5 : 0;

            ctx.fillStyle = lerpColor(moonColorStart, moonColorEnd, moonProgress);
            ctx.fill();

            // [ä¿®æ”¹] è®“æ¡†ç·šèˆ‡å…‰æšˆé¡è‰²ã€å¼·åº¦éƒ½æ ¹æ“šè¼ªæ¬¡è®ŠåŒ–
            const isMoonAltCycle = (moonCycle % 2 === 1);
            ctx.strokeStyle = isMoonAltCycle ? 'rgba(238, 130, 238, 1)' : color; // ç¬¬äºŒè¼ªè®Šç‚ºäº®ç´«è‰²æ¡†ç·š
            ctx.shadowColor = isMoonAltCycle ? '#EE82EE' : 'gold';
            ctx.shadowBlur = isMoonAltCycle ? glow * 1.8 : glow; // ç¬¬äºŒè¼ªå…‰æšˆç¯„åœå¢åŠ 80%
            ctx.stroke();
            ctx.restore();

            ctx.restore();
        }

    function animate() {
        requestAnimationFrame(animate);
    
    // ä¿éšªï¼šå¦‚æœéŠæˆ²å·²é‡ç½®æˆ–å…‰åœ˜ä¸åœ¨å ´ï¼Œå¼·åˆ¶è§£é–è¦–è§’
    if (playerLookDisabled && (!chaosOrb.active || chaosOrb.state === 'idle' || !gameStarted)) {
        playerLookDisabled = false;
    }
    
    const time = performance.now(); 
    const delta = Math.min((time - prevTime) / 1000, 0.05);
    updateFPS(time);

    // --- 1. å§‹çµ‚åŸ·è¡Œçš„è¦–è¦ºæ›´æ–° ---
    statusEffectManager.updateUI();

    // ä¾µè•ç‰¹æ•ˆï¼šSVG æ¿¾é¡ RGB éŒ¯ä½ + FOV å»£è§’ + å‹•æ…‹å™ªé»
        
        let erosionFactor = 0;
        if (typeof erosionSystem !== 'undefined') {
            erosionFactor = erosionSystem.value / 100;
        }

        const sceneContainer = document.getElementById('scene-container');
        const svgRed = document.getElementById('svg-offset-red');
        const svgBlue = document.getElementById('svg-offset-blue');
        const noiseOverlay = document.getElementById('noise-overlay'); // [æ–°å¢] å–å¾—å™ªé»å±¤

        if (gameStarted && !endingState.active) {
            // --- 1. FOV å»£è§’æ‹‰ä¼¸ (åŒ…å«å‚³é€ç‰¹æ•ˆä¿®æ­£) ---
            if (typeof window.teleportFovOffset === 'undefined') window.teleportFovOffset = 0;

            const targetFOV = 75 + (erosionFactor * 45) + window.teleportFovOffset; // [ä¿®æ”¹] ç–ŠåŠ å‚³é€ç‰¹æ•ˆåç§»
            const fovJitter = (Math.random() - 0.5) * erosionFactor * 2.0;
            camera.fov = THREE.MathUtils.lerp(camera.fov, targetFOV + fovJitter, 0.1);
            camera.updateProjectionMatrix();

            // --- 2. æ§åˆ¶ SVG æ¿¾é¡éŒ¯ä½ ---
            if (erosionFactor > 0.02) {
                if (sceneContainer.style.filter !== 'url(#rgb-split-filter)') {
                    sceneContainer.style.filter = 'url(#rgb-split-filter)';
                }
                const offsetBase = 9 * erosionFactor;

                if (svgRed) svgRed.setAttribute('dx', -offsetBase);
                if (svgBlue) svgBlue.setAttribute('dx', offsetBase);
            } else {
                sceneContainer.style.filter = 'none';
            }

            // --- 3. [æ–°å¢] æ§åˆ¶å™ªé» (Noise) ---
            if (noiseOverlay) {
                if (erosionFactor > 0.05) {
                    noiseOverlay.style.display = 'block';
                    
                    // A. é€æ˜åº¦ï¼šä¾µè•è¶Šé«˜ï¼Œå™ªé»è¶Šæ˜é¡¯ (æœ€é«˜ 0.4ï¼Œé¿å…ç•«é¢å¤ªé«’)
                    noiseOverlay.style.opacity = erosionFactor * 0.3;
                    
                    // B. é¡†ç²’å¤§å°ï¼šä¾µè•è¶Šé«˜ï¼Œé¡†ç²’è¶Šå¤§ (Size å¾ 150px è®Šå¤§åˆ° 300px)
                    // é€™æ¨£æœƒè®“å™ªé»çœ‹èµ·ä¾†æ›´ã€Œç²—ç³™ã€ï¼Œç¬¦åˆä½ èªªçš„ã€Œé»è¶Šå¤§ã€
                    const grainSize = 240 + (erosionFactor * 90); 
                    noiseOverlay.style.backgroundSize = `${grainSize}px ${grainSize}px`;
                    
                } else {
                    noiseOverlay.style.display = 'none';
                }
            }

        } else {
            // éŠæˆ²çµæŸæˆ–æœªé–‹å§‹ï¼šæ¢å¾©æ­£å¸¸
            if (Math.abs(camera.fov - 75) > 0.1) {
                camera.fov = THREE.MathUtils.lerp(camera.fov, 75, 0.1);
                camera.updateProjectionMatrix();
            }
            // é—œé–‰æ¿¾é¡èˆ‡å™ªé»
            sceneContainer.style.filter = 'none';
            if (svgRed) svgRed.setAttribute('dx', 0);
            if (svgBlue) svgBlue.setAttribute('dx', 0);
            if (noiseOverlay) noiseOverlay.style.display = 'none'; // [æ–°å¢] éš±è—å™ªé»
        }
        
        renderer.render(scene, camera);

    // --- 2. é­˜èˆ‡æ­¿å½±çš„ç¨ç«‹æ›´æ–° ---
    if ((gameStarted && !endingState.active) || (endingState.active && endingState.stage === 3)) {
        try {
            moyingManager.update(time, delta);
        } catch(e) { 
        }
    }

    // --- 3. éŠæˆ²é‚è¼¯æ ¸å¿ƒå€å¡Š ---
    // [é—œéµä¿®æ­£] è®“éŠæˆ²é‚è¼¯åœ¨éš±è—çµå±€éšæ®µ3ä¹ŸæŒçºŒé‹ä½œ (ç‚ºäº†è®“æ£‹å­ç¹¼çºŒç§»å‹•ã€ç”¢ç”Ÿç¢°æ’)
    if ((gameStarted && !endingState.active) || (endingState.active && endingState.stage === 3 && isHiddenEnding)) {
        
        updateSkills(time, delta); // [ä¿®æ”¹] çµ±ä¸€æ›´æ–°æŠ€èƒ½ç‹€æ…‹

        // [å„ªåŒ–] éš±è—çµå±€æ™‚ï¼Œåœæ­¢ä¸å¿…è¦çš„ç’°å¢ƒèˆ‡ BOSS é‹ç®—ï¼Œé‡‹æ”¾æ‰‹æ©Ÿæ•ˆèƒ½
        if (!isHiddenEnding) {
            weatherManager.update(time, delta);
            updateFallingPieces(time, delta); 
            updateLightning(time, delta);
            updateChaosOrb(time, delta);
            bossManager.update(time, delta);
            checkBossChaosCollision();
            updateVortex(time, delta);
            updateAttackEffect(time, delta);
            if(summoningCircle.active) updateSummoningCircle(time, delta);
        }
        
        if (playerAttackManager.isReloading && performance.now() > playerAttackManager.reloadEndTime) {
            playerAttackManager.isReloading = false;
            playerAttackManager.currentAmmo = playerAttackManager.maxAmmo;
        }
        updateShootUI();
        updateProjectiles(delta);

        magicCircle.rotations.star += 0.0012;
        magicCircle.rotations.sq1 += 0.002;
        magicCircle.rotations.sq2 -= 0.0015;
        magicCircle.orbitAngle -= delta * 0.5; 
        drawMagicCircle(time);
        shieldCageManager.update(time, delta);

        updateLissajousFigure(time, delta);
        updateSummoningAnimation(time, delta);
        
        updateSmileyBalls(time, delta);
        
        updateTraumaVignette();
        
        updateBird(time, delta);
        
        falseFacadeManager.update(delta);
        updateStatusSystem(time, delta);
        pillarManager.update(time);
        
        duckManager.update(time, delta);
        
    } 
    // --- éŠæˆ²é‚è¼¯å€å¡ŠçµæŸ ---

    if (auroraMaterial) auroraMaterial.uniforms.t.value = time * 0.00015;
    if (portalMaterial) portalMaterial.uniforms.u_time.value = time / 1000;
    if (!endingState.active) {
        updateSkyCycle(time);
    }

            // --- è™•ç†æ­»äº¡å‹•ç•«èˆ‡ UI é¡¯ç¤º ---
            if (gameOverAnimation.active) {
                const elapsed = time - gameOverAnimation.start;
                const progress = Math.min(elapsed / gameOverAnimation.duration, 1);
                const easedProgress = 1 - Math.pow(1 - progress, 3);
                
                const finalCamPos = new THREE.Vector3(player.position.x, player.position.y + 15, player.position.z);
                camera.position.lerpVectors(gameOverAnimation.initialCamPos, finalCamPos, easedProgress);
                const finalCamRot = new THREE.Quaternion().setFromEuler(new THREE.Euler(-PI_2, player.rotation.y, 0, 'YXZ'));
                camera.quaternion.slerp(finalCamRot, easedProgress);
                
                if (progress >= 1) { 
                    gameOverAnimation.active = false;
                    
                    if (gameOverScreen) {
                        gameOverScreen.style.opacity = '1'; 
                        gameOverScreen.style.visibility = 'visible';
                        gameOverScreen.style.display = 'flex';
                        gameOverScreen.style.zIndex = '2000'; 
                        
                        // æ¢å¾©è½‰å ´æ•ˆæœ
                        gameOverScreen.style.transition = 'background-color 1s ease-in-out';

                        setTimeout(() => {
                            const title = gameOverScreen.querySelector('h1');
                            if (title) {
                                title.innerHTML = `
                                    <span class="char1">å·²</span>
                                    <span class="char2">è¿·</span>
                                    <span class="char3">å¤±</span>
                                    <span class="char4">è‡ª</span>
                                    <span class="char5">æˆ‘</span>
                                `;
                                title.style.opacity = '1';
                            }
                            gameOverScreen.style.backgroundColor = 'rgba(0,0,0,0.8)';
                            const pText = gameOverScreen.querySelector('p');
                            if (pText) pText.style.opacity = '1';
                            
                            // é‡æ–°ç¶å®šé»æ“Šäº‹ä»¶
                            gameOverScreen.removeEventListener('pointerdown', returnToStartScreen);
                            gameOverScreen.addEventListener('pointerdown', returnToStartScreen, { once: true });
                        }, 100);
                    }
                }
                renderer.render(scene, camera);
                prevTime = time;
                return;
            }

            if (!gameStarted && !(endingState.active && endingState.stage === 3 && isHiddenEnding)) { 
                renderer.render(scene, camera); 
                prevTime = time; 
                return; 
            }
            
            // --- 4. ç‰©ç†ç¢°æ’èˆ‡æ¨æ“  ---
            let currentlyTouchingPiece = null; 
            let collisionCount = 0;

            if (gameStarted && !endingState.active) {
                const allPushers = obstacles.filter(o => (o.userData.isMovable || o.userData.isSmiley) && o.parent);

                for(const obs of allPushers){
                    const radius = obs.userData.collisionRadius || 0;
                    const distXZ = Math.hypot(player.position.x - obs.position.x, player.position.z - obs.position.z);
                    if (distXZ < playerRadius + radius) {
                        if (obs.userData.isShadow) continue; 

                        collisionCount++; 
                        currentlyTouchingPiece = obs;
                    }
                }

                if (isBeingPushed && !currentlyTouchingPiece) { isBeingPushed = false; pushingPiece = null; } 
                else if (!isBeingPushed && currentlyTouchingPiece) { isBeingPushed = true; pushingPiece = currentlyTouchingPiece; }
            }

            velocity.x *= (1 - 10 * delta);
            velocity.z *= (1 - 10 * delta);

            // ç©å®¶ç§»é€Ÿï¼šéš±è—çµå±€(Stage 3ä¸”æ˜¯éš±è—ç·š)æ”¹ç‚º 120ï¼Œæ­£å¸¸çµå±€(Stage 3)ç¶­æŒ 150ï¼Œä¸€èˆ¬éŠæˆ²ä¸­ç‚º 66
            const baseSpeed = (endingState.stage === 3) ? (isHiddenEnding ? 120 : 150) : 66;
            const playerSpeed = baseSpeed * impatientManager.speedMult; 

            // --- 5. ç©å®¶ç§»å‹• ---
            if (!isBeingPushed && (direction.x !== 0 || direction.z !== 0)) {
                const moveDir = new THREE.Vector3(direction.x, 0, direction.z);
                moveDir.applyQuaternion(player.quaternion).normalize();
                velocity.x += moveDir.x * playerSpeed * delta;
                velocity.z += moveDir.z * playerSpeed * delta;
            }

            // å‰µå‚·åæ‡‰
            if (player.userData.isTraumaActive && !endingState.active) {
                const forward = new THREE.Vector3(0, 0, -1);
                const worldQuaternion = new THREE.Quaternion();
                camera.getWorldQuaternion(worldQuaternion);
                forward.applyQuaternion(worldQuaternion);
                velocity.x += forward.x * TRAUMA_REACTION_CONFIG.AUTO_MOVE_SPEED * delta;
                velocity.z += forward.z * TRAUMA_REACTION_CONFIG.AUTO_MOVE_SPEED * delta;
            }

            // ç¬‘è‡‰çƒæ¨æ“ 
            if(isBeingPushed && pushingPiece && !endingState.active) { 
                let speed = 0;
                if (pushingPiece.userData.isSmiley) {
                    const smileyData = smileyBallManager.activeBalls.find(b => b.mesh === pushingPiece);
                    if (smileyData) { speed = smileyData.velocity.length(); }
                } else {
                    speed = pushingPiece.userData.speed;
                }
            
                if (speed > 0) {
                    const pushDir = player.position.clone().sub(pushingPiece.position).normalize().setY(0);
                    player.position.add(pushDir.multiplyScalar(speed * delta * 0.5));
                }
            
                if (time - lastPushDamageTime > 180) { 
                    const damage = pushingPiece.userData.isSmiley ? 1 : 1;
                    takeDamage(damage, false); 
                    lastPushDamageTime = time; 
                } 
            
                handlePushEffect(pushingPiece, delta, resetYinYang);
            }
            
            player.position.add(velocity.clone().multiplyScalar(delta));
            
            // --- 6. éšœç¤™ç‰©ç¢°æ’ (æ¥µè‡´å„ªåŒ–ç‰ˆï¼šé›¶è¨˜æ†¶é«”æ´©æ¼) ---
            if ((gameStarted && !endingState.active) || (endingState.active && endingState.stage === 3 && isHiddenEnding)) {
                
                // [é—œéµå„ªåŒ–] é å…ˆå»ºç«‹æš«å­˜è®Šæ•¸ï¼Œé¿å…è¿´åœˆå…§é‡è¤‡ new ç‰©ä»¶é€ æˆç•¶æ©Ÿ
                // é€™äº›è®Šæ•¸æœƒåœ¨ä¸‹é¢çš„é‹ç®—ä¸­é‡è¤‡ä½¿ç”¨ï¼Œä¸æœƒç”¢ç”Ÿåƒåœ¾
                const _nextPos = new THREE.Vector3();
                const _tempVec = new THREE.Vector3();
                const _colTop = new THREE.Vector3();
                const _pushVec = new THREE.Vector3();
                const _colAxis = new THREE.Vector3();
                const _up = new THREE.Vector3(0, 1, 0);

                if (!isHiddenEnding) { 
                    for (const obs of obstacles) {
                        if (!obs.parent) continue; 
                        if (obs.userData.isPortalBlocker && !exit_portal.visible) continue;

                        // [æ–°å¢] å¤¢æƒ³ä¹‹é–€å°ˆç”¨ï¼šæ–¹å¡Šç¢°æ’åˆ¤å®š
                        if (obs.userData.isBoxCollision && obs.userData.size) {
                            const localPos = player.position.clone(); // é€™è£¡åªæœ‰é‡å°é–€ï¼Œæ•¸é‡å°‘ï¼Œå¯ä¿ç•™
                            obs.worldToLocal(localPos);
                            const halfW = obs.userData.size.x / 2 + playerRadius;
                            const halfD = obs.userData.size.z / 2 + playerRadius;
                            if (Math.abs(localPos.x) < halfW && Math.abs(localPos.z) < halfD) {
                                const overlapX = halfW - Math.abs(localPos.x);
                                const overlapZ = halfD - Math.abs(localPos.z);
                                if (overlapX < overlapZ) localPos.x = Math.sign(localPos.x) * halfW;
                                else localPos.z = Math.sign(localPos.z) * halfD;
                                const worldPos = localPos.applyMatrix4(obs.matrixWorld);
                                player.position.x = worldPos.x;
                                player.position.z = worldPos.z;
                                velocity.set(0, 0, 0);
                                continue; 
                            }
                            continue; 
                        }

                        // --- åŸæœ¬çš„åœ“å½¢ç¢°æ’åˆ¤å®š (å„ªåŒ–) ---
                        const distXZ = Math.hypot(player.position.x - obs.position.x, player.position.z - obs.position.z);
                        const obsPlayerRadius = obs.userData.playerCollisionRadius || obs.userData.collisionRadius || (obs.userData.radius || 0);
                        const combinedRadius = playerRadius + obsPlayerRadius;

                        if (distXZ < combinedRadius) {
                            if (!obs.userData.isMovable && !obs.userData.isSmiley) collisionCount++;
                            const penetration = combinedRadius - distXZ;
                            
                            // å„ªåŒ–ï¼šä½¿ç”¨ _tempVec é¿å… new Vector3
                            _tempVec.copy(player.position).sub(obs.position).setY(0).normalize();
                            player.position.add(_tempVec.multiplyScalar(penetration));
                            
                            velocity.set(0, 0, 0);
                        }
                    }
                }

                // é‚Šç•Œæª¢æŸ¥
                const atBoundary = Math.abs(player.position.x) > boundary - playerRadius || Math.abs(player.position.z) > boundary - playerRadius;
                if (atBoundary) { collisionCount++; player.position.x = Math.max(-boundary + playerRadius, Math.min(boundary - playerRadius, player.position.x)); player.position.z = Math.max(-boundary + playerRadius, Math.min(boundary - playerRadius, player.position.z)); }
                if (isBeingPushed && collisionCount >= 2 && time - lastClampDamageTime > 500) { takeDamage(30, true); lastClampDamageTime = time; if (pushingPiece && !pushingPiece.userData.isSmiley) { pushingPiece.userData.direction *= -1; } }

                // --- æ£‹å­ç§»å‹•èˆ‡äº’æ’ (é‡ç½å€å„ªåŒ–) ---
                obstacles.forEach((obj, index) => {
                    if (obj.userData.isToppled || obj.userData.isToppling) return;
                    if (!obj || !obj.userData.isMovable || !obj.parent) return;
                    if (obj.userData.isShadow) return;
                    if (obj.isLOD) obj.update(camera);
                    
                    if (obj.userData.isFallen) {
                        if (time > obj.userData.landTime + 500) { 
                            if (obj.userData.speed < obj.userData.targetSpeed) obj.userData.speed += obj.userData.acceleration * delta; 
                            else { obj.userData.speed = obj.userData.targetSpeed; delete obj.userData.isFallen; }
                        }
                    }

                    const { moveAxis, initialPos, range, speed, direction } = obj.userData;
                    
                    // å„ªåŒ–ï¼šä½¿ç”¨ _nextPos é‡è¤‡åˆ©ç”¨ï¼Œä¸ä½¿ç”¨ clone()
                    _nextPos.copy(obj.position);
                    _nextPos[moveAxis] += speed * direction * delta;
                    
                    let reverseDirection = false;

                    // 1. æª¢æŸ¥ç¯„åœ
                    if (Math.abs(_nextPos.x) > boundary || Math.abs(_nextPos.z) > boundary || Math.abs(_nextPos[moveAxis] - initialPos[moveAxis]) >= range / 2) {
                        reverseDirection = true;
                    } else {
                        // 2. äº’æ’æª¢æŸ¥ (åŸæœ¬æœ€å¡çš„åœ°æ–¹ï¼Œå·²å…¨é¢å„ªåŒ–)
                        for(let i = 0; i < obstacles.length; i++){
                            if(index === i || !obstacles[i] || !obstacles[i].parent || (obstacles[i].userData.isPortalBlocker && !exit_portal.visible)) continue;
                            
                            const otherObs = obstacles[i];
                            
                            if (otherObs.userData.isToppled && otherObs.userData.isColumn) {
                                // æŸ±å­ç·šæ®µç¢°æ’ (å„ªåŒ–ï¼šä½¿ç”¨ _colAxis, _colTop)
                                _colAxis.copy(_up).applyQuaternion(otherObs.quaternion);
                                _colTop.copy(otherObs.position).add(_colAxis.multiplyScalar(66));
                                const distSq = distToSegmentSquared(_nextPos, otherObs.position, _colTop); 
                                
                                const combinedRadius = obj.userData.collisionRadius + 10.5;
                                
                                if (distSq < combinedRadius * combinedRadius) {
                                    reverseDirection = true;
                                    if (otherObs.userData.isMovable) otherObs.userData.direction *= -1;
                                    break;
                                }
                            } 
                            else {
                                // ä¸€èˆ¬åœ“å½¢ç¢°æ’
                                const distXZ = Math.hypot(_nextPos.x - otherObs.position.x, _nextPos.z - otherObs.position.z);
                                const combinedRadius = obj.userData.collisionRadius + (otherObs.userData.collisionRadius || (otherObs.userData.radius || 0));

                                if (distXZ < combinedRadius) {
                                    if (otherObs.userData.isShadow) {
                                        const penetration = combinedRadius - distXZ;
                                        // å„ªåŒ–ï¼šä½¿ç”¨ _tempVec
                                        _tempVec.copy(otherObs.position).sub(obj.position).setY(0).normalize();
                                        otherObs.position.add(_tempVec.multiplyScalar(penetration + 0.2));
                                        continue; 
                                    }

                                    reverseDirection = true;
                                    const penetration = combinedRadius - distXZ;
                                    // å„ªåŒ–ï¼šä½¿ç”¨ _pushVec
                                    _pushVec.copy(obj.position).sub(otherObs.position).setY(0).normalize();
                                    if (_pushVec.lengthSq() === 0) _pushVec.set(1, 0, 0);
                                    obj.position.add(_pushVec.multiplyScalar(Math.max(0.5, penetration))); 

                                    if (otherObs.userData.isMovable) {
                                        otherObs.userData.direction *= -1;
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    if (reverseDirection) {
                        obj.userData.direction *= -1;
                    } else {
                        obj.position.copy(_nextPos);
                    }
                    obj.updateMatrixWorld();
                });
            } else if (endingState.active && endingState.stage === 3) {
                // ç©ºä¸–ç•Œé‚Šç•Œé™åˆ¶
                const extendedBoundary = 300;
                const atBoundary = Math.abs(player.position.x) > extendedBoundary - playerRadius || Math.abs(player.position.z) > extendedBoundary - playerRadius;
                if (atBoundary) {
                    player.position.x = Math.max(-extendedBoundary + playerRadius, Math.min(extendedBoundary - playerRadius, player.position.x));
                    player.position.z = Math.max(-extendedBoundary + playerRadius, Math.min(extendedBoundary - playerRadius, player.position.z));
                }
            }
            
            updateScreenShake(player.position);
            
            // --- 7. å¯¶ç‰©æ‹¾å– ---
            if (gameStarted && !endingState.active) {
                let isTouchingAnyTreasure = false;
                for (let i = treasures.length - 1; i >= 0; i--) {
                    const treasure = treasures[i];
                    treasure.rotation.y += .5 * delta;
                    const baseHeight = treasure.userData.isBipyramid ? 2.5 : 2;
                    treasure.position.y = baseHeight + Math.sin(time / 500 + treasure.position.x) * 0.5;

                    if (!gameOver && player.position.distanceTo(treasure.position) < 3.6) {
                        isTouchingAnyTreasure = true;
                        if (collectionState.currentTreasure !== treasure) {
                            collectionState.currentTreasure = treasure;
                            collectionState.timer = 0;
                            collectionState.isCollecting = true;
                            collectionUI.container.style.display = 'flex';
                        }
                        
                        // [æ–°å¢] ç‹©çµå°è¨˜æ•ˆæœï¼šæ‹¾å–é€Ÿåº¦é™ä½ 18% (å‰© 82% é€Ÿåº¦)
                        let collectSpeed = 1000;
                        if (statusEffectManager.hasStatus('huntingMark')) {
                            collectSpeed *= 0.82; 
                        }
                        collectionState.timer += delta * collectSpeed;
                        
                        const progress = Math.min(collectionState.timer / collectionState.duration, 1.0);
                        collectionUI.bar.style.width = `${progress * 100}%`;
                        const colorIndex = Math.min(Math.floor(progress * 6), 5);
                        collectionUI.bar.style.backgroundColor = collectionColors[colorIndex];

                        if (collectionState.timer >= collectionState.duration) {
                            scene.remove(treasure);
                            treasures.splice(i, 1);
                            treasuresFound++;
                            magicCircle.collectedColors.push(treasure.userData.color.getStyle());
                            magicCircle.flash.active = true;
                            magicCircle.flash.startTime = time;
                            collectionState.isCollecting = false;
                            collectionState.currentTreasure = null;
                            collectionUI.container.style.display = 'none';

                            if (treasuresFound === 1 && !fallingPiecesManager.isActive) {
                                activateFallingPieces();
                                createBird();
                                weatherManager.startCycle(); // [æ–°å¢]å•Ÿå‹•æš´é¢¨é›ªè¨ˆæ™‚
                            }
                            if (treasuresFound === 2 && !smileyBallManager.isActive) {
                                activateSmileyBalls();
                            }
                            if (treasuresFound === 3) {
                                if (!lightningManager.isActive) {
                                    lightningManager.isActive = true;
                                    lightningManager.nextFlashTime = performance.now() + 1500 + Math.random() * 3000;
                                }
                                if (!chaosOrb.active && chaosOrb.state === 'idle') {
                                    activateChaosOrb();
                                }
                            }
                            if (treasuresFound === 4 && !duckManager.isActive) {
                                duckManager.init();
                                showShootButton(true); 
                            }
                            if (treasuresFound === 5 && !summoningCircle.active) {
                                activateSummoningPuzzle();
                            }
                            if (treasuresFound === 6) {
                                bossManager.init(); 
                                if (birdManager.isActive) {
                                    birdManager.state = 'fading_out';
                                }
                                if (exit_portal) exit_portal.visible = true;
                                setTimeout(() => {
                                    magicCircle.finish.active = true;
                                    magicCircle.finish.startTime = time;
                                }, magicCircle.flash.duration);
                            }
                            break;
                        }
                    }
                }
                if (!isTouchingAnyTreasure && collectionState.isCollecting) {
                    collectionState.isCollecting = false;
                    collectionState.timer = 0;
                    collectionState.currentTreasure = null;
                    collectionUI.container.style.display = 'none';
                    collectionUI.bar.style.width = '0%';
                }
            } 

            if(exit_portal && exit_portal.visible && !endingState.active) {
                const playerPosRelativeToPortal = player.position.clone(); 
                exit_portal.worldToLocal(playerPosRelativeToPortal); 
                
                if (exit_portal.userData.winZone.containsPoint(playerPosRelativeToPortal)) { 
                    const localVelocity = velocity.clone().applyQuaternion(exit_portal.quaternion.clone().invert()); 
                    if (localVelocity.z < -0.01) { 
                        startEndingSequence();
                    } 
                } 
            }
            prevTime = time;
            // [æ–°å¢] éš±è—çµå±€çš„ç‰¹æ®Šæ›´æ–°è¿´åœˆ
            if (endingState.active && endingState.stage === 3 && isHiddenEnding) {
                updateHiddenEndingLogic(delta);
            }

            // [ä¿®æ­£] è™•ç†éš±è—çµå±€é”æˆæ¢ä»¶å¾Œçš„å¤©ç©ºè®Šè‰² (åªèª¿æ•´å…‰ç…§ï¼ŒèƒŒæ™¯ç”± SkyMesh æ¥æ‰‹)
            if (endingState.triggerGloomy) {
                const gloomyElapsed = time - endingState.gloomyStartTime;
                const gloomyProgress = Math.min(gloomyElapsed / 4000, 1.0);

                // è®“ç’°å¢ƒå…‰è®Šæš—ï¼Œé…åˆç´…é»ƒå¤©ç©ºçš„å£“è¿«æ„Ÿ
                ambientLight.intensity = THREE.MathUtils.lerp(0.9, 0.3, gloomyProgress);
                directionalLight.intensity = THREE.MathUtils.lerp(0.5, 0.2, gloomyProgress);
            }

            renderer.render(scene, camera);
        }
    
        // [æ–°å¢] å°ˆé–€è™•ç† BOSS å­å½ˆæ‰“ä¸­æ··æ²Œå…‰åœ˜çš„åˆ¤å®š
        function checkBossChaosCollision() {
            // å¦‚æœå…‰åœ˜ä¸åœ¨å ´æˆ– BOSS ä¸åœ¨å ´ï¼Œå°±ä¸æª¢æŸ¥
            if (!chaosOrb.active || chaosOrb.state === 'idle' || chaosOrb.state === 'intro' || !bossManager.active) return;
            
            // å˜—è©¦å–å¾— BOSS çš„å­å½ˆé™£åˆ— (ç›¸å®¹å¸¸è¦‹çš„å‘½å: projectiles æˆ– bullets)
            // å¦‚æœæ‚¨çš„ bossManager ä½¿ç”¨ä¸åŒçš„è®Šæ•¸åç¨±å„²å­˜å­å½ˆï¼Œè«‹å°æ‡‰èª¿æ•´é€™è£¡
            const bullets = bossManager.projectiles || bossManager.bullets;
            
            if (!bullets || bullets.length === 0) return;

            const orbPos = chaosOrb.mesh.position;
            // [è¨­å®š] çµ¦äºˆå…‰åœ˜è¼ƒå¤§çš„å—å½ˆåˆ¤å®šåŠå¾‘ (åŸæœ¬æ˜¯ 4ï¼Œé€™è£¡è¨­ 8 è®“å®ƒæ›´å®¹æ˜“è¢«æ‰“ä¸­)
            const hitRadius = 4.0; 

            bullets.forEach(p => {
                // æª¢æŸ¥å­å½ˆæ˜¯å¦å•Ÿç”¨
                if (p.userData && p.userData.active === false) return;
                if (!p.visible) return;

                const dist = p.position.distanceTo(orbPos);
                
                if (dist < hitRadius) {
                    // å‘½ä¸­ï¼å‚³å…¥ 'boss' æ¨™è¨˜
                    chaosOrb.takeDamage(1, 'boss');

                    // éŠ·æ¯€æˆ–éš±è—è©²å­å½ˆ (é¿å…ç©¿é€æˆ–æ˜¯é‡è¤‡æ‰£è¡€)
                    if (p.userData) p.userData.active = false;
                    p.visible = false;
                    p.position.y = -999; // ç§»åˆ°åœ°åº•
                }
            });
        }
    
    </script>
</body>
</html>
